1 packages\frontend\chart.htmlæ¶‰åŠåˆ°å“ªäº›ä»£ç æ–‡ä»¶ï¼Ÿ
2 9å›¾æ¨¡å¼ä¸‹ï¼ŒåŸåˆè®¾è®¡æ„å›¾æ˜¯å¯¹åº”5åˆ†é’Ÿæ¶¨å¹…9ä¸ªå“ç§
ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œ9å›¾å¹¶ä¸æ˜¯


è¯„ä»·ä¸‹ä»¥ä¸‹æ–¹æ¡ˆæ˜¯å¦è¶³å¤Ÿå®Œå¤‡ï¼Œéœ€è¦ä½ è¶³å¤Ÿä¸¥è‹›çš„çœ‹å¾…å’Œè¯„ä»·
1è¯¥æ–¹æ¡ˆæ˜¯å¦è¿˜æœ‰éœ€è¦ä¿®æ”¹ï¼Œå’Œå®Œå¤‡çš„åœ°æ–¹
2è¯¥æ–¹æ¡ˆæ˜¯å¦å¯ä»¥ç›´æ¥ç”¨äºä¿®æ”¹äº†
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
é€šè¿‡åˆ†æä½ çš„æœ¬åœ°ä»£ç å’Œæä¾›çš„é‡æ„æ–¹æ¡ˆï¼Œæˆ‘åˆ¶å®šäº†åŸºäºæºç çš„æœ€ç»ˆä¿®æ”¹æ–¹æ¡ˆã€‚æ ¸å¿ƒæ€è·¯æ˜¯ï¼šä¿ç•™æœ¬åœ°ä»£ç ä¸­ä¼˜ç§€çš„ ClientPool å’Œ ProxyPool æ¶æ„ï¼ˆç‰¹åˆ«æ˜¯ enrich_meme_data ä¸­çš„ä»£ç†æ± é€»è¾‘ï¼‰ï¼Œå°†é‡æ„æ–¹æ¡ˆä¸­çš„â€œå…¨å±€ WebSocket ç®¡ç†â€å’Œâ€œå»¶è¿Ÿé€€è®¢â€é€»è¾‘èåˆè¿›å»ã€‚ä»¥ä¸‹æ˜¯å…·ä½“çš„ä¿®æ”¹æ–¹æ¡ˆï¼šğŸ› ï¸ ä¿®æ”¹ç›®æ ‡è¿æ¥èšåˆï¼šåºŸå¼ƒ binance_websocket_task å•æˆ¿é—´å•è¿æ¥æ¨¡å¼ï¼Œæ”¹ä¸º 2 ä¸ªå…¨å±€é•¿è¿æ¥ï¼ˆKline Manager + Tick Managerï¼‰ã€‚é«˜æ€§èƒ½è·¯ç”±ï¼šå¼•å…¥ RoomIndexï¼Œæ”¶åˆ° Tick æ•°æ®æ—¶ O(1) å®šä½æˆ¿é—´ï¼Œä¸å†éå†ã€‚é˜²æŠ–ä¸å»¶è¿Ÿé€€è®¢ï¼šå®ç° 60ç§’ Lazy Cancelï¼Œè§£å†³åˆ·æ–°é¡µé¢å¯¼è‡´çš„è¿æ¥éœ‡è¡ã€‚ğŸ—ï¸ ä¿®æ”¹å…³é”®ç‚¹types.rs: Room ç»“æ„ä½“ç§»é™¤ task_handleï¼Œä¸å†æŒæœ‰ä»»åŠ¡å¥æŸ„ã€‚state.rs: æ–°å¢ RoomIndex å’Œ BinanceChannels é€šé“å®šä¹‰ã€‚binance_task.rs: å®Œå…¨é‡å†™ã€‚å®ç° start_global_managerï¼Œå¤„ç†å¤šè·¯å¤ç”¨å’Œå¿ƒè·³ã€‚main.rs: åˆå§‹åŒ–å…¨å±€ Channelsï¼Œå¯åŠ¨ä¸¤ä¸ªå…¨å±€ Manager åç¨‹ï¼Œæ³¨å…¥ ServerStateã€‚socket_handlers.rs:ä¿ç•™ä½ æœ¬åœ°ä¼˜ç§€çš„ enrich_meme_data (ä½¿ç”¨ narrative_proxy_pool)ã€‚æ›¿æ¢ subscribe/unsubscribe/disconnect é€»è¾‘ï¼Œæ”¹ä¸ºå‘é€ Command åˆ°å…¨å±€ Channelã€‚æ–°å¢ schedule_lazy_tick_unsubscribe å¼‚æ­¥ä»»åŠ¡ã€‚ğŸ’» å®Œæ•´é‡æ„ä»£ç 1. packages/backend/src/types.rså˜æ›´ï¼šç§»é™¤ Room ä¸­çš„ task_handleï¼Œæ–°å¢é‡æ„æ‰€éœ€çš„ç»“æ„ä½“ã€‚ code Rustdownloadcontent_copyexpand_less    // packages/backend/src/types.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use socketioxide::socket::Sid;
use std::collections::HashSet;
use std::sync::Arc;
use tokio::sync::Mutex;
// ç§»é™¤: use tokio::task::JoinHandle; // ä¸å†éœ€è¦ï¼Œå› ä¸ºä»»åŠ¡ç”±å…¨å±€ç®¡ç†å™¨æ‰˜ç®¡

// ==============================================================================
// 1. å®šä¹‰ç‹¬ç«‹çš„æ•°æ®é¡¹ç»“æ„ä½“ (å¯¹åº” shared-types)
// ==============================================================================

// ğŸŸ¢ 1.1 Hotlist ä¸“ç”¨ç»“æ„ä½“ (å¯¹åº” TypeScript çš„ HotlistItem)
#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct HotlistItem {
    // --- BaseItem å­—æ®µ (é‡å¤å®šä¹‰ä»¥è§£è€¦) ---
    pub chain: String,
    pub contract_address: String,
    pub symbol: String,
    pub icon: Option<String>,

    // --- Hotlist æ ¸å¿ƒå­—æ®µ ---
    pub price: Option<f64>,
    pub market_cap: Option<f64>,
    pub volume1h: Option<f64>,
    pub volume24h: Option<f64>,
    pub price_change1h: Option<f64>,
    pub price_change24h: Option<f64>,

    // --- é¢å¤– Kçº¿ å­—æ®µ ---
    pub volume5m: Option<f64>,
    pub price_change5m: Option<f64>,

    // æ¥æºæ ‡è®°
    pub source: Option<String>,
}

// ğŸ”µ 1.2 Meme Rush ä¸“ç”¨ç»“æ„ä½“ (å¯¹åº” TypeScript çš„ MemeItem)
#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct MemeItem {
    // --- BaseItem å­—æ®µ ---
    pub chain: String,
    pub contract_address: String,
    pub symbol: String,
    pub icon: Option<String>,

    // --- Meme æ ¸å¿ƒå­—æ®µ ---
    pub name: String,
    pub progress: f64,                  // ç»‘å®šæ›²çº¿è¿›åº¦ (0-100)
    pub holders: i64,
    pub dev_migrate_count: Option<i64>, // å¯èƒ½ä¸ºnull
    pub create_time: i64,

    // âœ¨ æ–°å¢: å…¼å®¹ migrated æ•°æ®ä¸­çš„å­—æ®µ
    pub status: Option<String>, // e.g. "dex"
    pub update_time: Option<i64>,

    // ç¤¾äº¤
    pub twitter: Option<String>,
    pub telegram: Option<String>,
    pub website: Option<String>,

    // Meme äº¤æ˜“å±æ€§
    pub liquidity: Option<f64>,
    pub market_cap: Option<f64>,

    // âœ¨ æ–°å¢: é¡¹ç›®æè¿° (ä» Binance Narrative API è·å–)
    pub narrative: Option<String>,

    // æ¥æºæ ‡è®°
    pub source: Option<String>,
}

// ==============================================================================
// 2. å®šä¹‰ä¸¥æ ¼åˆ†æµçš„ Payload (æ ¸å¿ƒè§£è€¦ç‚¹)
// ==============================================================================

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub enum DataAction {
    #[serde(rename = "snapshot")]
    Snapshot,
    #[serde(rename = "update")]
    Update,
    #[serde(other)]
    Unknown, // å¤„ç† "full" æˆ–å…¶ä»–æœªé¢„æœŸçš„ action
}

// âœ¨ åˆ©ç”¨ serde(tag = "category") å®ç°è‡ªåŠ¨åˆ†æµ
#[derive(Debug, Deserialize, Serialize)]
#[serde(tag = "category")]
pub enum DataPayload {
    #[serde(rename = "hotlist")]
    Hotlist {
        r#type: DataAction,
        data: Vec<HotlistItem>,
    },

    #[serde(rename = "meme_new")]
    MemeNew {
        r#type: DataAction,
        data: Vec<MemeItem>,
    },

    // âœ¨ æ–°å¢: å¤„ç†å·²å‘å°„(Migrated)çš„ Meme ä»£å¸
    #[serde(rename = "meme_migrated")]
    MemeMigrated {
        r#type: DataAction,
        data: Vec<MemeItem>, // å¤ç”¨ MemeItem ç»“æ„
    },

    // å¤„ç†æœªçŸ¥çš„åˆ†ç±»ï¼Œé˜²æ­¢æŠ¥é”™å´©æºƒ
    #[serde(other)]
    Unknown,
}

// ==============================================================================
// 3. å…¶ä»–è¾…åŠ©ç»“æ„ (Binance/KLine/Socket/API)
// ==============================================================================

// âœ¨ æ–°å¢: Binance Narrative API å“åº”ç»“æ„
#[derive(Debug, Deserialize)]
pub struct NarrativeResponse {
    pub code: String,
    pub data: Option<NarrativeData>,
    pub success: bool,
}

#[derive(Debug, Deserialize)]
pub struct NarrativeData {
    pub text: Option<NarrativeText>,
}

#[derive(Debug, Deserialize)]
pub struct NarrativeText {
    pub en: Option<String>,
    pub cn: Option<String>,
}

#[derive(Debug, Deserialize, Clone)]
pub struct KlineSubscribePayload {
    pub address: String,
    pub chain: String,
    pub interval: String,
}

#[derive(Debug, Deserialize)]
pub struct BinanceStreamWrapper<T> {
    pub stream: String,
    pub data: T,
}

#[derive(Debug, Deserialize)]
pub struct BinanceKlineDataWrapper {
    #[serde(rename = "d")]
    pub kline_data: BinanceKlineDetail,
}

#[derive(Debug, Deserialize)]
#[allow(non_snake_case)]
pub struct BinanceKlineDetail {
    #[serde(rename = "u")]
    pub values: (String, String, String, String, String, String),
}

#[derive(Debug, Deserialize)]
pub struct BinanceTickDataWrapper {
    #[serde(rename = "d")]
    pub tick_data: BinanceTickDetail,
}

#[derive(Debug, Deserialize)]
#[allow(non_snake_case)]
pub struct BinanceTickDetail {
    pub t0a: String,
    pub t1a: String,
    pub t0pu: f64,
    pub t1pu: f64,
    pub v: f64,
    pub a0: f64,
    pub a1: f64,
    pub tp: String,
}

#[derive(Debug, Serialize, Clone)]
pub struct KlineBroadcastData {
    pub room: String,
    pub data: KlineTick,
}

#[derive(Debug, Serialize, Clone, Default, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct KlineTick {
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    pub open: f64,
    pub high: f64,
    pub low: f64,
    pub close: f64,
    pub volume: f64,
}

#[derive(Debug, Serialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct KlineHistoryResponse {
    pub address: String,
    pub chain: String,
    pub interval: String,
    pub data: Vec<KlineTick>,
}

// âœ¨ ä¿®æ”¹ï¼šRoom ä¸å†æŒæœ‰ task_handleï¼Œå› ä¸ºå®ƒä¸å†ç®¡ç†è¿æ¥
pub struct Room {
    pub clients: HashSet<Sid>,
    pub symbol: String,
    pub current_kline: Arc<Mutex<Option<KlineTick>>>,
}

#[derive(Debug, Deserialize)]
pub struct ImageProxyQuery {
    pub url: String,
}

#[derive(Serialize, Deserialize)]
pub struct CacheMeta {
    pub content_type: String,
}

#[derive(Debug, Deserialize)]
pub struct HistoricalDataWrapper {
    pub data: Vec<Vec<serde_json::Value>>,
}
  2. packages/backend/src/state.rså˜æ›´ï¼šæ–°å¢ RoomIndexã€SubscriptionCommand å’Œ BinanceChannelsã€‚ code Rustdownloadcontent_copyexpand_less    // packages/backend/src/state.rs
use super::types::Room;
use dashmap::DashMap;
use std::collections::HashSet;
use std::sync::Arc;
use tokio::sync::mpsc::UnboundedSender;

pub type AppState = Arc<DashMap<String, Room>>;

// âœ¨ Narrative Cache: ContractAddress -> Narrative Text
pub type NarrativeCache = Arc<DashMap<String, String>>;

// âœ¨ åå‘ç´¢å¼• (è·¯ç”±æ ¸å¿ƒ)
// Key: Contract Address (å°å†™) -> Value: è¯¥å¸ç§æ¶‰åŠçš„æ‰€æœ‰ RoomKey é›†åˆ
// ä½œç”¨ï¼šæ”¶åˆ° Tick æ•°æ®æ—¶ï¼ŒO(1) æ‰¾åˆ°æ‰€æœ‰éœ€è¦æ›´æ–°çš„æˆ¿é—´ (1m, 15m, 1h...)
pub type RoomIndex = Arc<DashMap<String, HashSet<String>>>;

// âœ¨ è®¢é˜…æŒ‡ä»¤ï¼šç”¨äºå‰ç«¯ Handler é€šçŸ¥åå° Manager
#[derive(Debug, Clone)]
pub enum SubscriptionCommand {
    Subscribe(String),   // å‚æ•°: stream name (e.g. kl@... or tx@...)
    Unsubscribe(String),
}

// âœ¨ å…¨å±€é€šé“æŒæœ‰è€…
#[derive(Clone)]
pub struct BinanceChannels {
    pub kline_tx: UnboundedSender<SubscriptionCommand>,
    pub tick_tx: UnboundedSender<SubscriptionCommand>,
}

pub fn new_app_state() -> AppState {
    Arc::new(DashMap::new())
}

pub fn new_narrative_cache() -> NarrativeCache {
    Arc::new(DashMap::new())
}

pub fn new_room_index() -> RoomIndex {
    Arc::new(DashMap::new())
}
  3. packages/backend/src/binance_task.rså˜æ›´ï¼šå®Œå…¨é‡å†™ï¼Œå®ç°å•ä¸€é•¿è¿æ¥å¤šè·¯å¤ç”¨ã€‚ code Rustdownloadcontent_copyexpand_less    // packages/backend/src/binance_task.rs
use super::{
    config::Config,
    state::{AppState, RoomIndex, SubscriptionCommand},
    types::{
        BinanceKlineDataWrapper, BinanceStreamWrapper, BinanceTickDataWrapper, KlineBroadcastData,
        KlineTick,
    },
};
use anyhow::{anyhow, Context, Result};
use chrono::{DateTime, Utc};
use futures_util::{stream::SplitSink, SinkExt, StreamExt};
use socketioxide::SocketIo;
use std::{collections::HashSet, sync::Arc, time::SystemTime};
use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
    sync::mpsc::UnboundedReceiver,
    time::{interval, sleep, Duration},
};
use tokio_native_tls::TlsConnector as TokioTlsConnector;
use tokio_tungstenite::{
    client_async_with_config,
    tungstenite::{client::IntoClientRequest, Message},
    WebSocketStream,
};
use tracing::{error, info, warn};
use url::Url;

type WsWrite = SplitSink<WebSocketStream<tokio_native_tls::TlsStream<TcpStream>>, Message>;

const LOW_VOLUME_PRICE_DEVIATION_THRESHOLD: f64 = 2.0;
const LOW_VOLUME_THRESHOLD: f64 = 10.0;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TaskType {
    Kline, // è´Ÿè´£æ‰€æœ‰ kl@...
    Tick,  // è´Ÿè´£æ‰€æœ‰ tx@...
}

impl std::fmt::Display for TaskType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TaskType::Kline => write!(f, "KLINE_MGR"),
            TaskType::Tick => write!(f, "TICK_MGR"),
        }
    }
}

/// âœ¨ å¯åŠ¨å…¨å±€ç®¡ç†ä»»åŠ¡ (Long Running Background Task)
pub async fn start_global_manager(
    task_type: TaskType,
    io: SocketIo,
    config: Arc<Config>,
    app_state: AppState,
    room_index: Option<RoomIndex>, // ä»… Tick ä»»åŠ¡éœ€è¦ç´¢å¼•
    mut cmd_rx: UnboundedReceiver<SubscriptionCommand>,
) {
    info!("ğŸš€ [STARTUP] Starting Global {}...", task_type);

    // ç»´æŠ¤å½“å‰æ´»è·ƒçš„æµï¼Œç”¨äºæ–­çº¿é‡è¿æ—¶è‡ªåŠ¨æ¢å¤è®¢é˜…
    let mut active_streams: HashSet<String> = HashSet::new();

    loop {
        // æ— é™é‡è¿å¾ªç¯
        let result = connect_and_serve(
            task_type,
            &io,
            &config,
            &app_state,
            &room_index,
            &mut cmd_rx,
            &mut active_streams,
        )
        .await;

        match result {
            Ok(_) => warn!(
                "ğŸ” [MANAGER {}] Disconnected gracefully. Reconnecting in 3s...",
                task_type
            ),
            Err(e) => error!(
                "ğŸ” [MANAGER {}] Connection crash: {:#?}. Retrying in 5s...",
                task_type, e
            ),
        }
        sleep(Duration::from_secs(5)).await;
    }
}

async fn connect_and_serve(
    task_type: TaskType,
    io: &SocketIo,
    config: &Config,
    app_state: &AppState,
    room_index: &Option<RoomIndex>,
    cmd_rx: &mut UnboundedReceiver<SubscriptionCommand>,
    active_streams: &mut HashSet<String>,
) -> Result<()> {
    // 1. å»ºç«‹ TCP/TLS è¿æ¥ (æ”¯æŒä»£ç†)
    let stream = establish_http_tunnel(task_type, config).await?;
    let host = Url::parse(&config.binance_wss_url)?
        .host_str()
        .unwrap_or_default()
        .to_string();
    let tls_stream = wrap_stream_with_tls(stream, &host).await?;

    // 2. WebSocket æ¡æ‰‹
    let mut request = config.binance_wss_url.as_str().into_client_request()?;
    let headers = request.headers_mut();
    headers.insert("User-Agent", "Mozilla/5.0 (Rust/Backend) GlobalManager".parse()?);

    let (ws_stream, response) = client_async_with_config(request, tls_stream, None)
        .await
        .context("WebSocket handshake failed")?;

    info!("âœ… [MANAGER {}] Connected! Status: {}", task_type, response.status());

    let (mut write, mut read) = ws_stream.split();

    // 3. çŠ¶æ€æ¢å¤ (Resubscribe after reconnect)
    if !active_streams.is_empty() {
        info!("ğŸ”„ [MANAGER {}] Resubscribing {} streams...", task_type, active_streams.len());
        let params: Vec<&str> = active_streams.iter().map(|s| s.as_str()).collect();
        
        // Binance å»ºè®®æ¯æ¬¡è®¢é˜…ä¸è¶…è¿‡ 50-100 ä¸ªæµ
        for chunk in params.chunks(50) {
            let msg = serde_json::json!({
                "method": "SUBSCRIBE",
                "params": chunk,
                "id": SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)?.as_millis()
            });
            write.send(Message::Text(msg.to_string().into())).await?;
            sleep(Duration::from_millis(100)).await;
        }
    }

    // 4. äº‹ä»¶ä¸»å¾ªç¯ (Select Loop)
    let mut heartbeat = interval(config.heartbeat_interval);

    loop {
        tokio::select! {
            // A. å¿ƒè·³ä¿æ´»
            _ = heartbeat.tick() => {
                write.send(Message::Ping(vec![].into())).await?;
            }

            // B. å¤„ç†æ¥è‡ªå…¶ä»–æ¨¡å—çš„æŒ‡ä»¤ (Subscribe/Unsubscribe)
            cmd = cmd_rx.recv() => {
                match cmd {
                    Some(SubscriptionCommand::Subscribe(stream)) => {
                        // é˜²é‡å…¥ï¼šåªæœ‰æœ¬åœ°æœªè®°å½•çš„æµæ‰å‘é€ç½‘ç»œè¯·æ±‚
                        if !active_streams.contains(&stream) {
                            info!("ğŸ“¥ [CMD {}] Subscribing: {}", task_type, stream);
                            let msg = serde_json::json!({
                                "method": "SUBSCRIBE",
                                "params": [stream],
                                "id": SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)?.as_millis()
                            });
                            write.send(Message::Text(msg.to_string().into())).await?;
                            active_streams.insert(stream);
                        }
                    },
                    Some(SubscriptionCommand::Unsubscribe(stream)) => {
                        if active_streams.contains(&stream) {
                            info!("ğŸ“¤ [CMD {}] Unsubscribing: {}", task_type, stream);
                            let msg = serde_json::json!({
                                "method": "UNSUBSCRIBE",
                                "params": [stream],
                                "id": SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)?.as_millis()
                            });
                            write.send(Message::Text(msg.to_string().into())).await?;
                            active_streams.remove(&stream);
                        }
                    },
                    None => return Err(anyhow!("Command channel closed")),
                }
            }

            // C. å¤„ç† WebSocket æ¶ˆæ¯ (Payload)
            msg_result = read.next() => {
                match msg_result {
                    Some(Ok(msg)) => {
                        match msg {
                            Message::Text(text) => handle_payload(task_type, &text, io, app_state, room_index).await,
                            Message::Ping(p) => { write.send(Message::Pong(p)).await?; }
                            Message::Close(_) => return Ok(()),
                            _ => {}
                        }
                    },
                    Some(Err(e)) => return Err(e.into()),
                    None => return Ok(()),
                }
            }
        }
    }
}

async fn handle_payload(
    task_type: TaskType,
    text: &str,
    io: &SocketIo,
    app_state: &AppState,
    room_index: &Option<RoomIndex>,
) {
    if text.contains("\"result\":null") { return; }

    match task_type {
        TaskType::Kline => {
            if let Ok(wrapper) = serde_json::from_str::<BinanceStreamWrapper<BinanceKlineDataWrapper>>(text) {
                // Stream Name: kl@pool_addr_interval
                let stream_parts: Vec<&str> = wrapper.stream.split('@').collect();
                if stream_parts.len() == 2 {
                    let params: Vec<&str> = stream_parts[1].split('_').collect();
                    if params.len() == 3 {
                        let pool_id = params[0];
                        let address = params[1];
                        let interval = params[2];
                        let room_key = format!("kl@{}@{}@{}", pool_id, address, interval);
                        
                        let kline = parse_kline(&wrapper.data.kline_data.values);

                        // Kline æ˜¯æƒå¨æ•°æ®ï¼Œis_authoritative = true (æ›´æ–°å†…å­˜)
                        update_room(io, app_state, &room_key, kline, true).await;
                    }
                }
            }
        }
        TaskType::Tick => {
            if let Ok(wrapper) = serde_json::from_str::<BinanceStreamWrapper<BinanceTickDataWrapper>>(text) {
                let tick = &wrapper.data.tick_data;
                let stream_parts: Vec<&str> = wrapper.stream.split('@').collect();

                if stream_parts.len() == 2 {
                    let params: Vec<&str> = stream_parts[1].split('_').collect();
                    if params.len() >= 2 {
                        let tracked_address = params[1]; // Stream ä¸­çš„åœ°å€é€šå¸¸æ˜¯å°å†™

                        // ä»·æ ¼åŒ¹é… (A0 or A1)
                        let price = if tick.t0a.eq_ignore_ascii_case(tracked_address) {
                            tick.t0pu
                        } else if tick.t1a.eq_ignore_ascii_case(tracked_address) {
                            tick.t1pu
                        } else {
                            return;
                        };

                        let usd_volume = tick.v;

                        // âœ¨ æ ¸å¿ƒä¼˜åŒ–ï¼šä½¿ç”¨ç´¢å¼•è¿›è¡Œ O(1) è·¯ç”±
                        if let Some(index) = room_index {
                            // æŸ¥æ‰¾è®¢é˜…äº†è¯¥åœ°å€çš„æ‰€æœ‰æˆ¿é—´ (1m, 15m, 1h ç­‰)
                            if let Some(room_keys) = index.get(&tracked_address.to_lowercase()) {
                                for room_key in room_keys.iter() {
                                    if let Some(entry) = app_state.get(room_key) {
                                        let mut kline_guard = entry.value().current_kline.lock().await;
                                        
                                        if let Some(kline) = kline_guard.as_mut() {
                                            // ä»·æ ¼å¼‚å¸¸è¿‡æ»¤ (é˜²æ­¢æ’é’ˆå¹²æ‰°å›¾è¡¨)
                                            if kline.close > 0.0 {
                                                let ratio = if price > kline.close { price / kline.close } else { kline.close / price };
                                                if ratio > LOW_VOLUME_PRICE_DEVIATION_THRESHOLD && usd_volume < LOW_VOLUME_THRESHOLD {
                                                    continue;
                                                }
                                            }

                                            // åªæ›´æ–°ä»·æ ¼ï¼Œä¿ç•™åŸæœ‰æƒå¨ Volume (é˜²æ­¢ Tick èšåˆå¯¼è‡´ Volume è™šé«˜)
                                            kline.high = kline.high.max(price);
                                            kline.low = kline.low.min(price);
                                            kline.close = price;

                                            // å¹¿æ’­åˆ°å¯¹åº”æˆ¿é—´
                                            broadcast_update(io, room_key, kline.clone()).await;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn parse_kline(values: &(String, String, String, String, String, String)) -> KlineTick {
    KlineTick {
        time: DateTime::from_timestamp(values.5.parse::<i64>().unwrap_or_default() / 1000, 0)
            .unwrap_or_default()
            .with_timezone(&Utc),
        open: values.0.parse().unwrap_or_default(),
        high: values.1.parse().unwrap_or_default(),
        low: values.2.parse().unwrap_or_default(),
        close: values.3.parse().unwrap_or_default(),
        volume: values.4.parse().unwrap_or_default(),
    }
}

async fn update_room(io: &SocketIo, app_state: &AppState, room_key: &str, new_kline: KlineTick, is_authoritative: bool) {
    if let Some(room) = app_state.get(room_key) {
        if is_authoritative {
            *room.current_kline.lock().await = Some(new_kline.clone());
        }
        broadcast_update(io, room_key, new_kline).await;
    }
}

async fn broadcast_update(io: &SocketIo, room_name: &str, kline: KlineTick) {
    let broadcast_data = KlineBroadcastData {
        room: room_name.to_string(),
        data: kline,
    };
    if let Err(e) = io.to(room_name.to_string()).emit("kline_update", &broadcast_data).await {
        if !e.to_string().contains("closed") {
            error!("âŒ [BROADCAST FAIL {}] {:?}", room_name, e);
        }
    }
}

async fn establish_http_tunnel(task_type: TaskType, config: &Config) -> Result<TcpStream> {
    let url_obj = Url::parse(&config.binance_wss_url)?;
    let host = url_obj.host_str().unwrap_or_default();
    let port = url_obj.port_or_known_default().unwrap_or(443);
    let target_addr = format!("{}:{}", host, port);

    if config.proxy_addr.is_empty() || config.proxy_addr == "none" {
         return TcpStream::connect(target_addr).await.context("Direct connection failed");
    }

    let mut stream = TcpStream::connect(&config.proxy_addr).await.context("HTTP proxy connection failed")?;
    let connect_req = format!("CONNECT {} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n", target_addr, target_addr);
    stream.write_all(connect_req.as_bytes()).await.context("Failed to send CONNECT request")?;
    
    let mut buf = vec![0; 1024];
    let n = stream.read(&mut buf).await.context("Failed to read proxy response")?;
    let response = String::from_utf8_lossy(&buf[..n]);

    if !response.starts_with("HTTP/1.1 200") {
        return Err(anyhow!("âŒ [MANAGER {}] Proxy CONNECT failed: {}", task_type, response.trim()));
    }
    Ok(stream)
}

async fn wrap_stream_with_tls(stream: TcpStream, host: &str) -> Result<tokio_native_tls::TlsStream<TcpStream>> {
    let tls_connector = native_tls::TlsConnector::builder().build()?;
    let tokio_tls_connector = TokioTlsConnector::from(tls_connector);
    tokio_tls_connector.connect(host, stream).await.context("TLS Handshake failed")
}
  4. packages/backend/src/main.rså˜æ›´ï¼šåˆå§‹åŒ– Channelsï¼Œå¯åŠ¨ä¸¤ä¸ªå…¨å±€ä»»åŠ¡ï¼Œå¹¶åœ¨ ServerState ä¸­åŠ å…¥ Channel å’Œ Indexã€‚ä¿ç•™åŸæœ‰çš„ narrative_proxy_poolã€‚ code Rustdownloadcontent_copyexpand_less    // packages/backend/src/main.rs

mod binance_task;
mod cache;
mod cache_manager;
mod client_pool;
mod config;
mod error;
mod http_handlers;
mod kline_handler;
mod socket_handlers;
mod state;
mod types;

use axum::{routing::get, Router};
use client_pool::ClientPool;
use config::Config;
use dashmap::DashMap;
use http::HeaderValue;
use socketioxide::{extract::SocketRef, SocketIo};
use sqlx::sqlite::{SqlitePool, SqlitePoolOptions};
use std::sync::Arc;
use tokio::sync::mpsc;
use tower_http::cors::{Any, CorsLayer};
use tracing::info;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// âœ¨ å¼•å…¥æ–°ç±»å‹
use crate::state::{BinanceChannels, SubscriptionCommand};

#[derive(Clone)]
pub struct ServerState {
    pub app_state: state::AppState,
    // âœ¨ æ–°å¢ï¼šæˆ¿é—´åå‘ç´¢å¼•
    pub room_index: state::RoomIndex,
    pub config: Arc<Config>,
    pub io: SocketIo,
    pub token_symbols: Arc<DashMap<String, String>>,
    pub narrative_cache: state::NarrativeCache,
    pub db_pool: SqlitePool,
    
    // âœ¨ 1. ç›´è¿æ±  (ç»™ K-line å†å²æ•°æ®ã€å›¾ç‰‡ä»£ç†ç”¨)
    pub client_pool: ClientPool,
    // âœ¨ 2. ä»£ç†æ±  (ç»™ Narrative/Meme æŠ“å–ç”¨ï¼Œå…·å¤‡æ•…éšœè½®æ¢èƒ½åŠ›)
    pub narrative_proxy_pool: ClientPool,
    
    // âœ¨ æ–°å¢: Binance é€šé“
    pub binance_channels: BinanceChannels,
}

#[tokio::main]
async fn main() {
    init_tracing();

    let (layer, io) = SocketIo::builder().max_buffer_size(40960).build_layer();
    let config = Arc::new(Config::new());

    // Database Setup
    if let Some(parent) = std::path::Path::new(&config.database_url.replace("sqlite:", "")).parent() {
        if !parent.exists() {
            std::fs::create_dir_all(parent).expect("Failed to create database directory");
        }
    }
    let db_pool = SqlitePoolOptions::new()
        .max_connections(10)
        .connect(&config.database_url)
        .await
        .expect("Failed to connect to SQLite database");
    info!("ğŸ—ƒï¸ Database connection pool established.");
    kline_handler::init_db(&db_pool)
        .await
        .expect("Failed to initialize database schema");

    // Pool A: ç›´è¿æ±  (20å¹¶å‘, ç›´è¿)
    info!("ğŸš€ Initializing Direct Client Pool...");
    let client_pool = ClientPool::new(20, None, "DIRECT".to_string()).await;

    // Pool B: ä»£ç†æ±  (8å¹¶å‘, èµ°ä»£ç†)
    info!("ğŸŒ Initializing Proxy Client Pool (Robust Mode)...");
    let proxy_url = format!("http://{}", config.proxy_addr);
    let narrative_proxy_pool = ClientPool::new(8, Some(proxy_url), "PROXY".to_string()).await;

    // âœ¨ 1. åˆ›å»ºå…¨å±€ Channels (HTTP/WS -> Manager)
    let (kline_tx, kline_rx) = mpsc::unbounded_channel::<SubscriptionCommand>();
    let (tick_tx, tick_rx) = mpsc::unbounded_channel::<SubscriptionCommand>();

    let app_state = state::new_app_state();
    // âœ¨ åˆå§‹åŒ–ç´¢å¼•
    let room_index = state::new_room_index();

    // âœ¨ 2. å¯åŠ¨å…¨å±€ Binance ä»»åŠ¡
    // Task A: Kline Manager
    let config_clone1 = config.clone();
    let io_clone1 = io.clone();
    let state_clone1 = app_state.clone();
    tokio::spawn(async move {
        binance_task::start_global_manager(
            binance_task::TaskType::Kline,
            io_clone1,
            config_clone1,
            state_clone1,
            None, // Kline ä¸éœ€è¦ç´¢å¼•
            kline_rx,
        ).await;
    });

    // Task B: Tick Manager (éœ€è¦ Index)
    let config_clone2 = config.clone();
    let io_clone2 = io.clone();
    let state_clone2 = app_state.clone();
    let index_clone2 = room_index.clone();
    tokio::spawn(async move {
        binance_task::start_global_manager(
            binance_task::TaskType::Tick,
            io_clone2,
            config_clone2,
            state_clone2,
            Some(index_clone2),
            tick_rx,
        ).await;
    });

    let server_state = ServerState {
        app_state,
        room_index, // âœ¨ æ³¨å…¥
        config: config.clone(),
        io: io.clone(),
        token_symbols: Arc::new(DashMap::new()),
        narrative_cache: state::new_narrative_cache(),
        db_pool,
        client_pool,
        narrative_proxy_pool, 
        binance_channels: BinanceChannels { kline_tx, tick_tx },
    };

    let socket_state = server_state.clone();
    io.ns("/", move |s: SocketRef| {
        let state = socket_state.clone();
        async move {
            socket_handlers::on_socket_connect(s, state).await;
        }
    });

    tokio::spawn(cache_manager::cache_manager_task(config));

    let app = Router::new()
        .route(
            "/desired-fields",
            get(http_handlers::desired_fields_handler),
        )
        .route("/image-proxy", get(http_handlers::image_proxy_handler))
        .with_state(server_state)
        .layer(
            CorsLayer::new()
                .allow_origin(
                    "http://localhost:15173"
                        .parse::<HeaderValue>()
                        .expect("Invalid CORS origin"),
                )
                .allow_methods(Any)
                .allow_headers(Any),
        )
        .layer(layer);

    info!("ğŸš€ Rust server is running at http://0.0.0.0:3001");
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3001")
        .await
        .expect("Failed to bind to port 3001");
    axum::serve(listener, app)
        .await
        .expect("Server failed to start");
}

fn init_tracing() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "backend=info,tower_http=info,sqlx=warn".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
}
  5. packages/backend/src/socket_handlers.rså˜æ›´ï¼šå¼•å…¥ schedule_lazy_tick_unsubscribeï¼Œä¿®æ”¹è®¢é˜…/é€€è®¢/æ–­å¼€é€»è¾‘ã€‚ä¿ç•™ enrich_meme_data ä½¿ç”¨ narrative_proxy_pool çš„é€»è¾‘ã€‚ code Rustdownloadcontent_copyexpand_less    // packages/backend/src/socket_handlers.rs
use super::{
    kline_handler,
    state::SubscriptionCommand,
    types::{DataPayload, KlineSubscribePayload, KlineTick, MemeItem, NarrativeResponse, Room},
    ServerState,
};
use socketioxide::extract::{Data, SocketRef};
use std::collections::HashSet;
use std::sync::Arc;
use tokio::sync::Mutex;
use tokio::time::Duration; // âœ¨ å¼•å…¥ Duration
use tracing::{error, info, warn};

const MIN_HOTLIST_AMOUNT: f64 = 1.0;
const NARRATIVE_API_URL: &str =
    "https://web3.binance.com/bapi/defi/v1/public/wallet-direct/buw/wallet/token/ai/narrative/query";
// âœ¨ å®šä¹‰å»¶è¿Ÿå–æ¶ˆæ—¶é—´ï¼š60ç§’
const LAZY_UNSUBSCRIBE_DELAY: u64 = 60;

pub async fn on_socket_connect(s: SocketRef, state: ServerState) {
    info!("ğŸ”Œ [Socket.IO] Client connected: {}", s.id);

    register_data_update_handler(&s, state.clone());
    register_kline_subscribe_handler(&s, state.clone());
    register_kline_unsubscribe_handler(&s, state.clone());
    register_disconnect_handler(&s, state.clone());
    register_kline_history_handler(&s, state);
}

// è¾…åŠ©ï¼šå¤„ç†ç´¢å¼•å¢åŠ  (è¿”å›æ˜¯å¦æ˜¯ç¬¬ä¸€æ¬¡è®¢é˜…è¯¥åœ°å€)
fn handle_index_subscription(state: &ServerState, address: &str, room_key: &str) -> bool {
    let address_lower = address.to_lowercase();
    let mut entry = state.room_index.entry(address_lower).or_default();
    let is_first = entry.is_empty();
    entry.insert(room_key.to_string());
    is_first
}

// è¾…åŠ©ï¼šå¤„ç†ç´¢å¼•å‡å°‘ (è¿”å›è¯¥åœ°å€æ˜¯å¦å·²ç»å½’é›¶)
fn handle_index_unsubscription(state: &ServerState, address: &str, room_key: &str) -> bool {
    let address_lower = address.to_lowercase();
    if let Some(mut entry) = state.room_index.get_mut(&address_lower) {
        entry.remove(room_key);
        return entry.is_empty();
    }
    false
}

// âœ¨âœ¨âœ¨ æ ¸å¿ƒæ–°å¢ï¼šLazy Unsubscribe è°ƒåº¦å™¨ âœ¨âœ¨âœ¨
fn schedule_lazy_tick_unsubscribe(state: ServerState, address: String, pool_id: i64) {
    // å¯åŠ¨ä¸€ä¸ªåˆ†ç¦»çš„å¼‚æ­¥ä»»åŠ¡
    tokio::spawn(async move {
        let address_lower = address.to_lowercase();
        // info!("â³ [LAZY UNSUB] Starting {}s timer for {}...", LAZY_UNSUBSCRIBE_DELAY, address);
        
        // 1. ç­‰å¾…ç¼“å†²æœŸ (è¦†ç›–ç”¨æˆ·åˆ·æ–°é¡µé¢çš„æ—¶é—´)
        tokio::time::sleep(Duration::from_secs(LAZY_UNSUBSCRIBE_DELAY)).await;

        // 2. å†æ¬¡æ£€æŸ¥ç´¢å¼•çŠ¶æ€ (Double Check)
        let should_really_unsub = if let Some(entry) = state.room_index.get(&address_lower) {
            // å¦‚æœé›†åˆä¸ºç©ºï¼Œè¯´æ˜è¿™ 60s å†…æ²¡äººé‡æ–°è®¢é˜…
            entry.is_empty()
        } else {
            // å¦‚æœ key éƒ½ä¸å­˜åœ¨äº†ï¼Œè‚¯å®šæ²¡äººè®¢é˜…
            true
        };

        // 3. æ‰§è¡ŒçœŸæ­£çš„é€€è®¢
        if should_really_unsub {
            info!("ğŸ“¤ [LAZY EXEC] Timer ended. No subscribers for {}. Unsubscribing Tick.", address);
            let tx_stream = format!("tx@{}_{}", pool_id, address);
            // å¿½ç•¥å‘é€é”™è¯¯ï¼ˆé€šé“å¯èƒ½å·²å…³é—­ï¼‰
            let _ = state.binance_channels.tick_tx.send(SubscriptionCommand::Unsubscribe(tx_stream));
            
            // å¯é€‰ï¼šæ¸…ç†ç©ºçš„ Index Key ä»¥èŠ‚çœå†…å­˜
            // state.room_index.remove(&address_lower); 
        } else {
            info!("â™»ï¸ [LAZY ABORT] Timer ended. User rejoined {}. Keeping connection alive.", address);
        }
    });
}

fn register_kline_subscribe_handler(socket: &SocketRef, state: ServerState) {
    socket.on(
        "subscribe_kline",
        move |s: SocketRef, Data(payload): Data<KlineSubscribePayload>| {
            let state = state.clone();
            async move {
                let chain_lower = payload.chain.to_lowercase();
                let address_lower = payload.address.to_lowercase();

                let symbol = state.token_symbols.get(&address_lower).map_or_else(
                    || format!("{}...", &payload.address[0..6]),
                    |s| s.value().clone(),
                );

                let pool_id = match chain_lower.as_str() {
                    "bsc" => 14,
                    "sol" | "solana" => 16,
                    "base" => 199,
                    _ => {
                        warn!("âš ï¸ [SUB FAIL] Unsupported chain for {}", s.id);
                        return;
                    }
                };

                let room_name = format!("kl@{}@{}@{}", pool_id, payload.address, payload.interval);
                let log_name = format!("kl@{}@{}@{}", pool_id, &symbol, payload.interval);

                info!("ğŸ”” [SUB] Client {} -> {}", s.id, log_name);
                s.join(room_name.clone());

                let is_new_room = !state.app_state.contains_key(&room_name);

                // 1. AppState æ›´æ–°
                state
                    .app_state
                    .entry(room_name.clone())
                    .or_insert_with(|| Room {
                        clients: HashSet::new(),
                        symbol: symbol.clone(),
                        current_kline: Arc::new(Mutex::new(None)),
                    })
                    .value_mut()
                    .clients
                    .insert(s.id);

                // 2. ç´¢å¼•æ›´æ–°
                let need_sub_tick = handle_index_subscription(&state, &payload.address, &room_name);

                if is_new_room {
                    // Kçº¿æµï¼šç«‹å³è®¢é˜… (Kçº¿é€šå¸¸ä¸éœ€è¦é˜²æŠ–ï¼Œå› ä¸ºå®ƒæŒ‰ Interval éš”ç¦»ï¼Œæµé‡å¯æ§)
                    let kl_stream = format!("kl@{}_{}_{}", pool_id, payload.address, payload.interval);
                    let _ = state.binance_channels.kline_tx.send(SubscriptionCommand::Subscribe(kl_stream));

                    // Tickæµï¼šå¦‚æœè¿™æ˜¯ç¬¬ä¸€ä¸ªäººï¼Œç«‹å³è®¢é˜… (ä¿è¯ç”¨æˆ·è¿›åœºç«‹é©¬æœ‰æ•°æ®)
                    // å³ä½¿ä¹‹å‰ Lazy Unsub è¿˜åœ¨å€’è®¡æ—¶ï¼Œé‡å¤å‘é€ Subscribe ä¹Ÿæ²¡é—®é¢˜ï¼ŒBinance ä¼šå¤„ç†
                    if need_sub_tick {
                        info!("ğŸ“¤ [SUB TICK] First sub for {}, sending Global CMD.", payload.address);
                        let tx_stream = format!("tx@{}_{}", pool_id, payload.address);
                        let _ = state.binance_channels.tick_tx.send(SubscriptionCommand::Subscribe(tx_stream));
                    }
                }
            }
        },
    );
}

fn register_kline_unsubscribe_handler(socket: &SocketRef, state: ServerState) {
    socket.on(
        "unsubscribe_kline",
        move |s: SocketRef, Data(payload): Data<KlineSubscribePayload>| {
            let state = state.clone();
            async move {
                let pool_id = match payload.chain.to_lowercase().as_str() {
                    "bsc" => 14,
                    "sol" | "solana" => 16,
                    "base" => 199,
                    _ => return,
                };
                let room_name = format!("kl@{}@{}@{}", pool_id, payload.address, payload.interval);

                s.leave(room_name.clone());

                let mut room_empty = false;
                if let Some(mut room) = state.app_state.get_mut(&room_name) {
                    room.clients.remove(&s.id);
                    room_empty = room.clients.is_empty();
                }

                if room_empty {
                    state.app_state.remove(&room_name);

                    // 1. Kçº¿æµï¼šç«‹å³é€€è®¢ (ä½é¢‘æµï¼Œç›´æ¥é€€è®¢å³å¯)
                    let kl_stream = format!("kl@{}_{}_{}", pool_id, payload.address, payload.interval);
                    let _ = state.binance_channels.kline_tx.send(SubscriptionCommand::Unsubscribe(kl_stream));

                    // 2. Tickæµï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦é€€è®¢
                    if handle_index_unsubscription(&state, &payload.address, &room_name) {
                        // âœ¨ è§¦å‘ Lazy Unsubscribe
                        info!("â³ [LAZY START] No subscribers for {}. Scheduling unsub in {}s...", payload.address, LAZY_UNSUBSCRIBE_DELAY);
                        schedule_lazy_tick_unsubscribe(state.clone(), payload.address.clone(), pool_id);
                    }
                }
            }
        },
    );
}

fn register_disconnect_handler(socket: &SocketRef, state: ServerState) {
    socket.on_disconnect(move |s: SocketRef| {
        let state = state.clone();
        async move {
            let mut empty_rooms = Vec::new();

            for mut entry in state.app_state.iter_mut() {
                if entry.value_mut().clients.remove(&s.id) && entry.value().clients.is_empty() {
                    empty_rooms.push(entry.key().clone());
                }
            }

            for room_name in empty_rooms {
                if let Some(_) = state.app_state.remove(&room_name) {
                    let parts: Vec<&str> = room_name.split('@').collect();
                    if parts.len() == 4 {
                        let pool_id = parts[1].parse::<i64>().unwrap_or(0);
                        let address = parts[2].to_string();
                        let interval = parts[3];

                        // 1. Kçº¿æµï¼šç«‹å³é€€è®¢
                        let kl_stream = format!("kl@{}_{}_{}", pool_id, address, interval);
                        let _ = state.binance_channels.kline_tx.send(SubscriptionCommand::Unsubscribe(kl_stream));

                        // 2. Tickæµï¼šè§¦å‘ Lazy Unsubscribe
                        if handle_index_unsubscription(&state, &address, &room_name) {
                            info!("â³ [LAZY START] Disconnect trigger. Scheduling unsub for {}...", address);
                            schedule_lazy_tick_unsubscribe(state.clone(), address, pool_id);
                        }
                    }
                }
            }
        }
    });
}

fn register_kline_history_handler(socket: &SocketRef, state: ServerState) {
    socket.on(
        "request_historical_kline",
        move |s: SocketRef, payload: Data<KlineSubscribePayload>| {
            let state = state.clone();
            async move {
                kline_handler::handle_kline_request(s, payload, state).await;
            }
        },
    );
}

fn register_data_update_handler(socket: &SocketRef, state: ServerState) {
    socket.on(
        "data-update",
        move |s: SocketRef, payload: Data<serde_json::Value>| {
            let state = state.clone();
            async move {
                match serde_json::from_value::<DataPayload>(payload.0) {
                    Ok(mut parsed_payload) => {
                        let mut should_broadcast = false;
                        let mut log_summary = String::new();

                        match &mut parsed_payload {
                            DataPayload::Hotlist { r#type, data } => {
                                let original_count = data.len();
                                data.retain(|item| {
                                    let volume = item.volume1h.unwrap_or(0.0);
                                    let price = item.price.unwrap_or(0.0);
                                    let amount = volume * price;
                                    amount >= MIN_HOTLIST_AMOUNT
                                });
                                let filtered_count = data.len();
                                should_broadcast = !data.is_empty();
                                log_summary = format!(
                                    "ğŸ”¥ [HOTLIST] Act: {:?} | Filter: {} -> {} (Criteria: 1H Amount >= ${})",
                                    r#type, original_count, filtered_count, MIN_HOTLIST_AMOUNT
                                );
                                for item in data.iter() {
                                    state.token_symbols.insert(
                                        item.contract_address.to_lowercase(),
                                        item.symbol.clone(),
                                    );
                                }
                            }
                            DataPayload::MemeNew { r#type, data } => {
                                data.retain(|item| !item.symbol.is_empty());
                                enrich_meme_data(data, &state).await;
                                let filtered_count = data.len();
                                should_broadcast = !data.is_empty();
                                log_summary = format!(
                                    "ğŸ¶ [MEME RUSH] Act: {:?} | Items: {} | Narrative Check Done",
                                    r#type, filtered_count
                                );
                                for item in data.iter() {
                                    state.token_symbols.insert(
                                        item.contract_address.to_lowercase(),
                                        item.symbol.clone(),
                                    );
                                }
                            }
                            DataPayload::MemeMigrated { r#type, data } => {
                                data.retain(|item| !item.symbol.is_empty());
                                enrich_meme_data(data, &state).await;
                                let filtered_count = data.len();
                                should_broadcast = !data.is_empty();
                                log_summary = format!(
                                    "ğŸš€ [MEME MIGRATED] Act: {:?} | Items: {} | Narrative Check Done",
                                    r#type, filtered_count
                                );
                                for item in data.iter() {
                                    state.token_symbols.insert(
                                        item.contract_address.to_lowercase(),
                                        item.symbol.clone(),
                                    );
                                }
                            }
                            DataPayload::Unknown => {
                                warn!("âš ï¸ [DATA] Received unknown category payload.");
                            }
                        }

                        if should_broadcast {
                            info!("{}", log_summary);
                            if let Err(e) = s.broadcast().emit("data-broadcast", &parsed_payload).await
                            {
                                error!("âŒ [BROADCAST FAIL] {:?}", e);
                            }
                        }
                    }
                    Err(e) => {
                        warn!("âŒ [JSON PARSE ERROR] Failed to parse data-update: {}", e);
                    }
                }
            }
        },
    );
}

// âœ¨ ä¿ç•™æœ¬åœ°ä¼˜ç§€çš„å®ç°ï¼šä½¿ç”¨ narrative_proxy_pool
async fn enrich_meme_data(items: &mut Vec<MemeItem>, state: &ServerState) {
    let mut to_fetch = Vec::new();
    
    for (i, item) in items.iter().enumerate() {
        if !state.narrative_cache.contains_key(&item.contract_address) {
            state
                .narrative_cache
                .insert(item.contract_address.clone(), "__PENDING__".to_string());
            to_fetch.push(i);
        }
    }

    if !to_fetch.is_empty() {
        info!("ğŸ” [NARRATIVE] Queuing fetch for {} items.", to_fetch.len());
    }

    for (q_idx, &idx) in to_fetch.iter().enumerate() {
        let addr = items[idx].contract_address.clone();
        let chain = items[idx].chain.clone();
        let cache = state.narrative_cache.clone();
        
        // 1. è·å–ä»£ç†æ± å¼•ç”¨
        let proxy_pool = state.narrative_proxy_pool.clone();

        // é”™å³°è¯·æ±‚
        let delay = std::time::Duration::from_millis(q_idx as u64 * 250);

        if let Some(cid) = get_chain_id(&chain) {
            tokio::spawn(async move {
                tokio::time::sleep(delay).await;

                // 2. ä»æ± ä¸­è·å– Client å¥æŸ„
                let (client_idx, client) = proxy_pool.get_client().await;

                // 3. ä¼ é€’ client å¼•ç”¨ç»™ fetch å‡½æ•°
                match fetch_narrative(&client, &addr, cid).await {
                    Ok(Some(t)) => {
                        info!("âœ… [Fetch OK] {}: {:.15}...", addr, t);
                        cache.insert(addr, t);
                    }
                    Ok(None) => {
                        cache.insert(addr, "".into());
                    }
                    Err(e) => {
                        // 4. è§¦å‘ç†”æ–­ï¼šè¯·æ±‚å¤±è´¥ï¼Œé”€æ¯å¹¶é‡å»ºè¯¥ Client
                        warn!("âŒ [Fetch ERR] Client #{} failed for {}: {}. Triggering Recycle...", client_idx, addr, e);
                        proxy_pool.recycle_client(client_idx).await;
                        cache.remove(&addr);
                    }
                }
            });
        } else {
            cache.insert(addr, "".into());
        }
    }

    // å¡«å……æ•°æ®å› item
    for item in items.iter_mut() {
        if let Some(t) = state.narrative_cache.get(&item.contract_address) {
            if !t.is_empty() && t.as_str() != "__PENDING__" {
                item.narrative = Some(t.clone());
            }
        }
    }
}

async fn fetch_narrative(
    client: &reqwest::Client,
    address: &str,
    chain_id: u64,
) -> anyhow::Result<Option<String>> {
    let url = format!(
        "{}?contractAddress={}&chainId={}",
        NARRATIVE_API_URL, address, chain_id
    );

    // ä½¿ç”¨ä¼ å…¥çš„ client å‘é€è¯·æ±‚
    let resp = client.get(&url)
        .header("ClientType", "web")
        .header("Origin", "https://web3.binance.com")
        .header("Referer", "https://web3.binance.com/zh-CN/meme-rush")
        // æ¨¡æ‹ŸçœŸå®æµè§ˆå™¨æŒ‡çº¹
        .header("Sec-Ch-Ua", "\"Google Chrome\";v=\"125\", \"Chromium\";v=\"125\", \"Not.A/Brand\";v=\"24\"")
        .header("Sec-Ch-Ua-Mobile", "?0")
        .header("Sec-Ch-Ua-Platform", "\"Windows\"")
        .header("Sec-Fetch-Dest", "empty")
        .header("Sec-Fetch-Mode", "cors")
        .header("Sec-Fetch-Site", "same-origin")
        .header("Cache-Control", "no-cache")
        .header("Pragma", "no-cache")
        .send()
        .await?;

    if !resp.status().is_success() {
        return Err(anyhow::anyhow!("HTTP Status {}", resp.status()));
    }

    let body: NarrativeResponse = resp.json().await?;

    if let Some(d) = body.data {
        if let Some(t) = d.text {
            if let Some(cn) = t.cn {
                if !cn.is_empty() { return Ok(Some(cn)); }
            }
            if let Some(en) = t.en {
                if !en.is_empty() { return Ok(Some(en)); }
            }
        }
    }
    Ok(None)
}

fn get_chain_id(chain: &str) -> Option<u64> {
    match chain.to_lowercase().as_str() {
        "bsc" => Some(56),
        "eth" | "ethereum" => Some(1),
        "base" => Some(8453),
        "arb" | "arbitrum" => Some(42161),
        "matic" | "polygon" => Some(137),
        "op" | "optimism" => Some(10),
        "avax" | "avalanche" => Some(43114),
        "sol" | "solana" => None,
        _ => None,
    }
}
  
  
  






`packages\extractor\src\meme-scanner.ts`è¾“å‡ºçš„æ—¥å¿—å¦‚ä¸‹
 F:\work\github\binanceweb3> pnpm scan:meme 

> realtime-monitor@1.0.0 scan:meme F:\work\github\binanceweb3
> pnpm --filter extractor scan:meme


> extractor@1.0.0 scan:meme F:\work\github\binanceweb3\packages\extractor
> tsc -b && node dist/meme-scanner.js

[Logger] æ—¥å¿—æ–‡ä»¶å·²åˆ›å»º: F:\work\github\binanceweb3\packages\logs\run_2025-12-02T04-15-17.log
[15:17.153] [INFO]     ğŸ•µï¸ [MemeScanner V10] å¯åŠ¨å…¨å­—æ®µæ·±åº¦æ‰«æ
[15:19.714] [INFO]     [Navi] å‰å¾€ç›®æ ‡é¡µé¢: https://web3.binance.com/zh-CN/meme-rush?chain=bsc
[15:25.664] [INFO]     [Wait] ç­‰å¾…æ•°æ®æµåŠ è½½ (10ç§’)...
[15:35.690] [INFO]     [Scroll] è§¦å‘é¡µé¢æ»šåŠ¨...
[15:41.336] [INFO]     [Inject] æ‰§è¡Œ V10 åˆ†æè„šæœ¬...
[15:41.377] [INFO]     
ğŸ‰ æ‰«ææˆåŠŸ! å‘ç°äº† 6 ä¸ªå€™é€‰åˆ—è¡¨ã€‚


===============================================================
ğŸ“¦ [LIST #1] source: Props.Value -> allTokens | Count: 40
===============================================================
ğŸ“Š [SORTING TRENDS] (è¿™å†³å®šäº†è°åœ¨é˜Ÿåˆ—æœ€ä¸Šé¢)
   Time:     Descending (â¬‡ï¸)
   Progress: Random/Mixed
   MktCap:   Random/Mixed

ğŸ” [OBJECT INSPECTION] (ç¬¬ä¸€ä¸ªå¸çš„æ‰€æœ‰å­—æ®µ - å¯»æ‰¾ status/migrated æ ‡å¿—)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)               â”‚ Values                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ firstSeen             â”‚ '1764648940864'                                         â”‚
â”‚ chainId               â”‚ '56'                                                    â”‚
â”‚ contractAddress       â”‚ '0xbeb9b6aee2e59ffd0f930581f834b0841c5a4444'            â”‚
â”‚ symbol                â”‚ 'GTOK'                                                  â”‚
â”‚ name                  â”‚ 'Grok takes over'                                       â”‚
â”‚ icon                  â”‚ 'https://static.four.meme/market/d2e5a2d2-9111-4397...' â”‚
â”‚ caIcon                â”‚ 'null'                                                  â”‚
â”‚ iconStatus            â”‚ '1'                                                     â”‚
â”‚ caIconStatus          â”‚ '1'                                                     â”‚
â”‚ createTime            â”‚ '1764648937000'                                         â”‚
â”‚ height                â”‚ '70196571'                                              â”‚
â”‚ twitter               â”‚ 'https://x.com/user_ydyb575n/status/199570828988398...' â”‚
â”‚ website               â”‚ 'https://axiom.trade/@sellhigh'                         â”‚
â”‚ telegram              â”‚ 'null'                                                  â”‚
â”‚ progress              â”‚ 'null'                                                  â”‚
â”‚ protocol              â”‚ '2001'                                                  â”‚
â”‚ holders               â”‚ '1'                                                     â”‚
â”‚ liquidity             â”‚ 'null'                                                  â”‚
â”‚ volume                â”‚ 'null'                                                  â”‚
â”‚ marketCap             â”‚ 'null'                                                  â”‚
â”‚ count                 â”‚ 'null'                                                  â”‚
â”‚ countBuy              â”‚ 'null'                                                  â”‚
â”‚ countSell             â”‚ 'null'                                                  â”‚
â”‚ holdersTop10Percent   â”‚ '5'                                                     â”‚
â”‚ holdersDevPercent     â”‚ '5'                                                     â”‚
â”‚ holdersSniperPercent  â”‚ 'null'                                                  â”‚
â”‚ holdersInsiderPercent â”‚ 'null'                                                  â”‚
â”‚ devSellPercent        â”‚ '0'                                                     â”‚
â”‚ migrateStatus         â”‚ 'false'                                                 â”‚
â”‚ migrateTime           â”‚ 'null'                                                  â”‚
â”‚ paidOnDexScreener     â”‚ 'false'                                                 â”‚
â”‚ devMigrateCount       â”‚ '2'                                                     â”‚
â”‚ decimal               â”‚ '18'                                                    â”‚
â”‚ sensitiveToken        â”‚ 'false'                                                 â”‚
â”‚ exclusive             â”‚ 'false'                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ‘€ [PREVIEW] (å‰ 3 ä¸ªæ•°æ®)
   - GTOK     | Prog: null% | Status: N/A | Time: 1764648937000
   - GTO      | Prog: 9.51% | Status: N/A | Time: 1764648930000
   - Grokæ¥ç®¡   | Prog: 3.85% | Status: N/A | Time: 1764648923000

===============================================================
ğŸ“¦ [LIST #2] source: Props.Value -> currentTokens | Count: 40
===============================================================
ğŸ“Š [SORTING TRENDS] (è¿™å†³å®šäº†è°åœ¨é˜Ÿåˆ—æœ€ä¸Šé¢)
   Time:     Descending (â¬‡ï¸)
   Progress: Random/Mixed
   MktCap:   Random/Mixed

ğŸ” [OBJECT INSPECTION] (ç¬¬ä¸€ä¸ªå¸çš„æ‰€æœ‰å­—æ®µ - å¯»æ‰¾ status/migrated æ ‡å¿—)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)               â”‚ Values                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ firstSeen             â”‚ '1764648940864'                                         â”‚
â”‚ chainId               â”‚ '56'                                                    â”‚
â”‚ contractAddress       â”‚ '0xbeb9b6aee2e59ffd0f930581f834b0841c5a4444'            â”‚
â”‚ symbol                â”‚ 'GTOK'                                                  â”‚
â”‚ name                  â”‚ 'Grok takes over'                                       â”‚
â”‚ icon                  â”‚ 'https://static.four.meme/market/d2e5a2d2-9111-4397...' â”‚
â”‚ caIcon                â”‚ 'null'                                                  â”‚
â”‚ iconStatus            â”‚ '1'                                                     â”‚
â”‚ caIconStatus          â”‚ '1'                                                     â”‚
â”‚ createTime            â”‚ '1764648937000'                                         â”‚
â”‚ height                â”‚ '70196571'                                              â”‚
â”‚ twitter               â”‚ 'https://x.com/user_ydyb575n/status/199570828988398...' â”‚
â”‚ website               â”‚ 'https://axiom.trade/@sellhigh'                         â”‚
â”‚ telegram              â”‚ 'null'                                                  â”‚
â”‚ progress              â”‚ 'null'                                                  â”‚
â”‚ protocol              â”‚ '2001'                                                  â”‚
â”‚ holders               â”‚ '1'                                                     â”‚
â”‚ liquidity             â”‚ 'null'                                                  â”‚
â”‚ volume                â”‚ 'null'                                                  â”‚
â”‚ marketCap             â”‚ 'null'                                                  â”‚
â”‚ count                 â”‚ 'null'                                                  â”‚
â”‚ countBuy              â”‚ 'null'                                                  â”‚
â”‚ countSell             â”‚ 'null'                                                  â”‚
â”‚ holdersTop10Percent   â”‚ '5'                                                     â”‚
â”‚ holdersDevPercent     â”‚ '5'                                                     â”‚
â”‚ holdersSniperPercent  â”‚ 'null'                                                  â”‚
â”‚ holdersInsiderPercent â”‚ 'null'                                                  â”‚
â”‚ devSellPercent        â”‚ '0'                                                     â”‚
â”‚ migrateStatus         â”‚ 'false'                                                 â”‚
â”‚ migrateTime           â”‚ 'null'                                                  â”‚
â”‚ paidOnDexScreener     â”‚ 'false'                                                 â”‚
â”‚ devMigrateCount       â”‚ '2'                                                     â”‚
â”‚ decimal               â”‚ '18'                                                    â”‚
â”‚ sensitiveToken        â”‚ 'false'                                                 â”‚
â”‚ exclusive             â”‚ 'false'                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ‘€ [PREVIEW] (å‰ 3 ä¸ªæ•°æ®)
   - GTOK     | Prog: null% | Status: N/A | Time: 1764648937000
   - GTO      | Prog: 9.51% | Status: N/A | Time: 1764648930000
   - Grokæ¥ç®¡   | Prog: 3.85% | Status: N/A | Time: 1764648923000

===============================================================
ğŸ“¦ [LIST #3] source: Props.Value -> allTokens | Count: 40
===============================================================
ğŸ“Š [SORTING TRENDS] (è¿™å†³å®šäº†è°åœ¨é˜Ÿåˆ—æœ€ä¸Šé¢)
   Time:     Random/Mixed
   Progress: Descending (â¬‡ï¸)
   MktCap:   Random/Mixed

ğŸ” [OBJECT INSPECTION] (ç¬¬ä¸€ä¸ªå¸çš„æ‰€æœ‰å­—æ®µ - å¯»æ‰¾ status/migrated æ ‡å¿—)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)               â”‚ Values                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ firstSeen             â”‚ '1764648938751'                                         â”‚
â”‚ chainId               â”‚ '56'                                                    â”‚
â”‚ contractAddress       â”‚ '0xd4e0e063e1e7b90afec8668f6b8785066db94444'            â”‚
â”‚ symbol                â”‚ '2026'                                                  â”‚
â”‚ name                  â”‚ '2026'                                                  â”‚
â”‚ icon                  â”‚ 'https://static.four.meme/market/6bea4c8c-4d91-416c...' â”‚
â”‚ caIcon                â”‚ 'null'                                                  â”‚
â”‚ iconStatus            â”‚ '1'                                                     â”‚
â”‚ caIconStatus          â”‚ '1'                                                     â”‚
â”‚ createTime            â”‚ '1764590830000'                                         â”‚
â”‚ height                â”‚ '70119104'                                              â”‚
â”‚ twitter               â”‚ 'null'                                                  â”‚
â”‚ website               â”‚ 'null'                                                  â”‚
â”‚ telegram              â”‚ 'null'                                                  â”‚
â”‚ progress              â”‚ '91.37'                                                 â”‚
â”‚ protocol              â”‚ '2001'                                                  â”‚
â”‚ holders               â”‚ '174'                                                   â”‚
â”‚ liquidity             â”‚ '21791.49'                                              â”‚
â”‚ volume                â”‚ '12525.71'                                              â”‚
â”‚ marketCap             â”‚ '46675.4'                                               â”‚
â”‚ count                 â”‚ '363'                                                   â”‚
â”‚ countBuy              â”‚ '319'                                                   â”‚
â”‚ countSell             â”‚ '44'                                                    â”‚
â”‚ holdersTop10Percent   â”‚ '45'                                                    â”‚
â”‚ holdersDevPercent     â”‚ 'null'                                                  â”‚
â”‚ holdersSniperPercent  â”‚ '72'                                                    â”‚
â”‚ holdersInsiderPercent â”‚ 'null'                                                  â”‚
â”‚ devSellPercent        â”‚ 'null'                                                  â”‚
â”‚ migrateStatus         â”‚ 'false'                                                 â”‚
â”‚ migrateTime           â”‚ '0'                                                     â”‚
â”‚ paidOnDexScreener     â”‚ 'false'                                                 â”‚
â”‚ devMigrateCount       â”‚ '1'                                                     â”‚
â”‚ decimal               â”‚ '18'                                                    â”‚
â”‚ sensitiveToken        â”‚ 'false'                                                 â”‚
â”‚ exclusive             â”‚ 'false'                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ‘€ [PREVIEW] (å‰ 3 ä¸ªæ•°æ®)
   - 2026     | Prog: 91.37% | Status: N/A | Time: 1764590830000
   - æ„Ÿè°¢æŠ¬ä¸¾     | Prog: 91.36% | Status: N/A | Time: 1764247769000
   - SRNX     | Prog: 90.97% | Status: N/A | Time: 1764630018000

===============================================================
ğŸ“¦ [LIST #4] source: Props.Value -> currentTokens | Count: 40
===============================================================
ğŸ“Š [SORTING TRENDS] (è¿™å†³å®šäº†è°åœ¨é˜Ÿåˆ—æœ€ä¸Šé¢)
   Time:     Random/Mixed
   Progress: Descending (â¬‡ï¸)
   MktCap:   Random/Mixed

ğŸ” [OBJECT INSPECTION] (ç¬¬ä¸€ä¸ªå¸çš„æ‰€æœ‰å­—æ®µ - å¯»æ‰¾ status/migrated æ ‡å¿—)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)               â”‚ Values                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ firstSeen             â”‚ '1764648938751'                                         â”‚
â”‚ chainId               â”‚ '56'                                                    â”‚
â”‚ contractAddress       â”‚ '0xd4e0e063e1e7b90afec8668f6b8785066db94444'            â”‚
â”‚ symbol                â”‚ '2026'                                                  â”‚
â”‚ name                  â”‚ '2026'                                                  â”‚
â”‚ icon                  â”‚ 'https://static.four.meme/market/6bea4c8c-4d91-416c...' â”‚
â”‚ caIcon                â”‚ 'null'                                                  â”‚
â”‚ iconStatus            â”‚ '1'                                                     â”‚
â”‚ caIconStatus          â”‚ '1'                                                     â”‚
â”‚ createTime            â”‚ '1764590830000'                                         â”‚
â”‚ height                â”‚ '70119104'                                              â”‚
â”‚ twitter               â”‚ 'null'                                                  â”‚
â”‚ website               â”‚ 'null'                                                  â”‚
â”‚ telegram              â”‚ 'null'                                                  â”‚
â”‚ progress              â”‚ '91.37'                                                 â”‚
â”‚ protocol              â”‚ '2001'                                                  â”‚
â”‚ holders               â”‚ '174'                                                   â”‚
â”‚ liquidity             â”‚ '21791.49'                                              â”‚
â”‚ volume                â”‚ '12525.71'                                              â”‚
â”‚ marketCap             â”‚ '46675.4'                                               â”‚
â”‚ count                 â”‚ '363'                                                   â”‚
â”‚ countBuy              â”‚ '319'                                                   â”‚
â”‚ countSell             â”‚ '44'                                                    â”‚
â”‚ holdersTop10Percent   â”‚ '45'                                                    â”‚
â”‚ holdersDevPercent     â”‚ 'null'                                                  â”‚
â”‚ holdersSniperPercent  â”‚ '72'                                                    â”‚
â”‚ holdersInsiderPercent â”‚ 'null'                                                  â”‚
â”‚ devSellPercent        â”‚ 'null'                                                  â”‚
â”‚ migrateStatus         â”‚ 'false'                                                 â”‚
â”‚ migrateTime           â”‚ '0'                                                     â”‚
â”‚ paidOnDexScreener     â”‚ 'false'                                                 â”‚
â”‚ devMigrateCount       â”‚ '1'                                                     â”‚
â”‚ decimal               â”‚ '18'                                                    â”‚
â”‚ sensitiveToken        â”‚ 'false'                                                 â”‚
â”‚ exclusive             â”‚ 'false'                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ‘€ [PREVIEW] (å‰ 3 ä¸ªæ•°æ®)
   - 2026     | Prog: 91.37% | Status: N/A | Time: 1764590830000
   - æ„Ÿè°¢æŠ¬ä¸¾     | Prog: 91.36% | Status: N/A | Time: 1764247769000
   - SRNX     | Prog: 90.97% | Status: N/A | Time: 1764630018000

===============================================================
ğŸ“¦ [LIST #5] source: Props.Value -> allTokens | Count: 40
===============================================================
ğŸ“Š [SORTING TRENDS] (è¿™å†³å®šäº†è°åœ¨é˜Ÿåˆ—æœ€ä¸Šé¢)
   Time:     Descending (â¬‡ï¸)
   Progress: Random/Mixed
   MktCap:   Random/Mixed

ğŸ” [OBJECT INSPECTION] (ç¬¬ä¸€ä¸ªå¸çš„æ‰€æœ‰å­—æ®µ - å¯»æ‰¾ status/migrated æ ‡å¿—)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)               â”‚ Values                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ firstSeen             â”‚ '1764648937915'                                         â”‚
â”‚ chainId               â”‚ '56'                                                    â”‚
â”‚ contractAddress       â”‚ '0xe81b40e01169b4c39bb823b5f965bf72e5c74444'            â”‚
â”‚ symbol                â”‚ 'BSC'                                                   â”‚
â”‚ name                  â”‚ 'BinanceChristmasHat'                                   â”‚
â”‚ icon                  â”‚ 'https://static.four.meme/market/7afa7454-f2d0-475e...' â”‚
â”‚ caIcon                â”‚ 'null'                                                  â”‚
â”‚ iconStatus            â”‚ '1'                                                     â”‚
â”‚ caIconStatus          â”‚ '1'                                                     â”‚
â”‚ createTime            â”‚ '1764648293000'                                         â”‚
â”‚ height                â”‚ '70195712'                                              â”‚
â”‚ twitter               â”‚ 'https://x.com/BNBChristmasHat'                         â”‚
â”‚ website               â”‚ 'https://x.com/BNBChristmasHat/status/1995694770027...' â”‚
â”‚ telegram              â”‚ 'null'                                                  â”‚
â”‚ progress              â”‚ '100'                                                   â”‚
â”‚ protocol              â”‚ '2001'                                                  â”‚
â”‚ holders               â”‚ '103'                                                   â”‚
â”‚ liquidity             â”‚ '14124.41'                                              â”‚
â”‚ volume                â”‚ '144908.07'                                             â”‚
â”‚ marketCap             â”‚ '14369.74'                                              â”‚
â”‚ count                 â”‚ '557'                                                   â”‚
â”‚ countBuy              â”‚ '334'                                                   â”‚
â”‚ countSell             â”‚ '223'                                                   â”‚
â”‚ holdersTop10Percent   â”‚ '35'                                                    â”‚
â”‚ holdersDevPercent     â”‚ '0'                                                     â”‚
â”‚ holdersSniperPercent  â”‚ '0'                                                     â”‚
â”‚ holdersInsiderPercent â”‚ '0'                                                     â”‚
â”‚ devSellPercent        â”‚ '99'                                                    â”‚
â”‚ migrateStatus         â”‚ 'true'                                                  â”‚
â”‚ migrateTime           â”‚ '1764648780000'                                         â”‚
â”‚ paidOnDexScreener     â”‚ 'false'                                                 â”‚
â”‚ devMigrateCount       â”‚ '0'                                                     â”‚
â”‚ decimal               â”‚ '18'                                                    â”‚
â”‚ sensitiveToken        â”‚ 'false'                                                 â”‚
â”‚ exclusive             â”‚ 'false'                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ‘€ [PREVIEW] (å‰ 3 ä¸ªæ•°æ®)
   - BSC      | Prog: 100% | Status: N/A | Time: 1764648293000
   - é©¬åˆ°åŠŸæˆ     | Prog: 100% | Status: N/A | Time: 1764644688000
   - ç‹å°äºŒäººç”Ÿ    | Prog: 100% | Status: N/A | Time: 1764642726000

===============================================================
ğŸ“¦ [LIST #6] source: Props.Value -> currentTokens | Count: 40
===============================================================
ğŸ“Š [SORTING TRENDS] (è¿™å†³å®šäº†è°åœ¨é˜Ÿåˆ—æœ€ä¸Šé¢)
   Time:     Descending (â¬‡ï¸)
   Progress: Random/Mixed
   MktCap:   Random/Mixed

ğŸ” [OBJECT INSPECTION] (ç¬¬ä¸€ä¸ªå¸çš„æ‰€æœ‰å­—æ®µ - å¯»æ‰¾ status/migrated æ ‡å¿—)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)               â”‚ Values                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ firstSeen             â”‚ '1764648937915'                                         â”‚
â”‚ chainId               â”‚ '56'                                                    â”‚
â”‚ contractAddress       â”‚ '0xe81b40e01169b4c39bb823b5f965bf72e5c74444'            â”‚
â”‚ symbol                â”‚ 'BSC'                                                   â”‚
â”‚ name                  â”‚ 'BinanceChristmasHat'                                   â”‚
â”‚ icon                  â”‚ 'https://static.four.meme/market/7afa7454-f2d0-475e...' â”‚
â”‚ caIcon                â”‚ 'null'                                                  â”‚
â”‚ iconStatus            â”‚ '1'                                                     â”‚
â”‚ caIconStatus          â”‚ '1'                                                     â”‚
â”‚ createTime            â”‚ '1764648293000'                                         â”‚
â”‚ height                â”‚ '70195712'                                              â”‚
â”‚ twitter               â”‚ 'https://x.com/BNBChristmasHat'                         â”‚
â”‚ website               â”‚ 'https://x.com/BNBChristmasHat/status/1995694770027...' â”‚
â”‚ telegram              â”‚ 'null'                                                  â”‚
â”‚ progress              â”‚ '100'                                                   â”‚
â”‚ protocol              â”‚ '2001'                                                  â”‚
â”‚ holders               â”‚ '103'                                                   â”‚
â”‚ liquidity             â”‚ '14124.41'                                              â”‚
â”‚ volume                â”‚ '144908.07'                                             â”‚
â”‚ marketCap             â”‚ '14369.74'                                              â”‚
â”‚ count                 â”‚ '557'                                                   â”‚
â”‚ countBuy              â”‚ '334'                                                   â”‚
â”‚ countSell             â”‚ '223'                                                   â”‚
â”‚ holdersTop10Percent   â”‚ '35'                                                    â”‚
â”‚ holdersDevPercent     â”‚ '0'                                                     â”‚
â”‚ holdersSniperPercent  â”‚ '0'                                                     â”‚
â”‚ holdersInsiderPercent â”‚ '0'                                                     â”‚
â”‚ devSellPercent        â”‚ '99'                                                    â”‚
â”‚ migrateStatus         â”‚ 'true'                                                  â”‚
â”‚ migrateTime           â”‚ '1764648780000'                                         â”‚
â”‚ paidOnDexScreener     â”‚ 'false'                                                 â”‚
â”‚ devMigrateCount       â”‚ '0'                                                     â”‚
â”‚ decimal               â”‚ '18'                                                    â”‚
â”‚ sensitiveToken        â”‚ 'false'                                                 â”‚
â”‚ exclusive             â”‚ 'false'                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ‘€ [PREVIEW] (å‰ 3 ä¸ªæ•°æ®)
   - BSC      | Prog: 100% | Status: N/A | Time: 1764648293000
   - é©¬åˆ°åŠŸæˆ     | Prog: 100% | Status: N/A | Time: 1764644688000
   - ç‹å°äºŒäººç”Ÿ    | Prog: 100% | Status: N/A | Time: 1764642726000

ğŸ’¡ [åˆ†æå»ºè®®]
1. æŸ¥çœ‹ "OBJECT INSPECTION" è¡¨æ ¼ã€‚
2. å¯»æ‰¾ç±»ä¼¼ 'listingStatus', 'state', 'phase', 'isDex' è¿™æ ·çš„å­—æ®µã€‚
3. æ¯”è¾ƒ [LIST #1] å’Œ [LIST #2] (å¦‚æœæœ‰)ï¼Œé€šå¸¸ä¸€ä¸ªæ˜¯ 'New' ä¸€ä¸ªæ˜¯ 'Migrated'ã€‚
4. ç¡®è®¤ 'Time' çš„æ’åºè¶‹åŠ¿ï¼šå¦‚æœ Time æ˜¯ Descending (â¬‡ï¸)ï¼Œåˆ™æ•°ç»„ç¬¬ 0 ä¸ªå°±æ˜¯æœ€æ–°çš„ã€‚
[Logger] æ—¥å¿—æ–‡ä»¶æµå·²å…³é—­ã€‚
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
æ ¹æ®æ—¥å¿—ä¿®æ”¹ï¼Œï¼Œå‚è€ƒpackages\extractor\src\meme-scanner.tsæ¥ä¿®æ”¹
`packages\extractor\src\meme-extractor.ts`
ç›®æ ‡æ˜¯å‘é€å·²è¿ç§»çš„å“ç§åˆ°åç«¯ï¼Œå¹¶ä¸”ä¸ºäº†è°ƒè¯•ï¼Œæ‰“å°å‡ºå“ç§çš„æ‰€æœ‰å­—æ®µ





function main(config, profileName) {
  console.log(`å¼€å§‹å¤„ç†é…ç½®æ–‡ä»¶: ${profileName}`);

  // ç¡®ä¿ proxies, proxy-groups, rules å­—æ®µå­˜åœ¨
  if (!Array.isArray(config.proxies)) config.proxies = [];
  if (!Array.isArray(config['proxy-groups'])) config['proxy-groups'] = [];
  if (!Array.isArray(config.rules)) config.rules = [];

  // --- æ­¥éª¤ 1: å®šä¹‰å¹¶åˆ›å»ºæ‰€æœ‰æ–°çš„ä»£ç†ç»„ ---
  const newGroups = [
    { name: 'ä»¥è‰²åˆ—', type: 'select', proxies: [] },
    { name: 'myother', type: 'select', proxies: [] },
    { name: 'google', type: 'select',  proxies: [] },
    { name: 'web3.binance.com', type: 'load-balance', strategy: 'round-robin', url: 'http://www.gstatic.com/generate_204', interval: 300, proxies: [] },
    { name: 'å¸å®‰api', type: 'load-balance', strategy: 'round-robin', url: 'http://www.gstatic.com/generate_204', interval: 300, proxies: [] },
    { name: 'tradingview', type: 'load-balance', strategy: 'round-robin', url: 'http://www.gstatic.com/generate_204', interval: 300, proxies: [] },
     { name: 'high', type: 'load-balance', strategy: 'round-robin', url: 'http://www.gstatic.com/generate_204', interval: 300, proxies: [] },
   { name: 'low', type: 'load-balance', strategy: 'round-robin', url: 'http://www.gstatic.com/generate_204', interval: 300, proxies: [] },
    { name: 'æ‰€æœ‰èŠ‚ç‚¹', type: 'load-balance', strategy: 'round-robin', url: 'http://www.gstatic.com/generate_204', interval: 300, proxies: [] }
  ];

  // --- æ­¥éª¤ 2: å®šä¹‰æ­£åˆ™è¡¨è¾¾å¼å¹¶å¡«å……ä»£ç†ç»„ ---
  const allProxyNames = config.proxies.map(p => p.name);
  const groupFilters = {
    'å¸å®‰api': /^(?=.*é«˜çº§)(?=.*(é¦™æ¸¯|æ–°åŠ å¡|å°æ¹¾|æ—¥æœ¬|Japan)).*$/,
    'web3.binance.com': /^(?=.*é«˜çº§)(?=.*(æ–°åŠ å¡|å°æ¹¾|æ—¥æœ¬|Japan)).*$/,
    'ä»¥è‰²åˆ—': /^(.*)(ä»¥è‰²åˆ—)+(.*)$/, // ä¿®æ­£äº† "||"
    'myother': /^(.*)(æ—¥æœ¬|JP|Japan|è‹±å›½|TW|å°æ¹¾|UK)+(.*)$/,
    'tradingview': /^(?=.*é«˜çº§)(?=.*(é¦™æ¸¯|æ–°åŠ å¡|å°æ¹¾|æ—¥æœ¬|Japan)).*$/,
    'high': /^(.*)(é«˜çº§)(.*)$/,
    'google': /^(?=.*(|æ–°åŠ å¡|å°æ¹¾|æ—¥æœ¬|Japan)).*$/,
    'low': /^(.*)(å®éªŒ)+(.*)$/,
    'æ‰€æœ‰èŠ‚ç‚¹': /^.*$/
  };

  newGroups.forEach(group => {
    if (groupFilters[group.name]) {
      const regex = groupFilters[group.name];
      const filteredProxies = allProxyNames.filter(name => regex.test(name));
      // å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°ï¼Œåˆ™æ·»åŠ ä¸€ä¸ª DIRECT ä½œä¸ºä¿åº•ï¼Œé˜²æ­¢ä»£ç†ç»„ä¸ºç©º Clash æ ¸å¿ƒæŠ¥é”™
      group.proxies = filteredProxies.length > 0 ? filteredProxies : ['DIRECT'];
    }
  });






  // --- æ­¥éª¤ 3: å®šä¹‰å¹¶å‰ç½®æ’å…¥æ–°çš„è§„åˆ™ ---
  const newRules = [
    // ... (æ‰€æœ‰è§„åˆ™ä¿æŒä¸å˜)
   
    'DOMAIN,nbstream.binance.com,å¸å®‰api',
    'DOMAIN,fapi.binance.com,å¸å®‰api',
    'DOMAIN-SUFFIX,web3.binance.com,web3.binance.com',
    'DOMAIN-SUFFIX,fstream.binance.com,å¸å®‰api',
    'DOMAIN,binance.com,å¸å®‰api',
    'DOMAIN-SUFFIX,google.com,google',
    'DOMAIN-SUFFIX,googleapis.com,google',
    'DOMAIN-SUFFIX,g.co,google',
    'DOMAIN-SUFFIX,goo.gl,google',
    'DOMAIN-SUFFIX,google.cn,google',
    'DOMAIN-SUFFIX,gstatic.com,google',
    'DOMAIN-SUFFIX,ggpht.com,google',
    'DOMAIN-SUFFIX,googleapis.com,google',
    'DOMAIN-SUFFIX,google-analytics.com,google',
    'DOMAIN-SUFFIX,googleadservices.com,google',
    'DOMAIN-SUFFIX,googlesyndication.com,google',
    'DOMAIN-SUFFIX,googletagmanager.com,google',
    'DOMAIN-SUFFIX,googletagservices.com,google',
    'DOMAIN-SUFFIX,googlevideo.com,low',
    'DOMAIN-SUFFIX,googleusercontent.com,google',
    'DOMAIN-SUFFIX,youtube.com,low',
    'DOMAIN-SUFFIX,youtu.be,low',
    'DOMAIN-SUFFIX,android.com,high',
    'DOMAIN-SUFFIX,doubleclick.net,high',
    'DOMAIN-SUFFIX,recaptcha.net,high',
    'DOMAIN-SUFFIX,augmentcode.com,ä»¥è‰²åˆ—',
   
   
    //'DOMAIN,fapi.binance.com,high',
    
    'DOMAIN-KEYWORD,tradingview,tradingview',
    'DOMAIN-KEYWORD,bing,low',
    'DOMAIN-KEYWORD,ave,myother',
  ];




  
  // --- æ­¥éª¤ 5: å°†æ‰€æœ‰æ–°å†…å®¹æ³¨å…¥åˆ° config å¯¹è±¡ä¸­ ---
  config['proxy-groups'].unshift(...newGroups);
  config.rules.unshift(...newRules);
  
  console.log(`æˆåŠŸæ·»åŠ äº† ${newGroups.length} ä¸ªæ–°çš„ä»£ç†ç»„å’Œ ${newRules.length} æ¡æ–°çš„è§„åˆ™ã€‚`);

  return config;
}