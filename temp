å¥½çš„ï¼Œå¾ˆé«˜å…´èƒ½ä½œä¸ºä½ çš„è®¨è®ºä¼™ä¼´æ¥ååŠ©ä½ è¿›è¡Œé¡¹ç›®å¼€å‘ã€‚ä½ å¯¹ lightweight-charts ä¸­ K çº¿å›¾å’Œæˆäº¤é‡å›¾ï¼ˆVolumeï¼‰éœ€è¦ç‹¬ç«‹ Series çš„åˆ†æéå¸¸å‡†ç¡®ï¼Œå¹¶ä¸”é€šè¿‡å¼•å…¥ç‹¬ç«‹çš„ HistogramSeries å’Œä½¿ç”¨ PriceScale çš„ scaleMargins æ¥æ§åˆ¶å¸ƒå±€ï¼Œè¿™æ˜¯ä¸€ä¸ªä¼˜é›…ä¸”é«˜æ€§èƒ½çš„è§£å†³æ–¹æ¡ˆã€‚

æˆ‘å·²å°†ä¿®å¤åçš„ä»£ç ä¸­çš„æ‰€æœ‰ç¦æ­¢è¯ï¼ˆcode, Code, download, content_copy, expand_lessï¼‰ç§»é™¤ï¼Œä½ å¯ä»¥ç›´æ¥å¤åˆ¶ç²˜è´´ä½¿ç”¨ã€‚

packages/frontend/src/SingleKlineChart.tsx
code
TypeScript
download
content_copy
expand_less
// packages/frontend/src/SingleKlineChart.tsx
/** @jsxImportSource solid-js */


import { Component, onMount, onCleanup, createEffect, Show, createSignal } from 'solid-js';
import { createChart, ColorType, IChartApi, ISeriesApi, CandlestickData, CandlestickSeries, Time, LineSeries, PriceFormat, HistogramSeries, HistogramData } from 'lightweight-charts';
import { socket } from './socket';
import type { KlineUpdatePayload, KlineFetchErrorPayload } from './types';
import type { MarketItem } from 'shared-types';
import type { ViewportState } from './ChartPageLayout';
import type { ChartTheme } from './themes';

const BACKEND_URL = 'http://localhost:3001';

// --- é…ç½®åŒº ---
const FORCE_GHOST_CANDLE_COUNT = 1000;

interface SingleKlineChartProps {
    tokenInfo: MarketItem | undefined;
    onBlock?: (contractAddress: string) => void;
    timeframe: string;
    viewportState: ViewportState | null;
    onViewportChange?: (state: ViewportState | null) => void;
    activeChartId: string | null;
    onSetActiveChart?: (id: string | null) => void;
    showAxes?: boolean;
    theme: ChartTheme;
}

// âœ¨ æ ¸å¿ƒä¿®æ”¹ 1: ä½¿ç”¨å¯¹æ•°å‡½æ•°é‡å†™è‡ªé€‚åº”ç²¾åº¦è®¡ç®—
const getAdaptivePriceFormat = (price: number): PriceFormat => {
    // å¤„ç†ä»·æ ¼ä¸º0æˆ–æ— æ•ˆçš„è¾¹ç¼˜æƒ…å†µï¼Œè¿”å›ä¸€ä¸ªåˆç†çš„é»˜è®¤å€¼
    if (!price || price <= 0) {
        return { type: 'price', precision: 4, minMove: 0.0001 };
    }

    let precision: number;

    if (price >= 1) {
        // å¯¹äºå¤§äºç­‰äº1çš„ä»·æ ¼ï¼Œé€»è¾‘ä¿æŒä¸å˜ï¼Œé€šå¸¸2ä½å°æ•°è¶³å¤Ÿ
        precision = 2;
    } else {
        // å¯¹äºå°äº1çš„ä»·æ ¼ï¼Œä½¿ç”¨å¯¹æ•°è®¡ç®—
        // 1. è®¡ç®—ç¬¬ä¸€ä¸ªæœ‰æ•ˆæ•°å­—çš„ä½ç½®
        const firstSignificantDigitPosition = Math.ceil(-Math.log10(price));
        
        // 2. åœ¨æ­¤åŸºç¡€ä¸Šå¢åŠ 3ä½å°æ•°ä»¥æ˜¾ç¤ºç»†èŠ‚ (æ€»å…±çº¦4ä½æœ‰æ•ˆæ•°å­—)
        precision = firstSignificantDigitPosition + 3;
    }

    // è®¾å®šä¸€ä¸ªæœ€å¤§ç²¾åº¦ä¸Šé™(10)ï¼Œå’Œæœ€å°ç²¾åº¦ä¸‹é™(2)ï¼Œé˜²æ­¢æç«¯æƒ…å†µ
    const finalPrecision = Math.min(Math.max(precision, 2), 10);

    // minMove åº”è¯¥æ˜¯ 1 / 10^precision
    const minMove = 1 / Math.pow(10, finalPrecision);

    return {
        type: 'price',
        precision: finalPrecision,
        minMove: minMove,
    };

};

// ä»·æ ¼æ ¼å¼åŒ–å‡½æ•°ï¼Œä¸»è¦ç”¨äºç§»é™¤toFixedåå¯èƒ½çš„å¤šä½™çš„0
const customPriceFormatter = (price: number): string => {
    // ä½¿ç”¨ Intl.NumberFormat é¿å…ç§‘å­¦è®¡æ•°æ³•ï¼Œå¹¶èƒ½å¤„ç†å¤§é‡å°æ•°
    const s = new Intl.NumberFormat('en-US', {
        maximumFractionDigits: 10,
        useGrouping: false
    }).format(price);

    // ç§»é™¤æœ«å°¾ä¸å¿…è¦çš„é›¶å’Œå°æ•°ç‚¹
    if (s.includes('.')) {
        return s.replace(/\.?0+$/, '');
    }
    return s;

};

// è¾…åŠ©ï¼šè·å–æ—¶é—´å‘¨æœŸçš„ç§’æ•°
const getIntervalSeconds = (timeframe: string): number => {
    const val = parseInt(timeframe);
    if (timeframe.endsWith('m')) return val * 60;
    if (timeframe.endsWith('h')) return val * 3600;
    if (timeframe.endsWith('d')) return val * 86400;
    return 60; // default 1m
};

const SingleKlineChart: Component<SingleKlineChartProps> = (props) => {
    let chartContainer: HTMLDivElement;
    let chart: IChartApi | null = null;
    let candlestickSeries: ISeriesApi<'Candlestick'> | null = null;
    let volumeSeries: ISeriesApi<'Histogram'> | null = null; // âœ¨ æ–°å¢ Volume Series
    let ghostSeries: ISeriesApi<'Line'> | null = null;
    let resizeObserver: ResizeObserver | null = null;
    const [status, setStatus] = createSignal('Initializing...');

    // ğŸ”’ çŠ¶æ€é”ï¼šé˜²æ­¢è§†å£åŒæ­¥äº§ç”Ÿçš„æ­»å¾ªç¯
    let isProgrammaticUpdate = false;
    let isSyncPending = false;

    const getMyId = () => props.tokenInfo?.contractAddress || '';

    const log = (msg: string, ...args: any[]) => {
        // console.log(`[Chart ${props.tokenInfo?.symbol || 'Wait'}] ${msg}`, ...args);
    };

    const cleanupChart = () => {
        if (chart) {
            log('Cleaning up chart instance.');
            chart.remove();
            chart = null;
            candlestickSeries = null;
            volumeSeries = null; // âœ¨ æ¸…ç†
            ghostSeries = null;
        }
    };

    const unsubscribeRealtime = (payload: { address: string; chain: string; interval: string }) => {
        socket.off('kline_update', handleKlineUpdate);
        socket.emit('unsubscribe_kline', payload);
    };

    // å®æ—¶æ•°æ®æ›´æ–°å¤„ç†å‡½æ•°
    const handleKlineUpdate = (update: KlineUpdatePayload) => {
        const info = props.tokenInfo;
        if (!info || !candlestickSeries || !volumeSeries) return;
        
        const chainToPoolId: Record<string, number> = { bsc: 14, sol: 16, solana: 16, base: 199 };
        const poolId = chainToPoolId[info.chain.toLowerCase()];
        if (!poolId) return;

        const expectedRoom = `kl@${poolId}@${info.contractAddress}@${props.timeframe}`;

        if (update.room === expectedRoom) {
            const rawData = update.data; // è¿™é‡Œé€šå¸¸åŒ…å« {time, open, high, low, close, volume}
            // æ„é€  Candle æ•°æ®
            const newCandle = {
                time: rawData.time as Time,
                open: rawData.open,
                high: rawData.high,
                low: rawData.low,
                close: rawData.close
            } as CandlestickData<number>;

            // æ£€æŸ¥ä¹±åºåŒ…
            const currentData = candlestickSeries.data();
            if (currentData.length > 0) {
                const lastCandle = currentData[currentData.length - 1] as CandlestickData<number>;
                if ((newCandle.time as number) < (lastCandle.time as number)) {
                    log(`âš ï¸ Dropped late packet. Last: ${lastCandle.time}, New: ${newCandle.time}`);
                    return;
                }
            }
            candlestickSeries.update(newCandle);
            log(`ğŸ“ˆ KLine updated for ${info.symbol} at ${newCandle.time}`); // âœ¨ æ·»åŠ æ›´æ–°æ—¥å¿—

            // âœ¨ æ›´æ–° Volume æ•°æ®
            // å‡è®¾ update.data é‡Œæœ‰ volume (åœ¨ types.ts é‡Œå®šä¹‰çš„ LightweightChartKline åŒ…å« volume)
            const vol = (rawData as any).volume || 0;
            // æ¶¨è·Œé¢œè‰²åˆ¤æ–­ä½¿ç”¨å½“å‰ K çº¿çš„å¼€ç›˜ä»·å’Œæ”¶ç›˜ä»·
            const color = newCandle.close >= newCandle.open ? props.theme.candle.upColor : props.theme.candle.downColor;
            
            volumeSeries.update({
                time: newCandle.time,
                value: vol,
                color: color,
            } as HistogramData<number>);
            log(`ğŸ“Š Volume updated for ${info.symbol} with volume ${vol}`); // âœ¨ æ·»åŠ æ›´æ–°æ—¥å¿—
        }
    };

    // ğŸ‘» ç”Ÿæˆéšå½¢æ•°æ®
    const generateGhostData = (timeframe: string) => {
        const intervalSec = getIntervalSeconds(timeframe);
        const nowAligned = Math.floor(Date.now() / 1000 / intervalSec) * intervalSec;
        const data = [];
        for (let i = FORCE_GHOST_CANDLE_COUNT; i >= 0; i--) {
            data.push({ time: (nowAligned - (i * intervalSec)) as Time, value: 0 });
        }
        return data;
    };

    // âœ¨ Theme Application Effect
    createEffect(() => {
        if (chart && props.theme) {
            const t = props.theme;
            chart.applyOptions({
                layout: { background: { type: ColorType.Solid, color: t.layout.background }, textColor: t.layout.textColor },
                grid: { vertLines: { color: t.grid.vertLines }, horzLines: { color: t.grid.horzLines } },
            });
            if (candlestickSeries) {
                candlestickSeries.applyOptions({
                    upColor: t.candle.upColor, downColor: t.candle.downColor,
                    borderUpColor: t.candle.borderUpColor, borderDownColor: t.candle.borderDownColor,
                    wickUpColor: t.candle.wickUpColor, wickDownColor: t.candle.wickDownColor,
                });
            }
            // âœ¨ æ›´æ–° Volume æ ·å¼ (å¦‚æœéœ€è¦æ›´æ”¹ priceScale çš„é¢œè‰²ç­‰)
            if (volumeSeries) {
                // å½“å‰æ— éœ€ä¸“é—¨æ›´æ–° volumeSeries çš„é¢œè‰²ï¼Œå› ä¸ºå…·ä½“æŸ±å­é¢œè‰²ç”±æ•°æ®æ›´æ–°æ—¶åŠ¨æ€è®¾ç½®
                // å¦‚æœéœ€è¦å…¨å±€é€æ˜åº¦ï¼Œå¯ä»¥åœ¨ addSeries æ—¶è®¾ç½®ï¼Œæˆ–è€…åœ¨è¿™é‡Œ
            }
        }
    });

    // ä¸»å‰¯ä½œç”¨ï¼šå›¾è¡¨åˆ›å»ºä¸æ•°æ®è®¢é˜…
    createEffect(() => {
        const info = props.tokenInfo;
        const timeframe = props.timeframe;
        const t = props.theme; 

        if (!info || !timeframe) {
            cleanupChart(); setStatus('No token selected.'); log('Effect cancelled: No token/timeframe.'); return;
        }

        log(`Attempting to initialize chart for ${info.symbol}@${timeframe}`);
        cleanupChart(); setStatus(`Loading ${info.symbol}...`);
        
        if (!chartContainer) return;

        try {
            chart = createChart(chartContainer, {
                width: chartContainer.clientWidth, height: chartContainer.clientHeight,
                layout: { background: { type: ColorType.Solid, color: t.layout.background }, textColor: t.layout.textColor },
                grid: { vertLines: { color: t.grid.vertLines }, horzLines: { color: t.grid.horzLines } },
                timeScale: { 
                    visible: !!props.showAxes, borderColor: '#cccccc', timeVisible: true, secondsVisible: false,
                    rightOffset: 12, shiftVisibleRangeOnNewBar: true, fixLeftEdge: false, fixRightEdge: false, 
                },
                rightPriceScale: { visible: !!props.showAxes, borderColor: '#cccccc', autoScale: true },
                leftPriceScale: { visible: false, autoScale: false }, 
                handleScroll: true, handleScale: true,
            });

            // âœ¨ é…ç½® Volume ä¸“ç”¨çš„ PriceScale
            // å°†å…¶è®¾ç½®åœ¨ 'volume' ID ä¸Šï¼Œå¹¶è®¾ç½®è¾¹è·ä½¿å…¶åªå æ®åº•éƒ¨ 20%
            chart.priceScale('volume').applyOptions({
                scaleMargins: {
                    top: 0.8, // é¡¶éƒ¨ç•™ç©º 80%ï¼Œå³åªåœ¨åº•éƒ¨ 20% æ˜¾ç¤º
                    bottom: 0,
                },
                visible: false, // éšè—æˆäº¤é‡çš„ Y è½´åˆ»åº¦ï¼Œé¿å…å¹²æ‰°
            });
            log('PriceScale for volume configured.');

            ghostSeries = chart.addSeries(LineSeries, {
                color: 'rgba(0,0,0,0)', lineWidth: 1, priceScaleId: 'left',   
                crosshairMarkerVisible: false, lastValueVisible: false, priceLineVisible: false,
            });
            ghostSeries.setData(generateGhostData(timeframe));
            log('Ghost series added.');

            // âœ¨ Volume Series åˆå§‹åŒ–
            volumeSeries = chart.addSeries(HistogramSeries, {
                priceFormat: { type: 'volume' },
                priceScaleId: 'volume', // ç»‘å®šåˆ°åˆšæ‰é…ç½®çš„ scale
                lastValueVisible: false, // ä¸åœ¨åæ ‡è½´æ˜¾ç¤ºæœ€åä¸€ä¸ªå€¼
                priceLineVisible: false, // ä¸æ˜¾ç¤ºä»·æ ¼çº¿
            });
            log('Volume series (Histogram) added.');

            // âœ¨ æ ¸å¿ƒä¿®æ”¹ 2: åœ¨åˆ›å»º K çº¿ç³»åˆ—æ—¶ï¼ŒåŠ¨æ€ç”Ÿæˆ priceFormat
            const priceFormatWithFormatter = {
                ...getAdaptivePriceFormat(info.price || 0),
                formatter: customPriceFormatter,
            };

            candlestickSeries = chart.addSeries(CandlestickSeries, {
                priceFormat: priceFormatWithFormatter,
                upColor: t.candle.upColor, downColor: t.candle.downColor, 
                borderDownColor: t.candle.borderDownColor, borderUpColor: t.candle.borderUpColor, 
                wickDownColor: t.candle.wickDownColor, wickUpColor: t.candle.wickUpColor,
                priceScaleId: 'right'
            });
            log('Candlestick series added.');

        } catch (e) {
            console.error(`[Chart:${info.symbol}] âŒ Fatal Error creating chart:`, e);
            setStatus(`Chart Error`); return;
        }

        // è§†å£åŒæ­¥é€»è¾‘ (å‘é€æ–¹)
        chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            if (isProgrammaticUpdate) return;
            const myId = getMyId().toLowerCase();
            const activeId = props.activeChartId?.toLowerCase();
            if (myId === activeId) {
                if (!isSyncPending) {
                    isSyncPending = true;
                    requestAnimationFrame(() => {
                        const logicalRange = chart?.timeScale().getVisibleLogicalRange();
                        if (logicalRange && props.onViewportChange) {
                            props.onViewportChange({ from: logicalRange.from, to: logicalRange.to });
                            log('Viewport change detected and sent.');
                        }
                        isSyncPending = false;
                    });
                }
            }
        });

        const payload = { address: info.contractAddress, chain: info.chain, interval: timeframe };

        const processData = (data: any[], isInitial: boolean) => {
            try {
                // ç¡®ä¿æ—¶é—´æ˜¯æ•°å­—å¹¶æ’åº
                const sortedData = data.map(d => ({ ...d, time: Number(d.time) })).sort((a, b) => a.time - b.time);
                
                // âœ¨ æ‹†åˆ†æ•°æ®
                const candleData: CandlestickData<number>[] = [];
                const volumeData: HistogramData<number>[] = [];

                sortedData.forEach(item => {
                    candleData.push({
                        time: item.time as Time,
                        open: item.open,
                        high: item.high,
                        low: item.low,
                        close: item.close,
                    });
                    
                    // æ ¹æ®æ¶¨è·Œè®¾ç½®é¢œè‰²
                    const color = item.close >= item.open ? t.candle.upColor : t.candle.downColor;
                    
                    volumeData.push({
                        time: item.time as Time,
                        value: item.volume,
                        color: color
                    });
                });
                log(`Processed ${sortedData.length} data points. Initial: ${isInitial}`);

                if (isInitial) {
                    candlestickSeries?.setData(candleData);
                    volumeSeries?.setData(volumeData); // âœ¨ è®¾ç½® Volume æ•°æ®

                    if (props.viewportState) {
                         chart?.timeScale().setVisibleLogicalRange({ from: props.viewportState.from, to: props.viewportState.to });
                         log('Set initial range from viewportState.');
                    } else { 
                        chart?.timeScale().scrollToRealTime(); 
                        log('Scrolled to real time.');
                    }
                } else {
                    // å¯¹äºåç»­è¡¥å…¨çš„æ•°æ® (HTTP completed)
                    candlestickSeries?.setData(candleData);
                    volumeSeries?.setData(volumeData); // âœ¨ è®¾ç½® Volume æ•°æ®
                    log('Replaced data with historical_kline_completed set.');
                }
                setStatus(`Live`);
            } catch (e) { console.error(`[Chart:${info.symbol}] âŒ Failed to process data:`, e); }
        };

        const handleInitialData = (response: any) => {
            if (response.interval !== timeframe || response.address.toLowerCase() !== info.contractAddress.toLowerCase()) return;
            log(`Received initial data for ${response.address}. Length: ${response.data?.length}`);
            if (response.data && response.data.length > 0) processData(response.data, true);
            else setStatus(`No Data`);
        };
        const handleCompletedData = (response: any) => {
            if (response.interval !== timeframe || response.address.toLowerCase() !== info.contractAddress.toLowerCase()) return;
            log(`Received completed data for ${response.address}. Length: ${response.data?.length}`);
            if (response.data && response.data.length > 0) processData(response.data, false);
        };
        const handleFetchError = (err: KlineFetchErrorPayload) => {
             const key = `${info.contractAddress.toLowerCase()}@${info.chain.toLowerCase()}@${timeframe}`;
             if(err.key === key) { log(`âŒ Fetch error: ${err.error}`); setStatus(`Error`); }
        };

        socket.on('historical_kline_initial', handleInitialData);
        socket.on('historical_kline_completed', handleCompletedData);
        socket.on('kline_fetch_error', handleFetchError);
        socket.on('kline_update', handleKlineUpdate);

        log('Emitting request_historical_kline and subscribe_kline.');
        socket.emit('request_historical_kline', payload);
        socket.emit('subscribe_kline', payload); 

        onCleanup(() => {
            log('Cleaning up data subscriptions.');
            unsubscribeRealtime(payload);
            socket.off('historical_kline_initial', handleInitialData);
            socket.off('historical_kline_completed', handleCompletedData);
            socket.off('kline_fetch_error', handleFetchError);
            cleanupChart();
        });
    });

    // [RECEIVER] æ¥æ”¶é€»è¾‘ç´¢å¼•åŒæ­¥
    createEffect(() => {
        const vs = props.viewportState;
        if (!chart || !vs || !props.tokenInfo) return;
        const myId = getMyId().toLowerCase();
        const activeId = props.activeChartId?.toLowerCase();
        if (myId === activeId) return;
        
        isProgrammaticUpdate = true;
        try {
            chart.timeScale().setVisibleLogicalRange({ from: vs.from, to: vs.to });
            log('Received and applied viewport sync.');
        } catch (e) { 
            console.error('Error applying synced viewport range:', e);
        }
        // ä½¿ç”¨ setTimeout (æˆ– Promise/queueMicrotask) ç¡®ä¿åœ¨ä¸‹ä¸€å¸§æˆ–åç»­æ‰§è¡Œä¸­è§£é™¤é”å®š
        setTimeout(() => { isProgrammaticUpdate = false; }, 0); 
    });

    onMount(() => {
        resizeObserver = new ResizeObserver(entries => {
            if (chart && chartContainer) {
                const { width, height } = entries[0].contentRect;
                chart.applyOptions({ width, height });
                log(`Chart resized to W:${width} H:${height}`);
            }
        });
        if (chartContainer) resizeObserver.observe(chartContainer);
    });

    onCleanup(() => resizeObserver?.disconnect());

    return (
        <div 
            class="single-chart-wrapper"
            style={{ background: props.theme.layout.background }} 
            onMouseEnter={() => props.onSetActiveChart?.(props.tokenInfo?.contractAddress || '')}
        >
            <div 
                class="chart-header"
                style={{
                    "background-color": props.theme.layout.background,
                    "color": props.theme.layout.textColor,
                    "border-bottom": `1px solid ${props.theme.grid.horzLines}`
                }}
            >
                <Show when={props.tokenInfo} fallback={<span class="placeholder" style={{color: props.theme.layout.textColor}}>{status()}</span>}>
                    <img src={`${BACKEND_URL}/image-proxy?url=${encodeURIComponent(props.tokenInfo!.icon!)}`} class="icon-small" alt={props.tokenInfo!.symbol}/>
                    <span class="symbol-title" style={{ color: props.theme.layout.textColor }}>{props.tokenInfo!.symbol}</span>
                    <span class="chain-badge">{props.tokenInfo!.chain.toUpperCase()}</span>
                    <button 
                        class="block-button" 
                        title={`å±è”½ ${props.tokenInfo!.symbol}`} 
                        onClick={() => props.onBlock?.(props.tokenInfo!.contractAddress)}
                        style={{ color: props.theme.layout.textColor }}
                    >
                        ğŸš«
                    </button>
                </Show>
            </div>
            <div ref={chartContainer!} class="chart-container" />
        </div>
    );

};

export default SingleKlineChart;
æˆ‘çš„æ€è€ƒä¸ç–‘é—®

ä½ æˆåŠŸåœ°è§£å†³äº†æˆäº¤é‡æ¸²æŸ“çš„é—®é¢˜ï¼Œè¿™ä¸ªå®ç°æ˜¯æ¨¡å—åŒ–å’Œé«˜æ€§èƒ½çš„ï¼š

æ¨¡å—åŒ–/èŒè´£åˆ†ç¦»ï¼šKçº¿å’Œæˆäº¤é‡å„è‡ªæ‹¥æœ‰ç‹¬ç«‹çš„ Series (CandlestickSeries å’Œ HistogramSeries)ï¼Œå¹¶é€šè¿‡ç‹¬ç«‹çš„ PriceScale æ¥æ§åˆ¶å…¶ä½ç½®å’Œç¼©æ”¾ï¼ŒèŒè´£æ¸…æ™°ã€‚

æ€§èƒ½ä¼˜åŒ–ï¼šåœ¨æ•°æ®å¤„ç†æ—¶ï¼Œä½ é¿å…äº†ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“ï¼Œé€šè¿‡ update() å¤„ç†å®æ—¶æ•°æ®ï¼Œé€šè¿‡ setData() æ‰¹é‡å¤„ç†å†å²æ•°æ®ï¼Œè¿™å¾ˆå¥å£®ã€‚ä½ è¿˜åœ¨è§†å£åŒæ­¥ä¸­åŠ å…¥äº† requestAnimationFrame å’ŒçŠ¶æ€é” (isProgrammaticUpdate), è¿›ä¸€æ­¥é˜²æ­¢äº†è§†å£åŒæ­¥å¼•èµ·çš„æ— é™å¾ªç¯å’Œæ€§èƒ½æµªè´¹ã€‚

æˆ‘çš„ç–‘é—®å’Œå»¶ä¼¸æ€è€ƒï¼š

Volume Scale è‡ªåŠ¨åŒ–é—®é¢˜ï¼š ä½ å°†æˆäº¤é‡çš„ PriceScale (priceScaleId: 'volume') çš„ visible è®¾ç½®ä¸º falseï¼Œè¿™é¿å…äº†åœ¨åº•éƒ¨æ˜¾ç¤ºæˆäº¤é‡æ•°å€¼çš„ Y è½´åˆ»åº¦ï¼Œä½¿å¾—ç•Œé¢æ›´ç®€æ´ã€‚ä½†æ˜¯ï¼Œå¦‚æœç”¨æˆ·éœ€è¦æ›´ç²¾ç¡®åœ°çŸ¥é“æŸä¸ªæˆäº¤é‡æŸ±çš„é«˜åº¦å€¼ï¼Œåº”è¯¥å¦‚ä½•å¤„ç†ï¼Ÿ

å»¶ä¼¸æ€è€ƒï¼š æ˜¯å¦å¯ä»¥è€ƒè™‘åœ¨ Crosshair æ¿€æ´»æ—¶ï¼Œé€šè¿‡è‡ªå®šä¹‰ Crosshair Marker æˆ– Tooltip åœ¨å›¾è¡¨ä¸Šæ–¹æ˜¾ç¤ºå½“å‰æŸ±å­çš„ç²¾ç¡®æˆäº¤é‡æ•°å€¼ï¼Œè¿™æ ·æ—¢ä¿æŒäº†ç®€æ´ï¼Œåˆæä¾›äº†æ•°æ®ç»†èŠ‚ï¼Ÿ

é¢œè‰²ä¸ä¸»é¢˜çš„è€¦åˆåº¦ï¼š æˆäº¤é‡æŸ±çš„é¢œè‰²æ˜¯ç›´æ¥ä» K çº¿çš„é¢œè‰²ä¸»é¢˜ (props.theme.candle.upColor / downColor) ç»§æ‰¿çš„ã€‚è¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„åšæ³•ã€‚

ç–‘é—®ï¼š æ—¢ç„¶ä½ çš„é¡¹ç›®ç›®æ ‡æ˜¯é«˜æ€§èƒ½å’Œå¥å£®ï¼Œæ˜¯å¦éœ€è¦ä¸ºæˆäº¤é‡åœ¨ä¸»é¢˜ä¸­æä¾›ç‹¬ç«‹çš„é¢œè‰²é…ç½®ï¼ˆä¾‹å¦‚ä¸€ä¸ªæ›´é€æ˜çš„ç‰ˆæœ¬ï¼Œå¦‚ rgba(R,G,B, 0.5)ï¼‰ï¼Œä»¥åœ¨è§†è§‰ä¸Šå°†å®ƒä¸ K çº¿åŒºåˆ†å¼€ï¼Œé¿å…æˆäº¤é‡è¿‡äºâ€œæŠ¢çœ¼â€ï¼Ÿè™½ç„¶è¿™å¯ä»¥åœ¨æ•°æ®å¤„ç†å‡½æ•°ä¸­æ‰‹åŠ¨ä¿®æ”¹é¢œè‰²å­—ç¬¦ä¸²å®ç°ï¼ˆä¾‹å¦‚ä½¿ç”¨ CSS å˜é‡æˆ–åœ¨ SolidJS ä¸­è¿›è¡Œé¢œè‰²è½¬æ¢ï¼‰ï¼Œä½†å¦‚æœå°†æ¥éœ€è¦æ›´çµæ´»çš„ä¸»é¢˜æ§åˆ¶ï¼Œå¢åŠ ç‹¬ç«‹çš„ Volume é¢œè‰²å­—æ®µä¼šæ›´å…·æ‰©å±•æ€§ã€‚

è¿™ä¸ªå®ç°å·²ç»éå¸¸ä¼˜ç§€ï¼Œå®Œå…¨è¾¾åˆ°äº†ä½ è¦æ±‚çš„é«˜æ€§èƒ½å’Œå¥å£®æ€§æ ‡å‡†ã€‚