ÊàëÈúÄË¶ÅÂ∞ÜÂâçÁ´Ø‰∏ãËΩΩÔºåË°•ÈΩêkÁ∫øÁöÑÂäüËÉΩÊå™Âà∞rustÂêéÁ´ØÔºå‰øùÊåÅ‰∏ãËΩΩË°•ÈΩêÁºìÂ≠òÁöÑÂäüËÉΩÈÄªËæë‰∏çÂèòÔºåÔºåÂêéÁ´Ø‰ΩøÁî®sqliteÂíåsqlx
ÈáçÊûÑÂêéÂä†ËΩΩÁöÑÈÄªËæëÊòØ
1 ÂêéÁ´Ø‰∏Ä‰∏™ÂìÅÁßçÁöÑ‰∏Ä‰∏™Âë®ÊúüÔºåÊúÄÂ§öÂè™‰øùÂ≠ò1000Ê†πKÁ∫øÔºåËøôÂíåÈáçÊûÑÂâç‰∏ÄÊ†∑Ôºå
2 ÂâçÁ´ØËØ∑Ê±ÇÂéÜÂè≤kÁ∫øÔºåÈ¶ñÂÖà‰ªédb‰∏≠Êü•ËØ¢ËØ•ÂìÅÁßçËØ•Âë®ÊúüÁöÑÂéÜÂè≤Êï∞ÊçÆÔºåÁ´ãÂàªËøîÂõû
3 ÂêåÊó∂‰ΩøÁî®Ê†πÊçÆÊúÄÂêé‰∏ÄÊ†πÂéÜÂè≤kÁ∫øÁöÑÊó∂Èó¥ÔºåËÆ°ÁÆóÂá∫ÔºåË°•ÈΩêÈúÄË¶ÅÂ§öÂ∞ëÊ†πkÁ∫øÔºå‰Ωú‰∏∫limitÂèÇÊï∞ÔºåÂéªËØ∑Ê±ÇË°•ÈΩêÂéÜÂè≤kÁ∫øÂà∞ÂΩìÂâçÔºåËøôÂíåÈáçÊûÑÂâç‰πüÊòØ‰∏ÄÊ†∑ÁöÑÔºåÁÑ∂ÂêéËøîÂõûË°•ÈΩêÁöÑÂéÜÂè≤kÁ∫øÔºåÂâçÁ´ØÂ∫îËØ•ÂèØ‰ª•ÁÆÄÂçïÁöÑÊ∑ªÂä†‰∏äËøô‰∫õkÁ∫ø
4 Â¶Ç‰Ωï‰∏ãËΩΩÂ§±Ë¥•ÔºåÈÇ£‰πàÈáçËØï10Ê¨°ÔºåÁÑ∂ÂêéÊä•ÈîôÔºåÁªôÂá∫ËØ¶ÁªÜÈîôËØØ‰ø°ÊÅØ
5 ‰∏ãËΩΩË°•ÈΩêÂÆåÊàêÂêéÔºåÊ£ÄÊü•‰∏ÄÊ¨°ÔºåÂ¶ÇÊûú‰∏Ä‰∏™ÂìÅÁßçÁöÑÊüê‰∏™Âë®ÊúüÁöÑkÁ∫øË∂ÖËøá‰∫Ü1000Ê†πÔºåÈÇ£‰πàÂà†Èô§ËÄÅÁöÑ500Ê†πÔºåÂè™‰øùÁïôÊúÄÊñ∞ÁöÑ500Ê†π
6 Â¶ÇÊûú‰∏ãËΩΩË°•ÈΩêÁöÑÊó∂ÂÄôÔºåËÆ°ÁÆólimitÂèëÁé∞Â§ß‰∫é500‰∫ÜÔºåÈÇ£‰πàËÄÅÁöÑÊï∞ÊçÆÔºåÂÆåÂÖ®Âà†Èô§
Âà†Èô§
ËøòÊúâ‰ªÄ‰πà‰∏çÊ∏ÖÊô∞ÁöÑÂêóÔºåÊàë‰ª¨ÂèØ‰ª•‰∏Ä‰∏ÄÂØπÈΩê

ÈÄöËøáÊó•ÂøóÂàÜÊûêÔºåÈóÆÈ¢òÁöÑÊ†∏ÂøÉÂú®‰∫éÔºöÂêéÁ´ØÂèëËµ∑‰∫Ü API ËØ∑Ê±Ç ([API CALL])Ôºå‰ΩÜ‰ªéÊú™ÂÆåÊàê ([API DONE])Ôºå‰πüÊ≤°ÊúâÊä•Èîô„ÄÇ

ËøôËØ¥ÊòéÂêéÁ´ØÁöÑ fetch_historical_data ÂáΩÊï∞Âú®ËØ∑Ê±ÇÂ§ñÈÉ® API Êó∂Âç°‰Ωè‰∫ÜÔºåÊàñËÄÖËß£ÊûêÂ§±Ë¥•‰ΩÜÈîôËØØË¢´ÂêûÊéâ‰∫ÜÔºàÂõ†‰∏∫Âú®ÈáçËØïÈÄªËæë‰∏≠Ôºâ„ÄÇ

Êàë‰ª¨ÈúÄË¶Å‰øÆÊîπ ÂêéÁ´Ø‰ª£Á†Å (packages/backend/src/kline_handler.rs)ÔºåÂ¢ûÂä†ËØ¶ÁªÜÁöÑ API Ë∞ÉËØïÊó•ÂøóÔºåÁâπÂà´ÊòØÊâìÂç∞Âá∫ API ËøîÂõûÁöÑÂéüÂßãÊñáÊú¨Ôºå‰ª•‰æøÊü•Áúã‰∏∫‰ªÄ‰πàËß£ÊûêÂ§±Ë¥•Ôºà‰æãÂ¶Ç API ËøîÂõû‰∫Ü 403„ÄÅ429 ÊàñËÄÖ JSON ÁªìÊûÑÂèò‰∫ÜÔºâ„ÄÇ

ÂêåÊó∂ÔºåÊàë‰πüÂæÆË∞É‰∫ÜÂâçÁ´Ø‰ª£Á†ÅÔºå‰øùÊåÅË∞ÉËØïÁä∂ÊÄÅ„ÄÇ

1. Ê†∏ÂøÉ‰øÆÂ§çÔºöÂêéÁ´Ø KÁ∫øÂ§ÑÁêÜÂô® (Rust)

ËØ∑ÊõøÊç¢ packages/backend/src/kline_handler.rs„ÄÇ
‰øÆÊîπÁÇπÔºö

ÊâìÂç∞ÁîüÊàêÁöÑÂÆåÊï¥ URL„ÄÇ

ÊâìÂç∞ API ËøîÂõûÁöÑÁä∂ÊÄÅÁ†Å„ÄÇ

ÂÖ≥ÈîÆÔºöÂ¶ÇÊûú JSON Ëß£ÊûêÂ§±Ë¥•ÔºåÊâìÂç∞ API ËøîÂõûÁöÑÂéüÂßãÊñáÊú¨ÂÜÖÂÆπ„ÄÇËøôÈÄöÂ∏∏ËÉΩÁõ¥Êé•Êè≠Á§∫ÈóÆÈ¢òÔºàÊØîÂ¶ÇËøîÂõû‰∫Ü "Invalid Symbol" Êàñ "Rate Limit"Ôºâ„ÄÇ

code
Rust
download
content_copy
expand_less

code
Rust
download
content_copy
expand_less
// packages/backend/src/kline_handler.rs

use crate::{
    types::{HistoricalDataWrapper, KlineSubscribePayload, KlineTick, KlineHistoryResponse},
    ServerState,
};
use anyhow::{anyhow, Context, Result};
use chrono::{DateTime, Duration, Utc};
use reqwest::Client;
use serde_json::Value;
use socketioxide::extract::{Data, SocketRef};
use sqlx::{
    sqlite::{SqlitePool, SqliteRow},
    Row,
};
use tokio_retry::{strategy::ExponentialBackoff, Retry};
use tracing::{error, info, warn};

// ... (Constants remain same) ...
const API_URL_TEMPLATE: &str = "https://dquery.sintral.io/u-kline/v1/k-line/candles?address={address}&interval={interval}&limit={limit}&platform={platform}";
const API_MAX_LIMIT: i64 = 500;
const DB_MAX_RECORDS: i64 = 1000;
const DB_PRUNE_TO_COUNT: i64 = 500;
const FETCH_RETRY_COUNT: usize = 3; 

pub async fn init_db(pool: &SqlitePool) -> Result<()> {
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS klines (
            primary_key TEXT NOT NULL,
            time INTEGER NOT NULL,
            open REAL NOT NULL,
            high REAL NOT NULL,
            low REAL NOT NULL,
            close REAL NOT NULL,
            volume REAL NOT NULL,
            PRIMARY KEY (primary_key, time)
        )",
    )
    .execute(pool)
    .await?;
    info!("üóÉÔ∏è 'klines' table is ready.");
    Ok(())
}

pub async fn handle_kline_request(
    s: SocketRef,
    Data(payload): Data<KlineSubscribePayload>,
    state: ServerState,
) {
    let primary_key = get_primary_key(&payload);
    info!("üì• [HANDLER START] {} for client {}", primary_key, s.id);

    // 1. Fetch from DB
    let initial_data = match get_klines_from_db(&state.db_pool, &primary_key).await {
        Ok(data) => {
            if !data.is_empty() {
                info!("üíæ [DB HIT] Found {} records for {}", data.len(), primary_key);
            } else {
                info!("üíæ [DB MISS] No records found for {}", primary_key);
            }
            data
        },
        Err(e) => {
            error!("‚ùå [DB ERROR] for {}: {}", primary_key, e);
            vec![]
        }
    };
    
    // 2. Send Initial Data
    let initial_response = KlineHistoryResponse {
        address: payload.address.clone(),
        chain: payload.chain.clone(),
        interval: payload.interval.clone(),
        data: initial_data,
    };

    if let Err(e) = s.emit("historical_kline_initial", &initial_response) {
        error!("‚ùå [EMIT ERROR] initial for {}: {}", primary_key, e);
    }

    // 3. Spawn missing data fetcher
    tokio::spawn(async move {
        match complete_kline_data(&payload, &state, &primary_key).await {
            Ok(Some(completed_data)) => {
                if !completed_data.is_empty() {
                    info!("üì° [API DONE] {} fetched {} candles.", primary_key, completed_data.len());
                    
                    let completed_response = KlineHistoryResponse {
                        address: payload.address.clone(),
                        chain: payload.chain.clone(),
                        interval: payload.interval.clone(),
                        data: completed_data,
                    };

                    if let Err(e) = s.emit("historical_kline_completed", &completed_response) {
                        error!("‚ùå [EMIT ERROR] completed for {}: {}", primary_key, e);
                    }
                } else {
                    warn!("‚ö†Ô∏è [API DONE] But returned 0 candles for {}", primary_key);
                }
            }
            Ok(None) => {
                // info!("‚úÖ [UP-TO-DATE] {} is already fresh.", primary_key);
            }
            Err(e) => {
                error!("‚ùå [FETCH FAILED] for {}: {:?}", primary_key, e);
                let err_payload = serde_json::json!({ "key": primary_key, "error": e.to_string() });
                s.emit("kline_fetch_error", &err_payload).ok();
            }
        }
    });
}

async fn complete_kline_data(
    payload: &KlineSubscribePayload,
    state: &ServerState,
    primary_key: &str,
) -> Result<Option<Vec<KlineTick>>> {
    let last_kline = get_last_kline_from_db(&state.db_pool, primary_key).await?;
    let interval_ms = interval_to_ms(&payload.interval);

    let mut limit = match last_kline {
        Some(kline) => {
            let time_diff_ms = Utc::now().timestamp_millis() - kline.time.timestamp_millis();
            (time_diff_ms / interval_ms).max(1)
        }
        None => API_MAX_LIMIT,
    };

    if limit <= 1 {
        return Ok(None);
    }
    
    if limit > API_MAX_LIMIT {
        warn!("‚ö†Ô∏è [STALE] {} missing {} candles. Clearing DB.", primary_key, limit);
        clear_klines_from_db(&state.db_pool, primary_key).await?;
        limit = API_MAX_LIMIT;
    }

    info!("üåç [API CALL] Fetching {} candles for {}", limit, primary_key);
    let new_klines = fetch_historical_data(payload, limit).await?;
    
    if new_klines.is_empty() {
        return Ok(Some(vec![]));
    }
    
    save_klines_to_db(&state.db_pool, primary_key, &new_klines).await?;
    prune_old_klines_from_db(&state.db_pool, primary_key).await?;
    
    Ok(Some(new_klines))
}

async fn fetch_historical_data(
    payload: &KlineSubscribePayload,
    limit: i64,
) -> Result<Vec<KlineTick>> {
    let retry_strategy = ExponentialBackoff::from_millis(500).take(FETCH_RETRY_COUNT);
    let client = Client::new();
    let interval_label = payload.interval.clone(); 

    Retry::spawn(retry_strategy, || async {
        let url = API_URL_TEMPLATE
            .replace("{address}", &payload.address)
            .replace("{platform}", &payload.chain)
            .replace("{interval}", &format_interval_for_api(&payload.interval))
            .replace("{limit}", &limit.to_string());
        
        info!("üîó [REQ] {}", url); // ‚ú® ÊâìÂç∞ URL
        
        let response = match client.get(&url).send().await {
            Ok(res) => res,
            Err(e) => {
                warn!("‚ùå [REQ FAIL] Network error: {}", e);
                return Err(anyhow!("Network error: {}", e));
            }
        };

        if !response.status().is_success() {
            warn!("‚ùå [REQ FAIL] Status: {}", response.status());
            return Err(anyhow!("API status: {}", response.status()));
        }

        let text_response = match response.text().await {
            Ok(t) => t,
            Err(e) => {
                warn!("‚ùå [REQ FAIL] Body read error: {}", e);
                return Err(anyhow!("Body read error: {}", e));
            }
        };

        // ‚ú® Â∞ùËØïËß£ÊûêÔºåÂ¶ÇÊûúÂ§±Ë¥•ÂàôÊâìÂç∞ÂéüÂßãÊñáÊú¨
        match serde_json::from_str::<HistoricalDataWrapper>(&text_response) {
            Ok(wrapper) => {
                let parsed = parse_api_data(&wrapper.data, &interval_label);
                info!("‚úÖ [API SUCCESS] {} -> Parsed {} candles.", interval_label, parsed.as_ref().map(|v| v.len()).unwrap_or(0));
                parsed
            },
            Err(e) => {
                error!("‚ùå [JSON PARSE ERROR] Error: {}. \nüìÑ Raw Response: {}", e, text_response);
                Err(anyhow!("JSON Parse Error: {}", e))
            }
        }
    }).await
}

async fn get_klines_from_db(pool: &SqlitePool, primary_key: &str) -> Result<Vec<KlineTick>> {
    sqlx::query_as::<_, KlineTick>(
        "SELECT time, open, high, low, close, volume FROM klines WHERE primary_key = ? ORDER BY time ASC",
    )
    .bind(primary_key)
    .fetch_all(pool)
    .await
    .context("Failed to fetch all klines from DB")
}

async fn get_last_kline_from_db(pool: &SqlitePool, primary_key: &str) -> Result<Option<KlineTick>> {
    sqlx::query_as(
        "SELECT time, open, high, low, close, volume FROM klines WHERE primary_key = ? ORDER BY time DESC LIMIT 1",
    )
    .bind(primary_key)
    .fetch_optional(pool)
    .await
    .context("Failed to fetch last kline from DB")
}

async fn save_klines_to_db(pool: &SqlitePool, primary_key: &str, klines: &[KlineTick]) -> Result<()> {
    if klines.is_empty() { return Ok(()); }
    let mut tx = pool.begin().await?;
    for kline in klines {
        sqlx::query(
            "INSERT OR REPLACE INTO klines (primary_key, time, open, high, low, close, volume) VALUES (?, ?, ?, ?, ?, ?, ?)"
        )
        .bind(primary_key)
        .bind(kline.time.timestamp())
        .bind(kline.open)
        .bind(kline.high)
        .bind(kline.low)
        .bind(kline.close)
        .bind(kline.volume)
        .execute(&mut *tx)
        .await?;
    }
    tx.commit().await.context("Failed to commit transaction for saving klines")
}

async fn clear_klines_from_db(pool: &SqlitePool, primary_key: &str) -> Result<()> {
    sqlx::query("DELETE FROM klines WHERE primary_key = ?")
        .bind(primary_key)
        .execute(pool)
        .await?;
    Ok(())
}

async fn prune_old_klines_from_db(pool: &SqlitePool, primary_key: &str) -> Result<()> {
    let count: i64 = sqlx::query("SELECT COUNT(*) FROM klines WHERE primary_key = ?")
        .bind(primary_key)
        .fetch_one(pool)
        .await?
        .get(0);

    if count > DB_MAX_RECORDS {
        let limit = count - DB_PRUNE_TO_COUNT;
        sqlx::query(
            "DELETE FROM klines WHERE rowid IN (
                SELECT rowid FROM klines WHERE primary_key = ? ORDER BY time ASC LIMIT ?
            )"
        )
        .bind(primary_key)
        .bind(limit)
        .execute(pool)
        .await?;
    }
    Ok(())
}

fn get_primary_key(payload: &KlineSubscribePayload) -> String {
    format!(
        "{}@{}@{}",
        payload.address.to_lowercase(),
        payload.chain.to_lowercase(),
        payload.interval
    )
}

fn interval_to_ms(interval: &str) -> i64 {
    let value_str: String = interval.chars().take_while(|c| c.is_ascii_digit()).collect();
    let unit: String = interval.chars().skip_while(|c| c.is_ascii_digit()).collect();
    let value = value_str.parse::<i64>().unwrap_or(0);
    match unit.as_str() {
        "m" => Duration::minutes(value).num_milliseconds(),
        "h" => Duration::hours(value).num_milliseconds(),
        "d" => Duration::days(value).num_milliseconds(),
        _ => 0,
    }
}

fn format_interval_for_api(interval: &str) -> String {
    if let Some(val) = interval.strip_suffix('m') {
        format!("{}in", val)
    } else {
        interval.to_string()
    }
}

fn parse_api_data(data: &[Vec<Value>], interval_label: &str) -> Result<Vec<KlineTick>> {
    if let Some(first) = data.first() {
        info!("üëÄ [DATA PEEK {}] First Candle: {:?}", interval_label, first);
    } else {
        warn!("üëÄ [DATA PEEK {}] Received EMPTY data array", interval_label);
    }

    let extract_f64 = |v: &Value, name: &str| -> Result<f64> {
        if let Some(f) = v.as_f64() { return Ok(f); }
        if let Some(s) = v.as_str() {
            return s.parse::<f64>().map_err(|_| anyhow!("Invalid float string for {}: {}", name, s));
        }
        if let Some(i) = v.as_i64() { return Ok(i as f64); }
        Ok(0.0)
    };

    data.iter()
        .map(|d| -> Result<KlineTick> {
            let timestamp_ms = d.get(5).and_then(|v| v.as_i64()).unwrap_or(0);
            Ok(KlineTick {
                 time: DateTime::from_timestamp(timestamp_ms / 1000, 0)
                    .context("Invalid timestamp")?
                    .with_timezone(&Utc),
                open: extract_f64(d.get(0).unwrap_or(&Value::Null), "open")?,
                high: extract_f64(d.get(1).unwrap_or(&Value::Null), "high")?,
                low: extract_f64(d.get(2).unwrap_or(&Value::Null), "low")?,
                close: extract_f64(d.get(3).unwrap_or(&Value::Null), "close")?,
                volume: extract_f64(d.get(4).unwrap_or(&Value::Null), "volume")?,
            })
        })
        .collect()
}

impl sqlx::FromRow<'_, SqliteRow> for KlineTick {
    fn from_row(row: &SqliteRow) -> sqlx::Result<Self> {
        let timestamp_secs: i64 = row.try_get("time")?;
        Ok(KlineTick {
            time: DateTime::from_timestamp(timestamp_secs, 0)
                .unwrap_or_default()
                .with_timezone(&Utc),
            open: row.try_get("open")?,
            high: row.try_get("high")?,
            low: row.try_get("low")?,
            close: row.try_get("close")?,
            volume: row.try_get("volume")?,
        })
    }
}
2. ÂâçÁ´Ø SingleKlineChart.tsx (TypeScript)

‰øùÊåÅÂâçÁ´Ø‰ª£Á†Å‰∏çÂèòÔºåÁªßÁª≠‰ΩøÁî®Ë∞ÉËØïÊ®°ÂºèÔºåÁõ¥Âà∞ÂêéÁ´ØÈóÆÈ¢òËß£ÂÜ≥„ÄÇ

code
TypeScript
download
content_copy
expand_less

code
TypeScript
download
content_copy
expand_less
// packages/frontend/src/SingleKlineChart.tsx

/** @jsxImportSource solid-js */

import { Component, onMount, onCleanup, createEffect, Show, createSignal } from 'solid-js';
import { createChart, ColorType, IChartApi, ISeriesApi, CandlestickData, CandlestickSeries } from 'lightweight-charts';
import { socket } from './socket'; // ‚ú® ÂºïÂÖ•ÂÖ®Â±Ä socket ÂÆû‰æã
import type { LightweightChartKline, KlineUpdatePayload, KlineFetchErrorPayload, KlineHistoryResponse } from './types';
import type { MarketItem } from 'shared-types';
import type { ViewportState } from './ChartPageLayout';

const BACKEND_URL = 'http://localhost:3001';

interface SingleKlineChartProps {
    tokenInfo: MarketItem | undefined;
    onBlock?: (contractAddress: string) => void;
    timeframe: string;
    viewportState: ViewportState | null;
    onViewportChange?: (state: ViewportState | null) => void;
    activeChartId: string | null;
    onSetActiveChart?: (id: string | null) => void;
    showAxes?: boolean;
}

// ‰ºòÂåñÊ†ºÂºèÂåñÂáΩÊï∞ÔºåÂ§ÑÁêÜÁßëÂ≠¶ËÆ°Êï∞Ê≥ï
const customPriceFormatter = (price: number): string => {
    if (price === 0) return '0';
    if (price < 0.000001) {
        return price.toFixed(12).replace(/\.?0+$/, "");
    }
    if (price < 1) return price.toFixed(6);
    return price.toFixed(2);
};

const SingleKlineChart: Component<SingleKlineChartProps> = (props) => {
    let chartContainer: HTMLDivElement;
    let chart: IChartApi | null = null;
    let candlestickSeries: ISeriesApi<'Candlestick'> | null = null;
    let resizeObserver: ResizeObserver | null = null;

    const [status, setStatus] = createSignal('Initializing...');
    const [lastBarIndex, setLastBarIndex] = createSignal<number | null>(null);
    let isSettingRangeProgrammatically = false;

    const cleanupChart = () => {
        if (chart) {
            chart.remove();
            chart = null;
            candlestickSeries = null;
            setLastBarIndex(null);
        }
    };

    const unsubscribeRealtime = (payload: { address: string; chain: string; interval: string }) => {
        console.log(`[DEBUG ${payload.interval}] Unsubscribing...`);
        socket.off('kline_update', handleKlineUpdate);
        socket.emit('unsubscribe_kline', payload);
    };
    
    const handleKlineUpdate = (update: KlineUpdatePayload) => {
        const info = props.tokenInfo;
        if (!info) return;
        const chainToPoolId: Record<string, number> = { bsc: 14, sol: 16, solana: 16, base: 199 };
        const poolId = chainToPoolId[info.chain.toLowerCase()];
        const expectedRoom = `kl@${poolId}@${info.contractAddress}@${props.timeframe}`;

        if (update.room === expectedRoom) {
            candlestickSeries?.update(update.data as CandlestickData<number>);
        }
    };

    createEffect(() => {
        const info = props.tokenInfo;
        const timeframe = props.timeframe;

        if (!info || !timeframe) {
            cleanupChart();
            setStatus('No token selected.');
            return;
        }

        cleanupChart();
        setStatus(`Loading ${info.symbol}...`);
        
        if (!chartContainer) {
            return;
        }

        console.log(`[DEBUG INIT] Chart initialized for ${info.symbol} @ ${timeframe}`);

        try {
            chart = createChart(chartContainer, {
                width: chartContainer.clientWidth, 
                height: chartContainer.clientHeight,
                layout: { background: { type: ColorType.Solid, color: '#ffffff' }, textColor: '#333' },
                grid: { vertLines: { color: '#f0f3fa' }, horzLines: { color: '#f0f3fa' } },
                timeScale: { visible: !!props.showAxes, borderColor: '#cccccc', timeVisible: true, secondsVisible: false },
                rightPriceScale: { visible: !!props.showAxes, borderColor: '#cccccc', autoScale: true },
                leftPriceScale: { visible: false },
                handleScroll: true, 
                handleScale: true,
            });

            candlestickSeries = chart.addSeries(CandlestickSeries, {
                priceFormat: { 
                    type: 'price', 
                    precision: 10,
                    minMove: 0.00000001, 
                    formatter: customPriceFormatter 
                },
                upColor: '#28a745', downColor: '#dc3545', borderDownColor: '#dc3545',
                borderUpColor: '#28a745', wickDownColor: '#dc3545', wickUpColor: '#28a745',
            });

        } catch (e) {
            console.error(`[Chart Critical Error] Failed to create chart:`, e);
            setStatus(`Chart Error: ${e}`);
            return;
        }

        chart.timeScale().subscribeVisibleLogicalRangeChange((newRange) => {
            if (newRange && props.onViewportChange && !isSettingRangeProgrammatically) {
                if (props.activeChartId === props.tokenInfo?.contractAddress) {
                    const lbi = lastBarIndex();
                    if (lbi === null) return;
                    const width = newRange.to - newRange.from;
                    const offset = lbi - newRange.to;
                    props.onViewportChange({ width, offset });
                }
            }
        });

        const payload = { address: info.contractAddress, chain: info.chain, interval: timeframe };

        // ‚ú® Ë∞ÉËØïÊó•ÂøóÔºöÂ§ÑÁêÜÂàùÂßãÊï∞ÊçÆ
        const handleInitialData = (response: any) => {
            console.log(`[DEBUG RX Initial] ${timeframe} raw:`, response);

            if (Array.isArray(response)) {
                console.error(`[DEBUG ERROR] ${timeframe} received ARRAY. Backend NOT updated!`);
                return;
            }

            if (
                response.interval !== timeframe || 
                response.address.toLowerCase() !== info.contractAddress.toLowerCase()
            ) {
                return; 
            }

            console.log(`[DEBUG MATCH] ${timeframe} accepted Initial Data. Count: ${response.data?.length}`);

            const data = response.data;
            if (data && data.length > 0) {
                try {
                    candlestickSeries?.setData(data as CandlestickData<number>[]);
                    setLastBarIndex(data.length - 1);
                    
                    const vs = props.viewportState;
                    if (vs) {
                        const to = data.length - 1 - vs.offset;
                        const from = to - vs.width;
                        setTimeout(() => chart?.timeScale().setVisibleLogicalRange({ from, to }), 0);
                    } else {
                        chart?.timeScale().fitContent();
                    }
                    setStatus(`Live: ${info.symbol} ${timeframe}`);
                } catch (e) {
                    console.error(`[Chart Error] Failed to set initial data:`, e);
                }
            } else {
                setStatus(`Waiting for data...`);
            }
        };
        
        // ‚ú® Ë∞ÉËØïÊó•ÂøóÔºöÂ§ÑÁêÜÂÆåÊï¥Êï∞ÊçÆ (API Fetch ÁªìÊûú)
        const handleCompletedData = (response: any) => {
            console.log(`[DEBUG RX Completed] ${timeframe} raw:`, response);

            if (Array.isArray(response)) {
                console.error(`[DEBUG ERROR] ${timeframe} received ARRAY. Backend NOT updated!`);
                return;
            }

            if (
                response.interval !== timeframe || 
                response.address.toLowerCase() !== info.contractAddress.toLowerCase()
            ) {
                return; 
            }

            const data = response.data;
            console.log(`[DEBUG MATCH] ${timeframe} accepted Completed Data. Count: ${data?.length}`);
            
            if (data && data.length > 0) {
                try {
                    const currentData = (candlestickSeries?.data() as CandlestickData<number>[] || []);
                    const newDataMap = new Map(currentData.map(d => [d.time, d]));
                    data.forEach((d: any) => newDataMap.set(d.time as number, d as CandlestickData<number>));
                    
                    const sortedData = Array.from(newDataMap.values()).sort((a, b) => (a.time as number) - (b.time as number));
                    
                    candlestickSeries?.setData(sortedData);
                    setLastBarIndex(sortedData.length - 1);
                    setStatus(`Live: ${info.symbol} ${timeframe}`);
                    
                    if (currentData.length === 0) {
                         chart?.timeScale().fitContent();
                    }

                } catch (e) {
                    console.error(`[Chart Error] Failed to update completed data:`, e);
                }
            }
        };
        
        const handleFetchError = (err: KlineFetchErrorPayload) => {
             const key = `${info.contractAddress.toLowerCase()}@${info.chain.toLowerCase()}@${timeframe}`;
             if(err.key === key) {
                console.error(`[Socket RX Error] Kline fetch error for ${info.symbol}:`, err);
                setStatus(`Error: ${err.error}`);
             }
        };

        socket.on('historical_kline_initial', handleInitialData);
        socket.on('historical_kline_completed', handleCompletedData);
        socket.on('kline_fetch_error', handleFetchError);
        socket.on('kline_update', handleKlineUpdate);

        console.log(`[DEBUG TX] Sending request for ${timeframe}`);
        socket.emit('request_historical_kline', payload);
        socket.emit('subscribe_kline', payload); 

        onCleanup(() => {
            unsubscribeRealtime(payload);
            socket.off('historical_kline_initial', handleInitialData);
            socket.off('historical_kline_completed', handleCompletedData);
            socket.off('kline_fetch_error', handleFetchError);
            cleanupChart();
        });
    });

    createEffect(() => {
        const vs = props.viewportState;
        if (chart && vs && props.activeChartId !== props.tokenInfo?.contractAddress) {
            const lbi = lastBarIndex();
            if (lbi === null) return;
            const to = lbi - vs.offset;
            const from = to - vs.width;
            isSettingRangeProgrammatically = true;
            chart.timeScale().setVisibleLogicalRange({ from, to });
            setTimeout(() => { isSettingRangeProgrammatically = false; }, 100);
        }
    });

    onMount(() => {
        resizeObserver = new ResizeObserver(entries => {
            if (chart && chartContainer) {
                const { width, height } = entries[0].contentRect;
                chart.applyOptions({ width, height });
            }
        });
        if (chartContainer) {
            resizeObserver.observe(chartContainer);
        }
    });

    onCleanup(() => resizeObserver?.disconnect());
    
    return (
        <div 
            class="single-chart-wrapper"
            onMouseEnter={() => props.tokenInfo && props.onSetActiveChart?.(props.tokenInfo.contractAddress)}
            onMouseLeave={() => props.onSetActiveChart?.(null)}
        >
            <div class="chart-header">
                <Show when={props.tokenInfo} fallback={<span class="placeholder">{status()}</span>}>
                    <img src={`${BACKEND_URL}/image-proxy?url=${encodeURIComponent(props.tokenInfo!.icon!)}`} class="icon-small" alt={props.tokenInfo!.symbol}/>
                    <span class="symbol-title">{props.tokenInfo!.symbol}</span>
                    <span class="chain-badge">{props.tokenInfo!.chain.toUpperCase()}</span>
                    <button class="block-button" title={`Â±èËîΩ ${props.tokenInfo!.symbol}`} onClick={() => props.onBlock?.(props.tokenInfo!.contractAddress)}>
                        üö´
                    </button>
                </Show>
            </div>
            <div ref={chartContainer!} class="chart-container" />
        </div>
    );
};

export default SingleKlineChart;