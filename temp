è¿™æ˜¯ä¸€ä¸ªéå¸¸å…¸å‹çš„ Lightweight-charts (LWC) é”™è¯¯ã€‚

é”™è¯¯åŸå› åˆ†æ

Error: Cannot update oldest data çš„æ„æ€æ˜¯ï¼šä½ æ­£åœ¨å°è¯•ç”¨ update() æ–¹æ³•æ›´æ–°ä¸€ä¸ª æ¯”å½“å‰å›¾è¡¨ä¸­æœ€åä¸€æ ¹ K çº¿æ—¶é—´æ›´æ—© çš„æ•°æ®ã€‚

LWC çš„ series.update(bar) æ–¹æ³•æœ‰ä¸¥æ ¼é™åˆ¶ï¼š

åªèƒ½å‘åè¿½åŠ ï¼šä¼ å…¥çš„ bar.time å¿…é¡» å¤§äº å½“å‰æœ€åä¸€æ¡æ•°æ®çš„ timeã€‚

æˆ–è€…åŸåœ°æ›´æ–°ï¼šä¼ å…¥çš„ bar.time å¿…é¡» ç­‰äº å½“å‰æœ€åä¸€æ¡æ•°æ®çš„ timeï¼ˆç”¨äºå®æ—¶å˜åŠ¨çš„æ”¶ç›˜ä»·ï¼‰ã€‚

ç»å¯¹ä¸èƒ½å›é€€ï¼šå¦‚æœ bar.time < lastBar.timeï¼Œå°±ä¼šæŠ¥ä½ é‡åˆ°çš„è¿™ä¸ªé”™ã€‚

äº§ç”Ÿåœºæ™¯ï¼š
ç”±äºç½‘ç»œå»¶è¿Ÿæˆ–å¼‚æ­¥åŠ è½½ï¼ŒWebSocket æ¨é€çš„ å®æ—¶åŒ… å¯èƒ½æ¯” å†å²æ•°æ®åŠ è½½å®Œæˆ æ›´æ—©åˆ°è¾¾ï¼Œæˆ–è€…ä¸¤ä¸ªå®æ—¶åŒ…åˆ°è¾¾é¡ºåºä¹±äº†ï¼ˆæ¯”å¦‚ï¼šå…ˆæ”¶åˆ°äº† 10:02 çš„åŒ…ï¼Œå¤„ç†äº†ï¼›ç´§æ¥ç€æ”¶åˆ°äº† 10:01 çš„å»¶è¿ŸåŒ…ï¼Œå† update å°±ä¼šæŠ¥é”™ï¼‰ã€‚

è§£å†³æ–¹æ¡ˆ

åœ¨è°ƒç”¨ update() ä¹‹å‰ï¼Œå¿…é¡»åŠ ä¸€å±‚ é˜²å«é€»è¾‘ï¼šæ£€æŸ¥æ–°æ¥çš„æ•°æ®æ—¶é—´æ˜¯å¦å°äºå½“å‰æœ€åä¸€æ ¹ K çº¿çš„æ—¶é—´ã€‚å¦‚æœæ˜¯ï¼Œåˆ™ä¸¢å¼ƒè¯¥â€œè¿Ÿåˆ°â€çš„æ•°æ®ã€‚

è¯·ç›´æ¥å¤åˆ¶æ›¿æ¢ packages/frontend/src/SingleKlineChart.tsxï¼Œä¸»è¦ä¿®æ”¹äº† handleKlineUpdate å‡½æ•°ï¼š

packages/frontend/src/SingleKlineChart.tsx

code
TypeScript
download
content_copy
expand_less
// packages/frontend/src/SingleKlineChart.tsx

/** @jsxImportSource solid-js */

import { Component, onMount, onCleanup, createEffect, Show, createSignal } from 'solid-js';
import { createChart, ColorType, IChartApi, ISeriesApi, CandlestickData, CandlestickSeries, Time } from 'lightweight-charts';
import { socket } from './socket';
import type { LightweightChartKline, KlineUpdatePayload, KlineFetchErrorPayload } from './types';
import type { MarketItem } from 'shared-types';
import type { ViewportState } from './ChartPageLayout';

const BACKEND_URL = 'http://localhost:3001';

// --- é…ç½®åŒº ---
// å¼ºåˆ¶è¡¥é½çš„Kçº¿æ•°é‡ï¼Œç”¨äºç»Ÿä¸€æ‰€æœ‰å›¾è¡¨çš„Xè½´æ—¶é—´è·¨åº¦ï¼Œè§£å†³æ–°è€å¸ç§åŒæ­¥æ‹–åŠ¨ä¸åŒæ­¥çš„é—®é¢˜
const FORCE_GHOST_CANDLE_COUNT = 1000;

interface SingleKlineChartProps {
tokenInfo: MarketItem | undefined;
onBlock?: (contractAddress: string) => void;
timeframe: string;
viewportState: ViewportState | null;
onViewportChange?: (state: ViewportState | null) => void;
activeChartId: string | null;
onSetActiveChart?: (id: string | null) => void;
showAxes?: boolean;
}

const customPriceFormatter = (price: number): string => {
if (price === 0) return '0';
if (price < 0.000001) {
return price.toFixed(12).replace(/.?0+$/, "");
}
if (price < 1) return price.toFixed(6);
return price.toFixed(2);
};

// è¾…åŠ©ï¼šè·å–æ—¶é—´å‘¨æœŸçš„ç§’æ•°
const getIntervalSeconds = (timeframe: string): number => {
const val = parseInt(timeframe);
if (timeframe.endsWith('m')) return val * 60;
if (timeframe.endsWith('h')) return val * 3600;
if (timeframe.endsWith('d')) return val * 86400;
return 60; // default 1m
};

const SingleKlineChart: Component<SingleKlineChartProps> = (props) => {
let chartContainer: HTMLDivElement;
let chart: IChartApi | null = null;
let candlestickSeries: ISeriesApi<'Candlestick'> | null = null;
let ghostSeries: ISeriesApi<'Line'> | null = null; // ğŸ‘» éšå½¢ç³»åˆ—å¼•ç”¨
let resizeObserver: ResizeObserver | null = null;
const [status, setStatus] = createSignal('Initializing...');

code
Code
download
content_copy
expand_less
// ğŸ”’ çŠ¶æ€é”
let isProgrammaticUpdate = false;
let isSyncPending = false;

const getMyId = () => props.tokenInfo?.contractAddress || '';

const cleanupChart = () => {
    if (chart) {
        chart.remove();
        chart = null;
        candlestickSeries = null;
        ghostSeries = null;
    }
};

const unsubscribeRealtime = (payload: { address: string; chain: string; interval: string }) => {
    socket.off('kline_update', handleKlineUpdate);
    socket.emit('unsubscribe_kline', payload);
};

const handleKlineUpdate = (update: KlineUpdatePayload) => {
    const info = props.tokenInfo;
    if (!info || !candlestickSeries) return;
    
    const chainToPoolId: Record<string, number> = { bsc: 14, sol: 16, solana: 16, base: 199 };
    const poolId = chainToPoolId[info.chain.toLowerCase()];
    const expectedRoom = `kl@${poolId}@${info.contractAddress}@${props.timeframe}`;

    if (update.room === expectedRoom) {
        const newCandle = update.data as CandlestickData<number>;
        
        // âœ¨âœ¨âœ¨ æ ¸å¿ƒä¿®å¤ï¼šé˜²æ­¢ "Cannot update oldest data" é”™è¯¯ âœ¨âœ¨âœ¨
        // è·å–å½“å‰ç³»åˆ—ä¸­çš„æ‰€æœ‰æ•°æ®
        const currentData = candlestickSeries.data();
        
        if (currentData.length > 0) {
            const lastCandle = currentData[currentData.length - 1] as CandlestickData<number>;
            // åªæœ‰å½“æ–°æ•°æ®çš„æ—¶é—´ >= æœ€åä¸€æ ¹Kçº¿çš„æ—¶é—´æ—¶ï¼Œæ‰å…è®¸æ›´æ–°
            // å¦‚æœæ–°æ•°æ®æ—¶é—´æ¯”æœ€åä¸€æ¡è¿˜æ—©ï¼ˆä¹±åºåˆ°è¾¾ï¼‰ï¼Œåˆ™ç›´æ¥ä¸¢å¼ƒ
            if (newCandle.time < lastCandle.time) {
                // console.warn(`[Chart] Dropped late packet. Last: ${lastCandle.time}, New: ${newCandle.time}`);
                return;
            }
        }
        
        candlestickSeries.update(newCandle);
    }
};

// ğŸ‘» ç”Ÿæˆéšå½¢æ•°æ®ï¼šä»å½“å‰æ—¶é—´ç‚¹å€’æ¨ N æ ¹ï¼Œç¡®ä¿æ—¶é—´è½´è¢«æ’‘å¼€
const generateGhostData = (timeframe: string) => {
    const intervalSec = getIntervalSeconds(timeframe);
    // å‘ä¸‹å–æ•´å¯¹é½æ—¶é—´ï¼Œç¡®ä¿æ‰€æœ‰å›¾è¡¨çš„åˆ»åº¦çº¿å‚ç›´å¯¹é½
    const now = Math.floor(Date.now() / 1000 / intervalSec) * intervalSec;
    const data = [];
    for (let i = FORCE_GHOST_CANDLE_COUNT; i >= 0; i--) {
        data.push({
            time: (now - (i * intervalSec)) as Time,
            value: 0 // ä»·æ ¼ä¸º0ï¼Œåæ­£ä¸æ˜¾ç¤º
        });
    }
    return data;
};

createEffect(() => {
    const info = props.tokenInfo;
    const timeframe = props.timeframe;

    if (!info || !timeframe) {
        cleanupChart();
        setStatus('No token selected.');
        return;
    }

    cleanupChart();
    setStatus(`Loading ${info.symbol}...`);
    
    if (!chartContainer) return;

    const logId = `[Chart:${info.symbol}]`;

    try {
        chart = createChart(chartContainer, {
            width: chartContainer.clientWidth, 
            height: chartContainer.clientHeight,
            layout: { background: { type: ColorType.Solid, color: '#ffffff' }, textColor: '#333' },
            grid: { vertLines: { color: '#f0f3fa' }, horzLines: { color: '#f0f3fa' } },
            timeScale: { 
                visible: !!props.showAxes, 
                borderColor: '#cccccc', 
                timeVisible: true, 
                secondsVisible: false,
                rightOffset: 12, 
                shiftVisibleRangeOnNewBar: true, 
                fixLeftEdge: false, 
                fixRightEdge: false,
            },
            rightPriceScale: { visible: !!props.showAxes, borderColor: '#cccccc', autoScale: true },
            leftPriceScale: { visible: false, autoScale: false }, 
            handleScroll: true, 
            handleScale: true,
        });

        // 1. æ·»åŠ  Ghost Series (éšå½¢ç³»åˆ—)
        ghostSeries = chart.addLineSeries({
            color: 'rgba(0,0,0,0)', 
            lineWidth: 1,
            priceScaleId: 'left',   
            crosshairMarkerVisible: false,
            lastValueVisible: false,
            priceLineVisible: false,
        });
        ghostSeries.setData(generateGhostData(timeframe));

        // 2. æ·»åŠ çœŸå® K çº¿ç³»åˆ—
        candlestickSeries = chart.addSeries(CandlestickSeries, {
            priceFormat: { 
                type: 'price', 
                precision: 10,
                minMove: 0.00000001, 
                formatter: customPriceFormatter 
            },
            upColor: '#28a745', downColor: '#dc3545', borderDownColor: '#dc3545',
            borderUpColor: '#28a745', wickDownColor: '#dc3545', wickUpColor: '#28a745',
            priceScaleId: 'right' 
        });

    } catch (e) {
        console.error(`${logId} âŒ Failed to create chart:`, e);
        setStatus(`Chart Error: ${e}`);
        return;
    }

    // [SENDER] å‘é€åŒæ­¥ä¿¡å·
    chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
        if (isProgrammaticUpdate) return;

        const myId = getMyId().toLowerCase();
        const activeId = props.activeChartId?.toLowerCase();

        if (myId === activeId) {
            if (!isSyncPending) {
                isSyncPending = true;
                requestAnimationFrame(() => {
                    const timeRange = chart?.timeScale().getVisibleRange();
                    if (timeRange && props.onViewportChange) {
                        const from = Number(timeRange.from);
                        const to = Number(timeRange.to);
                        props.onViewportChange({ from, to });
                    }
                    isSyncPending = false;
                });
            }
        }
    });

    const payload = { address: info.contractAddress, chain: info.chain, interval: timeframe };

    const processData = (data: any[], isInitial: boolean) => {
        try {
            const sortedData = data
                .map(d => ({ ...d, time: Number(d.time) }))
                .sort((a, b) => a.time - b.time);

            if (isInitial) {
                candlestickSeries?.setData(sortedData as CandlestickData<number>[]);
                
                if (props.viewportState) {
                     chart?.timeScale().setVisibleRange({
                        from: props.viewportState.from as Time,
                        to: props.viewportState.to as Time
                    });
                } else {
                    chart?.timeScale().scrollToRealTime();
                }
            } else {
                const currentData = (candlestickSeries?.data() as CandlestickData<number>[] || []);
                const newDataMap = new Map(currentData.map(d => [d.time, d]));
                sortedData.forEach(d => newDataMap.set(d.time as number, d as CandlestickData<number>));
                const merged = Array.from(newDataMap.values()).sort((a, b) => (a.time as number) - (b.time as number));
                candlestickSeries?.setData(merged);
            }
            setStatus(`Live: ${info.symbol} ${timeframe}`);
        } catch (e) {
            console.error(`${logId} âŒ Failed to process data:`, e);
        }
    };

    const handleInitialData = (response: any) => {
        if (response.interval !== timeframe || response.address.toLowerCase() !== info.contractAddress.toLowerCase()) return;
        if (response.data && response.data.length > 0) {
            processData(response.data, true);
        } else {
            setStatus(`Waiting for data...`);
        }
    };
    
    const handleCompletedData = (response: any) => {
        if (response.interval !== timeframe || response.address.toLowerCase() !== info.contractAddress.toLowerCase()) return;
        if (response.data && response.data.length > 0) {
            processData(response.data, false);
        }
    };
    
    const handleFetchError = (err: KlineFetchErrorPayload) => {
         const key = `${info.contractAddress.toLowerCase()}@${info.chain.toLowerCase()}@${timeframe}`;
         if(err.key === key) {
            setStatus(`Error: ${err.error}`);
         }
    };

    socket.on('historical_kline_initial', handleInitialData);
    socket.on('historical_kline_completed', handleCompletedData);
    socket.on('kline_fetch_error', handleFetchError);
    socket.on('kline_update', handleKlineUpdate);

    socket.emit('request_historical_kline', payload);
    socket.emit('subscribe_kline', payload); 

    onCleanup(() => {
        unsubscribeRealtime(payload);
        socket.off('historical_kline_initial', handleInitialData);
        socket.off('historical_kline_completed', handleCompletedData);
        socket.off('kline_fetch_error', handleFetchError);
        cleanupChart();
    });
});

// [RECEIVER] æ¥æ”¶åŒæ­¥ä¿¡å·
createEffect(() => {
    const vs = props.viewportState;
    if (!chart || !vs || !props.tokenInfo) return;

    const myId = getMyId().toLowerCase();
    const activeId = props.activeChartId?.toLowerCase();

    if (myId === activeId) return;

    isProgrammaticUpdate = true;
    try {
        chart.timeScale().setVisibleRange({
            from: vs.from as Time,
            to: vs.to as Time
        });
    } catch (e) {}
    
    setTimeout(() => { isProgrammaticUpdate = false; }, 0);
});

onMount(() => {
    resizeObserver = new ResizeObserver(entries => {
        if (chart && chartContainer) {
            const { width, height } = entries[0].contentRect;
            chart.applyOptions({ width, height });
        }
    });
    if (chartContainer) {
        resizeObserver.observe(chartContainer);
    }
});

onCleanup(() => resizeObserver?.disconnect());

return (
    <div 
        class="single-chart-wrapper"
        onMouseEnter={() => {
            if (props.tokenInfo) {
                props.onSetActiveChart?.(props.tokenInfo.contractAddress);
            }
        }}
    >
        <div class="chart-header">
            <Show when={props.tokenInfo} fallback={<span class="placeholder">{status()}</span>}>
                <img src={`${BACKEND_URL}/image-proxy?url=${encodeURIComponent(props.tokenInfo!.icon!)}`} class="icon-small" alt={props.tokenInfo!.symbol}/>
                <span class="symbol-title">{props.tokenInfo!.symbol}</span>
                <span class="chain-badge">{props.tokenInfo!.chain.toUpperCase()}</span>
                <button class="block-button" title={`å±è”½ ${props.tokenInfo!.symbol}`} onClick={() => props.onBlock?.(props.tokenInfo!.contractAddress)}>
                    ğŸš«
                </button>
            </Show>
        </div>
        <div ref={chartContainer!} class="chart-container" />
    </div>
);

};

export default SingleKlineChart;