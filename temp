`README.MD`è¿™æ˜¯é¡¹ç›®æè¿°`æˆ‘æ­£åœ¨ç«¯åˆ°ç«¯æ–¹æ¡ˆè¿›è¡Œä¿®æ”¹
`packages\shared-types\src\index.ts`å·²ç»å®šä¹‰äº†ä¸¤ä¸ªç‹¬ç«‹çš„æ¥å£ï¼Œ
packages\backend\src\types.rsï¼Œï¼Œå·²ç»å¯¹åº”äº†index.ts,
è¿™æ˜¯ä¸€ä¸ªå®Œæ•´çš„ç«¯åˆ°ç«¯å®ç°æ–¹æ¡ˆï¼Œæ¶µç›–äº†ä»é‡‡é›†ã€ä¼ è¾“ã€åç«¯å¤„ç†åˆ°å‰ç«¯å±•ç¤ºçš„æ•´ä¸ªé“¾è·¯
ç›®å‰å·²ç»å®Œæˆçˆ¬è™«ç«¯å’Œrustç«¯çš„ä¿®æ”¹ï¼Œæ¥ä¸‹æ¥ï¼Œéœ€è¦ä¿®æ”¹å‰ç«¯ï¼Œéœ€è¦æœ‰ä¸€ä¸ªæ–°çš„é¡µé¢æ¥æ˜¾ç¤ºmeme newçš„åˆ—è¡¨ï¼ŒåŒæ—¶æ£€æŸ¥å½“å‰çš„ä¿®æ”¹ï¼Œæ˜¯å¦å½±å“åˆ°äº†æ—§çš„é¡µé¢ï¼Œå› ä¸ºruståç«¯å·²ç»åŒºåˆ†äº†è½¬å‘çš„æ•°æ®ç±»å‹hostlistï¼Œè¿˜æ˜¯meme new
ä¸‹é¢çš„å‰ç«¯çš„ä¿®æ”¹åˆæ­¥æ–¹æ¡ˆï¼Œé¦–å…ˆè¯„ä»·ä¸‹è¿™ä¸ªæ–¹æ¡ˆï¼Œç„¶åç»™å‡ºç»¼åˆåçš„å®Œæ•´çš„ä¿®æ”¹æ–¹æ¡ˆï¼Œæ³¨æ„ä¸è¦çœç•¥ä»£ç ä¸­ä¸å˜çš„éƒ¨åˆ†
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”



è¿™æ˜¯ä¸€ä¸ªéå¸¸æ¸…æ™°çš„æ¶æ„é€‰æ‹©ã€‚æ—¢ç„¶ä½ é€‰æ‹©äº† æ–¹æ¡ˆ Bï¼ˆåŒºåˆ† Socket æˆ¿é—´/è®¢é˜…æ¨¡å¼ï¼‰ï¼Œæˆ‘ä»¬å°†å½»åº•é‡æ„é€šä¿¡æœºåˆ¶ï¼Œå®ç°æŒ‰éœ€è®¢é˜…ã€æµé‡éš”ç¦»ã€‚æ–¹æ¡ˆ B ä¿®æ”¹æ ¸å¿ƒç‚¹ï¼šBackend (socket_handlers.rs):æ–°å¢ subscribe_feed å’Œ unsubscribe_feed äº‹ä»¶å¤„ç†ï¼Œå…è®¸å®¢æˆ·ç«¯åŠ å…¥ç‰¹å®šæˆ¿é—´ï¼ˆroom_hotlist æˆ– room_meme_newï¼‰ã€‚ä¿®æ”¹ data-update é€»è¾‘ï¼šä¸å†æ— å·®åˆ« broadcast()ï¼Œè€Œæ˜¯æ ¹æ®æ•°æ®ç±»å‹ï¼ˆCategoryï¼‰ç²¾å‡†æ¨é€åˆ°å¯¹åº”çš„æˆ¿é—´ (to(room_name).emit(...))ã€‚Frontend (useMarketData.ts):Hook å¢åŠ å‚æ•° categoryã€‚ç»„ä»¶æŒ‚è½½æ—¶è‡ªåŠ¨å‘é€ subscribe_feedï¼Œå¸è½½æ—¶å‘é€ unsubscribe_feedã€‚ä¾ç„¶ä¿ç•™æ•°æ®çš„ update/insert/delete é€»è¾‘ï¼Œä½†ç°åœ¨æ¥æ”¶åˆ°çš„æ•°æ®æ˜¯çº¯å‡€çš„ï¼Œä¸éœ€è¦å¤æ‚çš„è·¨æºæ¸…ç†é€»è¾‘ã€‚Frontend Pages:App.tsx è®¢é˜… 'hotlist'ã€‚MemePage.tsx è®¢é˜… 'meme_new'ã€‚ä¸‹é¢æ˜¯å®Œæ•´çš„ç«¯åˆ°ç«¯ä¿®æ”¹ä»£ç ã€‚1. åç«¯ä¿®æ”¹ï¼šSocket è·¯ç”±ä¸åˆ†å‘æˆ‘ä»¬éœ€è¦ä¿®æ”¹ Rust åç«¯ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†è®¢é˜…è¯·æ±‚ï¼Œå¹¶æ ¹æ®æ•°æ®ç±»å‹è¿›è¡Œå®šå‘æ¨é€ã€‚packages/backend/src/socket_handlers.rs code Rustdownloadcontent_copyexpand_less    // packages/backend/src/socket_handlers.rs

use super::{
    binance_task,
    kline_handler,
    types::{DataPayload, KlineSubscribePayload, Room, KlineTick},
    ServerState,
};
use socketioxide::{
    extract::{Data, SocketRef},
};
use std::collections::HashSet;
use std::sync::Arc;
use tokio::sync::Mutex;
use tracing::{error, info, warn};

// âœ¨ å®šä¹‰è¿‡æ»¤é˜ˆå€¼ï¼š1000 USD (æˆäº¤é‡ * ä»·æ ¼)
const MIN_HOTLIST_AMOUNT: f64 = 1000.0;

// âœ¨ å®šä¹‰æˆ¿é—´å¸¸é‡
const ROOM_HOTLIST: &str = "room_hotlist";
const ROOM_MEME_NEW: &str = "room_meme_new";

pub async fn on_socket_connect(s: SocketRef, state: ServerState) {
    info!("ğŸ”Œ [Socket.IO] Client connected: {}", s.id);

    // æ³¨å†Œä¸šåŠ¡å¤„ç†å™¨
    register_subscribe_feed_handler(&s);   // âœ¨ æ–°å¢ï¼šè®¢é˜…æ•°æ®æµ
    register_unsubscribe_feed_handler(&s); // âœ¨ æ–°å¢ï¼šå–æ¶ˆè®¢é˜…
    
    register_data_update_handler(&s, state.clone());
    register_kline_subscribe_handler(&s, state.clone());
    register_kline_unsubscribe_handler(&s, state.clone());
    register_disconnect_handler(&s, state.clone());
    register_kline_history_handler(&s, state);
}

// =================================================================================
// âœ¨ æ–°å¢ï¼šè®¢é˜…/å–æ¶ˆè®¢é˜…å¤„ç†å™¨ (æ–¹æ¡ˆBæ ¸å¿ƒ)
// =================================================================================

fn register_subscribe_feed_handler(socket: &SocketRef) {
    socket.on(
        "subscribe_feed",
        move |s: SocketRef, Data(category): Data<String>| {
            async move {
                let room = match category.as_str() {
                    "hotlist" => ROOM_HOTLIST,
                    "meme_new" => ROOM_MEME_NEW,
                    _ => {
                        warn!("âš ï¸ [SUB FAIL] Client {} tried to subscribe to invalid feed: {}", s.id, category);
                        return;
                    }
                };
                
                info!("ğŸ”” [FEED SUB] Client {} joined feed: {}", s.id, room);
                s.join(room);
            }
        },
    );
}

fn register_unsubscribe_feed_handler(socket: &SocketRef) {
    socket.on(
        "unsubscribe_feed",
        move |s: SocketRef, Data(category): Data<String>| {
            async move {
                let room = match category.as_str() {
                    "hotlist" => ROOM_HOTLIST,
                    "meme_new" => ROOM_MEME_NEW,
                    _ => return,
                };
                
                info!("ğŸ”• [FEED UNSUB] Client {} left feed: {}", s.id, room);
                s.leave(room);
            }
        },
    );
}

// =================================================================================
// ğŸŸ¢ æ•°æ®æ›´æ–°å¤„ç†å™¨ (ä¿®æ”¹ä¸ºå®šå‘æ¨é€)
// =================================================================================

fn register_data_update_handler(socket: &SocketRef, state: ServerState) {
    socket.on(
        "data-update",
        move |s: SocketRef, payload: Data<serde_json::Value>| {
            let state = state.clone();
            async move {
                // 1. å°è¯•ååºåˆ—åŒ–
                match serde_json::from_value::<DataPayload>(payload.0) {
                    Ok(mut parsed_payload) => {
                        let mut should_broadcast = false;
                        let mut log_summary = String::new();
                        let target_room: &str; // âœ¨ ç›®æ ‡æˆ¿é—´

                        match &mut parsed_payload {
                            // ğŸŸ¢ Hotlist -> æ¨é€åˆ° ROOM_HOTLIST
                            DataPayload::Hotlist { r#type, data } => {
                                target_room = ROOM_HOTLIST;
                                let original_count = data.len();
                                
                                // è¿‡æ»¤é€»è¾‘
                                data.retain(|item| {
                                    let volume = item.volume1h.unwrap_or(0.0);
                                    let price = item.price.unwrap_or(0.0);
                                    (volume * price) >= MIN_HOTLIST_AMOUNT
                                });

                                let filtered_count = data.len();
                                should_broadcast = !data.is_empty();
                                log_summary = format!(
                                    "ğŸ”¥ [HOTLIST] Act: {:?} | Filter: {} -> {} | Room: {}", 
                                    r#type, original_count, filtered_count, target_room
                                );

                                // æ›´æ–° Symbol Map
                                for item in data.iter() {
                                    state.token_symbols.insert(item.contract_address.to_lowercase(), item.symbol.clone());
                                }
                            },

                            // ğŸ”µ MemeNew -> æ¨é€åˆ° ROOM_MEME_NEW
                            DataPayload::MemeNew { r#type, data } => {
                                target_room = ROOM_MEME_NEW;
                                
                                data.retain(|item| !item.symbol.is_empty());

                                let filtered_count = data.len();
                                should_broadcast = !data.is_empty();
                                log_summary = format!(
                                    "ğŸ¶ [MEME RUSH] Act: {:?} | Items: {} | Room: {}", 
                                    r#type, filtered_count, target_room
                                );

                                for item in data.iter() {
                                    state.token_symbols.insert(item.contract_address.to_lowercase(), item.symbol.clone());
                                }
                            },

                            DataPayload::Unknown => {
                                warn!("âš ï¸ [DATA] Received unknown category payload.");
                                return;
                            }
                        }

                        // 3. âœ¨ å®šå‘å¹¿æ’­æ•°æ® (ä¸å†ä½¿ç”¨ s.broadcast().emit)
                        // s.to(room) ä¼šå‘é€ç»™æˆ¿é—´å†…çš„æ‰€æœ‰äººï¼ˆåŒ…æ‹¬å‘é€è€…è‡ªå·±ï¼Œè™½ç„¶è¿™é‡Œå‘é€è€…æ˜¯ extractorï¼Œå®ƒä¸åœ¨æˆ¿é—´é‡Œï¼Œæ‰€ä»¥æ²¡é—®é¢˜ï¼‰
                        if should_broadcast {
                            info!("{}", log_summary);
                            if let Err(e) = s.to(target_room).emit("data-broadcast", &parsed_payload).await {
                                error!("âŒ [ROOM EMIT FAIL] Room: {}, Error: {:?}", target_room, e);
                            }
                        }
                    }
                    Err(e) => {
                        warn!("âŒ [JSON PARSE ERROR] Failed to parse data-update: {}", e);
                    }
                }
            }
        },
    );
}

// ... ä¸‹é¢æ˜¯ KLine ç›¸å…³çš„ä»£ç ï¼Œä¿æŒä¸å˜ ...

fn register_kline_history_handler(socket: &SocketRef, state: ServerState) {
    socket.on(
        "request_historical_kline",
        move |s: SocketRef, payload: Data<KlineSubscribePayload>| {
            let state = state.clone();
            async move {
                kline_handler::handle_kline_request(s, payload, state).await;
            }
        },
    );
}

fn register_kline_subscribe_handler(socket: &SocketRef, state: ServerState) {
    socket.on(
        "subscribe_kline",
        move |s: SocketRef, Data(payload): Data<KlineSubscribePayload>| {
            let state = state.clone();
            async move {
                let chain_lower = payload.chain.to_lowercase();
                let address_lowercase = payload.address.to_lowercase();
                
                let symbol = state.token_symbols
                    .get(&address_lowercase)
                    .map_or_else(
                        || format!("{}...", &payload.address[0..6]),
                        |s| s.value().clone()
                    );

                let pool_id = match chain_lower.as_str() {
                    "bsc" => 14, 
                    "sol" | "solana" => 16, 
                    "base" => 199,
                    unsupported_chain => {
                        warn!("âš ï¸ [SUBSCRIBE FAIL] Unsupported chain '{}' for {}. Ignored.", unsupported_chain, s.id);
                        return;
                    }
                };

                let room_name = format!("kl@{}@{}@{}", pool_id, payload.address, payload.interval);
                let log_display_name = format!("kl@{}@{}@{}", pool_id, &symbol, payload.interval);

                info!("ğŸ”” [SUB] Client {} -> Room: {}", s.id, log_display_name);
                s.join(room_name.clone());

                state.app_state
                    .entry(room_name.clone())
                    .or_insert_with(|| {
                        info!("âœ¨ [ROOM NEW] First subscriber for '{}'. Spawning Binance task...", log_display_name);
                        let current_kline = Arc::new(Mutex::new(None::<KlineTick>));
                        
                        let task_handle = tokio::spawn(binance_task::binance_websocket_task(
                            state.io.clone(),
                            room_name.clone(),
                            symbol.clone(), 
                            state.config.clone(),
                            current_kline.clone(),
                        ));
                        
                        Room {
                            clients: HashSet::new(),
                            task_handle,
                            symbol,
                            current_kline,
                        }
                    })
                    .value_mut()
                    .clients
                    .insert(s.id);
            }
        },
    );
}

fn register_kline_unsubscribe_handler(socket: &SocketRef, state: ServerState) {
    socket.on(
        "unsubscribe_kline",
        move |s: SocketRef, Data(payload): Data<KlineSubscribePayload>| {
            let state = state.clone();
            async move {
                let chain_lower = payload.chain.to_lowercase();
                let symbol = state.token_symbols
                    .get(&payload.address.to_lowercase())
                    .map_or_else(|| format!("{}...", &payload.address[0..6]), |s| s.value().clone());

                let pool_id = match chain_lower.as_str() {
                    "bsc" => 14, 
                    "sol" | "solana" => 16, 
                    "base" => 199,
                    _ => { return; }
                };
                let room_name = format!("kl@{}@{}@{}", pool_id, payload.address, payload.interval);
                let log_display_name = format!("kl@{}@{}@{}", pool_id, &symbol, payload.interval);

                info!("ğŸ”½ [UNSUB] Client {} leaving room: {}", s.id, log_display_name);
                s.leave(room_name.clone());

                if let Some(mut room) = state.app_state.get_mut(&room_name) {
                    room.clients.remove(&s.id);
                    if room.clients.is_empty() {
                        drop(room);
                        if let Some((_, room_to_abort)) = state.app_state.remove(&room_name) {
                            info!("ğŸ—‘ï¸ [ROOM EMPTY] Last client left '{}'. Aborting Binance task.", log_display_name);
                            room_to_abort.task_handle.abort();
                        }
                    }
                }
            }
        },
    );
}

fn register_disconnect_handler(socket: &SocketRef, state: ServerState) {
    socket.on_disconnect(move |s: SocketRef| {
        let state = state.clone();
        async move {
            let mut empty_rooms: Vec<(String, String)> = Vec::new();

            for mut entry in state.app_state.iter_mut() {
                if entry.value_mut().clients.remove(&s.id) {
                    let log_display_name = {
                        let parts: Vec<&str> = entry.key().split('@').collect();
                        if parts.len() == 4 {
                             format!("{}@{}@{}@{}", parts[0], parts[1], &entry.value().symbol, parts[3])
                        } else {
                            entry.key().to_string()
                        }
                    };
                    if entry.clients.is_empty() {
                        empty_rooms.push((entry.key().clone(), log_display_name));
                    }
                }
            }

            for (room_name, log_display_name) in empty_rooms {
                if let Some((_, room)) = state.app_state.remove(&room_name) {
                    info!("ğŸ—‘ï¸ [ROOM CLEANUP] Room '{}' is now empty. Aborting task.", log_display_name);
                    room.task_handle.abort();
                }
            }
        }
    });
}
  2. å‰ç«¯ Hook ä¿®æ”¹ï¼šæŒ‰éœ€è®¢é˜…ä¿®æ”¹ useMarketDataï¼Œä½¿å…¶å¿…é¡»ä¼ å…¥ä¸€ä¸ª categoryï¼Œå¹¶å¤„ç†è®¢é˜…é€»è¾‘ã€‚å› ä¸ºæµé‡å·²ç»éš”ç¦»ï¼Œæˆ‘ä»¬ä¸å†éœ€è¦å¤æ‚çš„é€»è¾‘å»åˆ¤æ–­æ•°æ®æ¥æºæ˜¯å¦åŒ¹é…ï¼Œåªéœ€è¦ä¸“æ³¨å¤„ç†æ•°æ®æ›´æ–°ã€‚packages/frontend/src/hooks/useMarketData.ts code TypeScriptdownloadcontent_copyexpand_less    // packages/frontend/src/hooks/useMarketData.ts
import { createSignal, onMount, onCleanup } from 'solid-js';
import { createStore, produce } from 'solid-js/store';
import { socket } from '../socket';
import type { MarketItem, DataPayload } from 'shared-types';
import { checkAndTriggerAlerts } from '../AlertManager';

const loadBlockListFromStorage = (): Set<string> => {
    try {
        const storedList = localStorage.getItem('trading-dashboard-blocklist');
        if (storedList) {
            const parsedArray = JSON.parse(storedList);
            if (Array.isArray(parsedArray)) return new Set(parsedArray);
        }
    } catch (error) { console.error('[Blocklist] Failed to load:', error); }
    return new Set();
};

// âœ¨ æ–°å¢å‚æ•° category
export const useMarketData = (targetCategory: 'hotlist' | 'meme_new') => {
    // è¿™ä¸ª Store ç°åœ¨åªä¼šå­˜å‚¨ targetCategory çš„æ•°æ®
    const [marketData, setMarketData] = createStore<MarketItem[]>([]);
    const [connectionStatus, setConnectionStatus] = createSignal('Connecting...');
    const [lastUpdate, setLastUpdate] = createSignal('N/A');
    const [blockList] = createSignal(loadBlockListFromStorage());

    const handleAlertLog = (msg: string, type: 'volume' | 'price') => {
        console.log(`[Alert System] ğŸš¨ [${type.toUpperCase()}] ${msg}`);
    };

    onMount(() => {
        console.log(`[useMarketData] ğŸ”Œ Initializing for scope: ${targetCategory}`);
        
        if (!socket.connected) {
            socket.connect();
        }

        const onConnect = () => {
            console.log(`[useMarketData] âœ… Socket Connected. Subscribing to ${targetCategory}...`);
            setConnectionStatus('Connected');
            // âœ¨ æ ¸å¿ƒï¼šå‘é€è®¢é˜…è¯·æ±‚
            socket.emit('subscribe_feed', targetCategory);
        };

        const onDisconnect = () => {
            console.warn('[useMarketData] âŒ Socket Disconnected');
            setConnectionStatus('Disconnected');
        };

        // ğŸ“¡ æ•°æ®å¤„ç†é€»è¾‘ (é€»è¾‘ç®€åŒ–ï¼Œå› ä¸ºå·²ç»æ˜¯å®šå‘æ¨é€)
        const onDataBroadcast = (payload: DataPayload) => {
            // åŒé‡ä¿é™©ï¼šè™½ç„¶åç«¯å·²ç»åˆ†æµï¼Œä½†å‰ç«¯å†æ ¡éªŒä¸€æ¬¡æ›´å®‰å…¨
            if (payload.category !== targetCategory) {
                // console.debug(`[Ignored] Received ${payload.category} but listening to ${targetCategory}`);
                return;
            }

            if (!payload.data || payload.data.length === 0) return;

            const startTime = performance.now();
            const blocked = blockList();

            // 1. æŠ¥è­¦æ£€æµ‹
            for (const newItem of payload.data) {
                if (!blocked.has(newItem.contractAddress)) {
                    const oldItem = marketData.find(d => 
                        d.contractAddress === newItem.contractAddress && d.chain === newItem.chain
                    );
                    if (oldItem) {
                        checkAndTriggerAlerts(newItem, oldItem, handleAlertLog);
                    }
                }
            }

            // 2. æ•°æ®åŒæ­¥
            setMarketData(produce(currentData => {
                const incomingIds = new Set<string>();
                let updatedCount = 0;
                let addedCount = 0;
                let removedCount = 0;

                // A. æ›´æ–°æˆ–æ’å…¥
                for (const rawItem of payload.data) {
                    // è¡¥å…¨ source å­—æ®µ (å¯é€‰ï¼Œå› ä¸ºç°åœ¨æ•´ä¸ª store éƒ½æ˜¯åŒä¸€ç±»)
                    const newItem = { ...rawItem, source: rawItem.source || targetCategory };
                    
                    const uniqueId = `${newItem.chain}-${newItem.contractAddress}`;
                    incomingIds.add(uniqueId);

                    const index = currentData.findIndex(d => 
                        d.contractAddress === newItem.contractAddress && d.chain === newItem.chain
                    );

                    if (index > -1) {
                        Object.assign(currentData[index], newItem);
                        updatedCount++;
                    } else {
                        currentData.push(newItem);
                        addedCount++;
                    }
                }

                // B. æ¸…ç† (Prune) - ç§»é™¤ä¸åœ¨æœ¬æ¬¡æ¨é€åˆ—è¡¨ä¸­çš„æ•°æ®
                // âœ¨ é€»è¾‘ç®€åŒ–ï¼šä¸å†éœ€è¦åˆ¤æ–­ sourceï¼Œå› ä¸º Store é‡Œå…¨æ˜¯å½“å‰ category çš„æ•°æ®
                for (let i = currentData.length - 1; i >= 0; i--) {
                    const item = currentData[i];
                    const uniqueId = `${item.chain}-${item.contractAddress}`;
                    
                    if (!incomingIds.has(uniqueId)) {
                        currentData.splice(i, 1);
                        removedCount++;
                    }
                }
                
                const duration = (performance.now() - startTime).toFixed(2);
                if (addedCount > 0 || removedCount > 0 || Number(duration) > 10) {
                    console.log(`[Sync:${targetCategory}] +${addedCount} ~${updatedCount} -${removedCount} (${duration}ms)`);
                }
            }));

            setLastUpdate(new Date().toLocaleTimeString());
        };

        socket.on('connect', onConnect);
        socket.on('disconnect', onDisconnect);
        socket.on('data-broadcast', onDataBroadcast);

        // å¦‚æœå·²ç»è¿æ¥ï¼ˆæ¯”å¦‚çƒ­é‡è½½æ—¶ï¼‰ï¼Œæ‰‹åŠ¨è§¦å‘ä¸€æ¬¡è®¢é˜…
        if (socket.connected) {
            onConnect();
        }

        onCleanup(() => {
            console.log(`[useMarketData] ğŸ§¹ Cleaning up scope: ${targetCategory}`);
            // âœ¨ æ ¸å¿ƒï¼šå‘é€å–æ¶ˆè®¢é˜…è¯·æ±‚
            if (socket.connected) {
                socket.emit('unsubscribe_feed', targetCategory);
            }
            socket.off('connect', onConnect);
            socket.off('disconnect', onDisconnect);
            socket.off('data-broadcast', onDataBroadcast);
        });
    });

    return {
        marketData,
        connectionStatus,
        lastUpdate
    };
};
  3. å‰ç«¯é¡µé¢ä¿®æ”¹ï¼šä¼ å…¥å‚æ•°ç°åœ¨æˆ‘ä»¬éœ€è¦åœ¨è°ƒç”¨ useMarketData æ—¶æ˜¾å¼æŒ‡å®šéœ€è¦çš„ Categoryã€‚æ—§é¡µé¢ï¼šHotlist (App.tsx)packages/frontend/src/App.tsx code Tsxdownloadcontent_copyexpand_less    // packages/frontend/src/App.tsx
import { createSignal, onMount, For, Component, JSX, createMemo } from 'solid-js';
import type { MarketItem } from 'shared-types';
import { useMarketData } from './hooks/useMarketData';

const BACKEND_URL = 'http://localhost:3001';
const CHAINS = ['BSC', 'Base', 'Solana'];

// ... (è¾…åŠ©å‡½æ•°ä¿æŒä¸å˜ï¼Œçœç•¥ä»¥èŠ‚çœç©ºé—´) ...
const formatPrice = (price: number | null | undefined) => price ? price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 6 }) : '-';
const formatPercentage = (val: any) => <span class={parseFloat(val) >= 0 ? 'positive' : 'negative'}>{parseFloat(val).toFixed(2)}%</span>;
const formatVolume = (val: any) => val ? `$${(val/1000).toFixed(0)}K` : '-';

const MarketRow: Component<{ item: MarketItem }> = (props) => {
  const { item } = props;
  const iconUrl = item.icon ? `${BACKEND_URL}/image-proxy?url=${encodeURIComponent(item.icon)}` : '';
  
  return (
    <tr onClick={() => window.open(`/token.html?address=${item.contractAddress}&chain=${item.chain}`, '_blank')} style={{ cursor: 'pointer' }}>
      <td><img src={iconUrl} class="icon" onError={(e) => e.currentTarget.style.display='none'} /></td>
      <td class="symbol-cell">{item.symbol}</td>
      <td>{item.chain}</td>
      <td>{formatPrice(item.price)}</td>
      <td>{formatPercentage(item.priceChange24h)}</td>
      <td>{formatVolume(item.volume24h)}</td>
      <td>{formatVolume(item.marketCap)}</td>
      <td class="address-cell">{item.contractAddress.substring(0, 6)}...</td>
      <td>{formatVolume(item.volume1m)}</td>
    </tr>
  );
};

const App: Component = () => {
  // âœ¨ æ ¸å¿ƒä¿®æ”¹ï¼šæ˜ç¡®è®¢é˜… 'hotlist'
  const { marketData, connectionStatus, lastUpdate } = useMarketData('hotlist');
  const [selectedChain, setSelectedChain] = createSignal<string>(CHAINS[0]);
  
  // è¿‡æ»¤å½“å‰é“¾ (ä¸éœ€è¦å†è¿‡æ»¤ source äº†ï¼Œå› ä¸º subscribe å·²ç»åšäº†éš”ç¦»)
  const hotData = createMemo(() => 
    marketData.filter(item => item.chain === selectedChain())
  );

  onMount(() => console.log("[App] Hotlist Dashboard Mounted"));

  return (
    <div class="page-wrapper">
      <header class="app-header">
        <div class="header-left">
            <h1>ğŸ”¥ Market Hotlist</h1>
            <nav class="nav-links">
                <span class="nav-btn active">ğŸ”¥ Hotlist</span>
                <a href="/meme.html" class="nav-btn">ğŸ¶ Meme New</a>
            </nav>
        </div>
        
        <div class="stats-panel">
             <div class="status-indicator">
                <span class={`dot ${connectionStatus().includes('Connected') ? 'green' : 'red'}`}></span>
                {connectionStatus()}
            </div>
            <div class="update-time">Upd: {lastUpdate()}</div>
        </div>
      </header>

      {/* é“¾é€‰æ‹©å™¨ */}
      <div class="sub-controls">
        <div class="chain-selector">
            <For each={CHAINS}>
              {(chain) => (
                <button
                  class={selectedChain() === chain ? 'active' : ''}
                  onClick={() => setSelectedChain(chain)}
                >
                  {chain}
                </button>
              )}
            </For>
        </div>
      </div>

      <div class="table-container">
        <table>
          <thead>
            <tr>
              <th width="40"></th>
              <th>Symbol</th>
              <th>Chain</th>
              <th>Price</th>
              <th>24h %</th>
              <th>24h Vol</th>
              <th>MCap</th>
              <th>Contract</th>
              <th>1m Vol</th>
            </tr>
          </thead>
          <tbody>
            <For each={hotData()} fallback={<tr><td colspan={9} class="empty-state">No hot data for {selectedChain()}</td></tr>}>
              {(item) => <MarketRow item={item} />}
            </For>
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default App;
  æ–°é¡µé¢ï¼šMeme New (MemePage.tsx)packages/frontend/src/MemePage.tsx code Tsxdownloadcontent_copyexpand_less    // packages/frontend/src/MemePage.tsx
import { Component, createMemo, For, Show } from 'solid-js';
import { useMarketData } from './hooks/useMarketData';
import type { MarketItem } from 'shared-types';

const BACKEND_URL = 'http://localhost:3001';

// ... (BondingCurveProgress ç»„ä»¶ä¿æŒä¸å˜) ...
const BondingCurveProgress: Component<{ percent: number }> = (props) => {
    const colorClass = () => {
        if (props.percent >= 90) return 'bg-success';
        if (props.percent >= 50) return 'bg-warning';
        return 'bg-primary';
    };
    return (
        <div class="progress-container" title={`Bonding Curve: ${props.percent.toFixed(2)}%`}>
            <div class="progress-bar">
                <div class={`progress-fill ${colorClass()}`} style={{ width: `${props.percent}%` }}></div>
            </div>
            <span class="progress-text">{props.percent.toFixed(1)}%</span>
        </div>
    );
};

// ... (MemeRow ç»„ä»¶ä¿æŒä¸å˜) ...
const MemeRow: Component<{ item: MarketItem }> = (props) => {
    const { item } = props;
    const iconUrl = item.icon ? `${BACKEND_URL}/image-proxy?url=${encodeURIComponent(item.icon)}` : '';
    const handleRowClick = () => { window.open(`/token.html?address=${item.contractAddress}&chain=${item.chain}`, '_blank'); };
    const formatTime = (ts: number | undefined) => ts ? new Date(ts).toLocaleTimeString('zh-CN', { hour:'2-digit', minute:'2-digit', second:'2-digit' }) : '-';

    return (
        <tr onClick={handleRowClick} class="meme-row">
            <td>
                <div class="meme-icon-wrapper">
                    <Show when={item.icon} fallback={<div class="icon-placeholder">?</div>}>
                        <img src={iconUrl} class="icon" onError={(e) => e.currentTarget.style.display='none'} />
                    </Show>
                </div>
            </td>
            <td>
                <div class="meme-name-group">
                    <span class="symbol">{item.symbol}</span>
                    <Show when={item.name}><span class="fullname">{item.name}</span></Show>
                </div>
            </td>
            <td class="time-cell">{formatTime(item.createTime)}</td>
            <td><BondingCurveProgress percent={item.progress || 0} /></td>
            <td>${item.marketCap?.toLocaleString() || '-'}</td>
            <td>{item.holders?.toLocaleString() || '-'}</td>
            <td>
                <span class={`dev-count ${item.devMigrateCount && item.devMigrateCount > 0 ? 'highlight' : ''}`}>
                    {item.devMigrateCount ?? '-'}
                </span>
            </td>
            <td class="address-cell">{item.contractAddress.substring(0, 4)}...{item.contractAddress.slice(-4)}</td>
        </tr>
    );
};

const MemePage: Component = () => {
    // âœ¨ æ ¸å¿ƒä¿®æ”¹ï¼šæ˜ç¡®è®¢é˜… 'meme_new'
    const { marketData, connectionStatus, lastUpdate } = useMarketData('meme_new');

    const memeList = createMemo(() => {
        // ä¸éœ€è¦ .filter(source === 'meme-rush') äº†ï¼Œå› ä¸ºæ•°æ®æºå·²ç»çº¯å‡€
        return marketData
            .slice() // åˆ›å»ºå‰¯æœ¬ä»¥è¿›è¡Œæ’åº
            .sort((a, b) => (b.createTime || 0) - (a.createTime || 0));
    });

    return (
        <div class="page-wrapper">
            <header class="app-header">
                <div class="header-left">
                    <h1>ğŸ¶ Meme Rush <span class="subtitle">Realtime Scanner</span></h1>
                    <nav class="nav-links">
                        <a href="/" class="nav-btn">ğŸ”¥ Hotlist</a>
                        <span class="nav-btn active">ğŸ¶ Meme New</span>
                    </nav>
                </div>
                
                <div class="stats-panel">
                    <div class="status-indicator">
                        <span class={`dot ${connectionStatus().includes('Connected') ? 'green' : 'red'}`}></span>
                        {connectionStatus()}
                    </div>
                    <div class="update-time">Upd: {lastUpdate()}</div>
                    <div class="count-badge">Total: {memeList().length}</div>
                </div>
            </header>

            <div class="table-container meme-table-container">
                <table>
                    <thead>
                        <tr>
                            <th width="50">Icon</th>
                            <th>Token</th>
                            <th>Created</th>
                            <th width="200">Bonding Curve</th>
                            <th>MCap</th>
                            <th>Holders</th>
                            <th>Dev Coins</th>
                            <th>Address</th>
                        </tr>
                    </thead>
                    <tbody>
                        <For each={memeList()} fallback={
                            <tr><td colspan={8} class="empty-state">
                                ğŸ“¡ Waiting for new meme tokens... <br/>
                                <small>(Check backend connection if this persists)</small>
                            </td></tr>
                        }>
                            {(item) => <MemeRow item={item} />}
                        </For>
                    </tbody>
                </table>
            </div>
        </div>
    );
};

export default MemePage;
  4. å…¶ä»–éœ€è¦å¾®è°ƒçš„æ–‡ä»¶ChartPageLayout.tsx å’Œ TokenPageLayout.tsx ä¹Ÿä½¿ç”¨äº† useMarketDataï¼Œå®ƒä»¬é€šå¸¸éœ€è¦æ˜¾ç¤º Hotlist æ•°æ®ï¼ˆä½œä¸ºä¾§è¾¹æ ï¼‰ï¼Œæ‰€ä»¥éœ€è¦æ›´æ–°è°ƒç”¨å‚æ•°ã€‚packages/frontend/src/ChartPageLayout.tsx (ä¿®æ”¹ä¸€è¡Œ) code Tsxdownloadcontent_copyexpand_less    // ... imports
const ChartPageLayout: Component = () => {
  // âœ¨ ä»ªè¡¨ç›˜é€šå¸¸æ˜¾ç¤º Hotlist
  const { marketData, connectionStatus, lastUpdate } = useMarketData('hotlist');
  // ... rest of the code
  packages/frontend/src/TokenPageLayout.tsx (ä¿®æ”¹ä¸€è¡Œ) code Tsxdownloadcontent_copyexpand_less    // ... imports
const TokenPageLayout: Component = () => {
  // âœ¨ è¯¦æƒ…é¡µä¾§è¾¹æ é€šå¸¸ä¹Ÿæ˜¾ç¤º Hotlist
  const { marketData, lastUpdate } = useMarketData('hotlist'); 
  // ... rest of the code
  è‡³æ­¤ï¼Œæ–¹æ¡ˆ B å·²å®Œæ•´å®ç°ã€‚å‰ç«¯é€šè¿‡ subscribe_feed ä¸»åŠ¨é€‰æ‹©æ•°æ®æºï¼Œåç«¯ç²¾å‡†æ¨é€ï¼ŒçœŸæ­£å®ç°äº†æµé‡éš”ç¦»å’Œé€»è¾‘è§£è€¦ã€‚