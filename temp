`README.MD`è¿™æ˜¯é¡¹ç›®æè¿°æˆ‘å‘ç°ä¸€ä¸ªé‡å¤§çš„bugï¼Œé‚£å°±æ˜¯ç›®å‰è®¡ç®—æˆäº¤é‡‘é¢çš„æ–¹å¼æ˜¯é”™çš„ï¼Œå› ä¸ºé»˜è®¤äº†å“ç§çš„æˆäº¤é‡æ˜¯ä»¥ç¾å…ƒè®¡ä»·çš„ï¼Œå…¶å®å¹¶ä¸æ˜¯ï¼Œç›®å‰çˆ¬è™«ç«¯ä¼šè¿”å›ä¸‰æ¡é“¾çš„çƒ­ç‚¹æ•°æ®ï¼Œbsc ä¹Ÿå°±æ˜¯bnbé“¾ï¼Œä»¥bnbè®¡ä»·ï¼Œsolé“¾ï¼Œä»¥solè®¡ä»·ï¼Œè¿˜æœ‰baseé“¾ï¼Œä»¥ethè®¡ä»·ï¼Œç›®å‰å“ç§çš„ä»·æ ¼ï¼Œæ˜¯ç›¸å¯¹äºå„è‡ªé“¾å¸è€Œè¨€çš„ï¼Œè€Œå¹¶ä¸æ˜¯usdtï¼Œæˆ‘ä»¬éœ€è¦é‡æ–°ç¼–å†™é€»è¾‘1 ruståç«¯åˆå§‹åŒ–å¯åŠ¨æ—¶ï¼Œå…ˆè®¢é˜…ä¸‰ä¸ªé“¾çš„ä¸»å¸bnbçš„åœ°å€ï¼š0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095csolçš„åœ°å€ï¼šSo11111111111111111111111111111111111111112ethçš„åœ°å€ï¼š0x4200000000000000000000000000000000000006æ³¨æ„å¯¹åº”çš„é“¾çš„id2 æ¯ä¸€ä¸ªè®¢é˜…å“ç§çš„é“¾å¸çš„ä»·æ ¼ï¼Œéƒ½éœ€è¦ä¸€ä¸ªå…¨å±€çš„å®æ—¶ä»·æ ¼å»å­˜å‚¨3 ä¹Ÿå°±æ˜¯æœ‰3ä¸ªä»·æ ¼ï¼Œbnbçš„ä»·æ ¼ï¼Œsolçš„ä»·æ ¼ï¼Œethçš„ä»·æ ¼ï¼Œæœ‰äº†è¿™ä¸‰ä¸ªåŸºäºusdtçš„ä»·æ ¼ï¼Œæ˜¯å¦å°±å¯ä»¥è®¡ç®—å‡ºä¸€ä¸ªé“¾ä¸Šçš„ä»£å¸çš„å‡†ç¡®çš„æˆäº¤é‡‘é¢äº†ï¼Ÿ4 ä¸‰ä¸ªé“¾çš„ä¸»å¸çš„ä»·æ ¼ï¼Œä¸å…‰éœ€è¦è®¡ç®—ä¸‹è½½çš„kçº¿å’Œå®æ—¶æ›´æ–°kçº¿çš„æˆäº¤é‡‘é¢ï¼Œè¿˜éœ€è¦è®¡ç®—å‡ºhotlistä¸­æ¯ä¸ªå“ç§çš„æˆäº¤é‡ï¼Œhotlistä¸­çš„æˆäº¤é‡ï¼Œåº”è¯¥æ˜¯ç›¸å¯¹äºä¸»é“¾è€Œè¨€çš„ï¼Œæ¯”å¦‚å¸å®‰äººç”Ÿçš„1åˆ†é’Ÿæˆäº¤é‡æ˜¯100ï¼Œé‚£ä¹ˆè¿™100åº”è¯¥æŒ‡çš„çš„æ˜¯100ä¸ªbnbï¼Œbnbçš„ä»·æ ¼æŒ‰å½“å‰800ç²—ç•¥è®¡ç®—ï¼Œå¸å®‰äººç”Ÿ1åˆ†é’Ÿæˆäº¤é‡‘é¢ï¼Œä»¥usdtè®¡ä»·åº”è¯¥æ˜¯100*800=8ä¸‡usdtè¿™æ˜¯`å…¶ä»–AIçš„å›å¤ä¾›ä½ å‚è€ƒç»¼åˆ`ï¼Œä½ é¦–å…ˆç‹¬ç«‹æ€è€ƒï¼Œç„¶åè¯„ä»·ä¸‹è¿™ä¸ªAIçš„æ–¹æ¡ˆï¼Œç„¶åä½ å†ç»¼åˆè¾“å‡ºæœ€ç»ˆä¿®æ”¹æ–¹æ¡ˆï¼Œæ³¨æ„ä¸è¦çœç•¥è¾“å‡ºä»£ç çš„ä»»ä½•éƒ¨åˆ†ï¼Œä¸å˜çš„éƒ¨åˆ†ä¹Ÿè¦è¾“å‡ºï¼Œæˆ‘éœ€è¦ç›´æ¥å¤åˆ¶ç²˜è´´æ›¿æ¢æœ¬åœ°æ–‡ä»¶
ä¸ºäº†ç¨³å¦¥ï¼Œæˆ‘ä»¬éœ€è¦å°†ä¿®æ”¹ï¼Œåˆ†å‰²æˆæ¯ä¸€æ­¥éƒ½å¯ä»¥è¢«æ—¥å¿—éªŒè¯çš„ä¸­é—´æ­¥éª¤ï¼Œä¸€æ­¥ä¸€æ­¥æ¥å®ç°




`README.MD`è¿™æ˜¯é¡¹ç›®æè¿°

kçº¿ä¸‹è½½å’Œè®¢é˜…klè¡Œæƒ…çš„æ—¶å€™ï¼Œè·å–çš„æ•°æ®ä¸­ï¼Œæ˜¯æˆäº¤é‡ï¼Œæˆ‘éœ€è¦ç¡®å®šï¼Œtxè¡Œæƒ…è·å–çš„æ—¶å€™ï¼Œç›®å‰æ˜¯ç”¨ä»€ä¹ˆå€¼å»æ›´æ–°åŸºå‡†kçº¿ä¸­çš„æˆäº¤é‡çš„ï¼Œæˆ‘æ„Ÿè§‰å¥½åƒæœ‰é—®é¢˜è¿™æ˜¯txçš„å…·ä½“çš„ä¸€æ¬¡çš„å€¼{"stream": "tx@16_6p6xgHyF7AeE6TZkSmFsko444wqoP15icUSqi2jfGiPN","data": {"d": {"pid": 16,"f": "HpNfyc2Saw7RKkQd8nEL4khUcuPhQ7WwY1B2qjx8jxFq","h": "381777573","tp": "buy","pa": "6XaG4RMmyBmX2djczAQVVJWRHnmmVspxMUTDf5ruUjWP","t0a": "6p6xgHyF7AeE6TZkSmFsko444wqoP15icUSqi2jfGiPN","t1a": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB","v": 1.0486795004829428,"q": 6.2636848893028585,"t0pu": 6.261371238344814,"t1pu": 0.9996306246244928,"tx": "YhYPQShv7Uh3dvczZtGYSMDUbn13syx51Av42QZVyP1nDq9HN7NwFKnQUh7Z42aJBFVZaBNNBa6SbZp6Qc6RWtt","ts": "1763820150000","qi": 1,"ma": "Fv68iTMkbzG45aqnUCD2e7g2yrqM3EXhkjpVCG1uzhLy","ba": "6p6xgHyF7AeE6TZkSmFsko444wqoP15icUSqi2jfGiPN","a0": 0.167484,"a1": 1.049067,"tii": 1,"t0s": "TRUMP","t1s": "USDT","t0ts": "999999250.411964","t1ts": "2739917389.469811","lgid": "152027","top": false,"t0top": false,"t1top": false,"ex": false,"txtp": 0,"t0pt": 1,"t1pt": 4,"iix": "3-7","tid": "76"},"t": "1763820151671","c": "quote@transaction@tx@16_6p6xgHyF7AeE6TZkSmFsko444wqoP15icUSqi2jfGiPN"}}

ä¸‹é¢æ˜¯å…¶ä»–AIçš„å›å¤ï¼Œä¾›ä½ å‚è€ƒ
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

ä½ çš„ç›´è§‰æ˜¯å®Œå…¨æ­£ç¡®çš„ã€‚ç›®å‰çš„å®ç°æ˜¯æœ‰é—®é¢˜çš„ã€‚é—®é¢˜åˆ†ææ•°æ®æºåˆ†æ (tx JSON):v: 1.048...ã€‚è¿™æ˜¯ USD æ€»ä»·å€¼ (Value / Volume in USD)ã€‚a0: 0.167...ã€‚è¿™æ˜¯ Token0 (TRUMP) çš„æ•°é‡ã€‚a1: 1.049...ã€‚è¿™æ˜¯ Token1 (USDT) çš„æ•°é‡ã€‚t0pu: 6.26...ã€‚Token0 çš„å•ä»·ã€‚å½“å‰ä»£ç  (binance_task.rs):ä½ ç›®å‰ä½¿ç”¨çš„æ˜¯ let volume = tick.v;ã€‚è¿™æ„å‘³ç€ä½ æŠŠ USD é‡‘é¢ å½“ä½œ Token æ•°é‡ ç´¯åŠ åˆ°äº† K çº¿ä¸­ã€‚å‰ç«¯é€»è¾‘å†²çª (SingleKlineChart.tsx):æˆ‘ä»¬åœ¨ä¸Šä¸€ä¸ªé—®é¢˜ä¸­ç¡®è®¤ï¼Œå‰ç«¯çš„è®¡ç®—é€»è¾‘æ˜¯ï¼šæˆäº¤é‡‘é¢ = Volume * Priceã€‚åæœï¼šå¦‚æœåç«¯ä¼ çš„æ˜¯ USD (1.048)ï¼Œå‰ç«¯å†ä¹˜ä»¥ä»·æ ¼ (6.26)ï¼Œæ˜¾ç¤ºçš„æˆäº¤é‡‘é¢å˜æˆäº† ~6.56ã€‚ç»“è®ºï¼šæ•°æ®è¢«æ”¾å¤§äº†çº¦ Price å€ã€‚ åç«¯å¿…é¡»ä¼  Base Asset Volume (Token æ•°é‡)ï¼Œä¹Ÿå°±æ˜¯ a0 æˆ– a1ã€‚ä¿®å¤æ–¹æ¡ˆæˆ‘ä»¬éœ€è¦ä¿®æ”¹ä¸¤ä¸ªæ–‡ä»¶ï¼štypes.rs: å¢åŠ è§£æ a0 and a1 å­—æ®µã€‚binance_task.rs: æ ¹æ®å½“å‰ç›‘å¬çš„åˆçº¦åœ°å€ï¼Œåˆ¤æ–­æ˜¯å– a0 è¿˜æ˜¯ a1ã€‚1. ä¿®æ”¹ packages/backend/src/types.rsæˆ‘ä»¬éœ€è¦åœ¨ç»“æ„ä½“ä¸­æ·»åŠ  a0 å’Œ a1 å­—æ®µã€‚<file path="packages/backend/src/types.rs"><![CDATA[// packages/backend/src/types.rsuse chrono::{DateTime, Utc};use serde::{Deserialize, Serialize};use socketioxide::socket::Sid;// use sqlx::FromRow; // ğŸ”´ ç§»é™¤æœªä½¿ç”¨çš„å¼•ç”¨use std::collections::HashSet;use std::sync::Arc;use tokio::sync::Mutex;use tokio::task::JoinHandle;// âœ¨ æ·»åŠ  Serialize#[derive(Debug, Deserialize, Serialize, Clone)]#[serde(rename_all = "camelCase")]pub struct MarketItem {pub contract_address: Option<String>,pub symbol: Option<String>,pub icon: Option<String>,pub chain: Option<String>,pub price: Option<f64>,pub market_cap: Option<f64>,pub chain_id: Option<String>,pub volume1m: Option<f64>,pub volume5m: Option<f64>,pub volume1h: Option<f64>,pub volume4h: Option<f64>,pub volume24h: Option<f64>,pub price_change1m: Option<f64>,pub price_change5m: Option<f64>,pub price_change1h: Option<f64>,pub price_change4h: Option<f64>,pub price_change24h: Option<f64>,}#[derive(Debug, Deserialize, Clone)]pub struct KlineSubscribePayload {pub address: String,pub chain: String,pub interval: String,}// âœ¨ 1. å®šä¹‰ä¸šåŠ¡åˆ†ç±» (Category) - æ·»åŠ  Serialize#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Hash, Clone)]pub enum DataCategory {#[serde(rename = "hotlist")]Hotlist,#[serde(rename = "new")]New,#[serde(other)]Unknown,}// âœ¨ 2. å®šä¹‰åŠ¨ä½œç±»å‹ (Action/Type) - æ·»åŠ  Serialize#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]pub enum DataAction {#[serde(rename = "snapshot")]Snapshot,#[serde(rename = "update")]Update,#[serde(other)]Unknown,}// âœ¨ 3. æ›´æ–°åçš„ Payload ç»“æ„ - æ·»åŠ  Serialize#[derive(Debug, Deserialize, Serialize)]pub struct DataPayload {pub category: DataCategory,pub r#type: DataAction,pub data: Vec<MarketItem>,}#[derive(Debug, Deserialize)]pub struct BinanceStreamWrapper<T> {pub stream: String,pub data: T,}#[derive(Debug, Deserialize)]pub struct BinanceKlineDataWrapper {#[serde(rename = "d")]pub kline_data: BinanceKlineDetail,}#[derive(Debug, Deserialize)]#[allow(non_snake_case)]pub struct BinanceKlineDetail {#[serde(rename = "u")]pub values: (String, String, String, String, String, String),}#[derive(Debug, Deserialize)]pub struct BinanceTickDataWrapper {#[serde(rename = "d")]pub tick_data: BinanceTickDetail,}#[derive(Debug, Deserialize)]#[allow(non_snake_case)]pub struct BinanceTickDetail {pub t0a: String,pub t1a: String,pub t0pu: f64,pub t1pu: f64,pub v: f64,// âœ¨ æ–°å¢è§£æå­—æ®µï¼ša0 (Token0 Amount) å’Œ a1 (Token1 Amount)pub a0: f64,pub a1: f64,pub tp: String,}#[derive(Debug, Serialize, Clone)]pub struct KlineBroadcastData {pub room: String,pub data: KlineTick,}#[derive(Debug, Serialize, Clone, Default, PartialEq)]#[serde(rename_all = "camelCase")]pub struct KlineTick {#[serde(with = "chrono::serde::ts_seconds")]pub time: DateTime<Utc>,pub open: f64,pub high: f64,pub low: f64,pub close: f64,pub volume: f64,}#[derive(Debug, Serialize, Clone)]#[serde(rename_all = "camelCase")]pub struct KlineHistoryResponse {pub address: String,pub chain: String,pub interval: String,pub data: Vec<KlineTick>,}pub struct Room {pub clients: HashSet<Sid>,pub task_handle: JoinHandle<()>,pub symbol: String,pub current_kline: Arc<Mutex<Option<KlineTick>>>,}#[derive(Debug, Deserialize)]pub struct ImageProxyQuery {pub url: String,}#[derive(Serialize, Deserialize)]pub struct CacheMeta {pub content_type: String,}#[derive(Debug, Deserialize)]pub struct HistoricalDataWrapper {pub data: Vec<Vec<serde_json::Value>>,}]]></file>2. ä¿®æ”¹ packages/backend/src/binance_task.rsæˆ‘ä»¬éœ€è¦ä¿®æ”¹ handle_message ä¸­çš„ tx å¤„ç†é€»è¾‘ï¼Œæ ¹æ®åœ°å€åŒ¹é…å–å‡ºæ­£ç¡®çš„ volumeï¼ˆæ•°é‡ï¼‰ï¼Œè€Œä¸æ˜¯ vï¼ˆç¾å…ƒä»·å€¼ï¼‰ã€‚<file path="packages/backend/src/binance_task.rs"><![CDATA[// packages/backend/src/binance_task.rsuse super::{config::Config,types::{BinanceKlineDataWrapper, BinanceStreamWrapper, BinanceTickDataWrapper, KlineBroadcastData,KlineTick,},};use anyhow::{anyhow, Context, Result};use chrono::{DateTime, Utc};use futures_util::{stream::SplitSink, SinkExt, StreamExt};use socketioxide::SocketIo;use std::{sync::Arc, time::SystemTime};use tokio::{io::{AsyncReadExt, AsyncWriteExt},net::TcpStream,sync::Mutex,time::interval,};use tokio_native_tls::TlsConnector as TokioTlsConnector;use tokio_tungstenite::{client_async_with_config,tungstenite::{client::IntoClientRequest, Message},WebSocketStream,};use tracing::{error, info, warn};use url::Url;type WsStream = WebSocketStream<tokio_native_tls::TlsStream<TcpStream>>;type WsWrite = SplitSink<WsStream, Message>;type WsRead = futures_util::stream::SplitStream<WsStream>;const LOW_VOLUME_PRICE_DEVIATION_THRESHOLD: f64 = 2.0;const LOW_VOLUME_THRESHOLD: f64 = 10.0;pub async fn binance_websocket_task(io: SocketIo,room_name: String,symbol: String,config: Arc<Config>,// âœ¨ æ¥æ”¶å…±äº«çš„çŠ¶æ€current_kline: Arc<Mutex<Option<KlineTick>>>,) {let log_display_name = {let parts: Vec<&str> = room_name.split('@').collect();if parts.len() == 4 {format!("{}@{}@{}@{}", parts[0], parts[1], &symbol, parts[3])} else {room_name.clone()}}; code Codedownloadcontent_copyexpand_less    let address = match room_name.split('@').nth(2) {
    Some(addr) => addr.to_lowercase(),
    None => {
        error!(
            "âŒ [TASK INIT FAILED] Invalid room name format: {}. Cannot extract address. Aborting task.",
            log_display_name
        );
        return;
    }
};
let address = Arc::new(address);

loop {
    match connect_and_run(&io, &room_name, &log_display_name, address.clone(), &config, current_kline.clone()).await {
        Ok(_) => warn!(
            "ğŸ” [TASK {}] Disconnected gracefully. Reconnecting...",
            log_display_name
        ),
        Err(e) => error!(
            "ğŸ” [TASK {}] Connection failed: {:#?}. Retrying in 3s...",
            log_display_name, e
        ),
    }
    tokio::time::sleep(std::time::Duration::from_secs(3)).await;
}
  }async fn connect_and_run(io: &SocketIo,room_name: &str,log_display_name: &str,address: Arc<String>,config: &Config,current_kline: Arc<Mutex<Option<KlineTick>>>,) -> Result<()> {let stream = establish_http_tunnel(log_display_name, config).await?;let host = Url::parse(&config.binance_wss_url)?.host_str().unwrap_or_default().to_string();let tls_stream = wrap_stream_with_tls(stream, &host).await?; code Codedownloadcontent_copyexpand_less    let mut request = config.binance_wss_url.as_str().into_client_request()?;
let headers = request.headers_mut();

headers.insert("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36".parse()?);
headers.insert("Origin", "https://web3.binance.com".parse()?);
headers.insert("Accept-Encoding", "gzip, deflate, br, zstd".parse()?);
headers.insert("Accept-Language", "zh-CN,zh;q=0.9,en;q=0.8".parse()?);
headers.insert("Pragma", "no-cache".parse()?);
headers.insert("Cache-Control", "no-cache".parse()?);

let (ws_stream, response) = client_async_with_config(request, tls_stream, None)
    .await
    .context("WebSocket handshake failed")?;
info!(
    "âœ… [TASK {}] WebSocket handshake successful. Status: {}",
    log_display_name,
    response.status()
);

let (mut write, mut read) = ws_stream.split();
subscribe_all(&mut write, room_name, log_display_name).await?;

message_loop(
    io,
    room_name,
    log_display_name,
    config,
    &mut write,
    &mut read,
    current_kline, 
    address,
)
.await
  }async fn subscribe_all(write: &mut WsWrite,kline_room_name: &str,log_display_name: &str,) -> Result<()> {let parts: Vec<&str> = kline_room_name.split('@').collect();if parts.len() != 4 {return Err(anyhow!("Invalid kline room name format: {}",kline_room_name));}let pool_id = parts[1];let address = parts[2]; code Codedownloadcontent_copyexpand_less    let tick_param = format!("tx@{}_{}", pool_id, address);
let tick_request_id = SystemTime::now()
    .duration_since(SystemTime::UNIX_EPOCH)?
    .as_millis();
let tick_subscribe_msg = serde_json::json!({
    "id": tick_request_id,
    "method": "SUBSCRIBE",
    "params": [tick_param]
});
info!(
    "ğŸ“¤ [SEND SUB {}] Tick Stream Payload: {}",
    log_display_name, tick_subscribe_msg
);
write
    .send(Message::Text(tick_subscribe_msg.to_string().into()))
    .await?;

tokio::time::sleep(std::time::Duration::from_millis(100)).await;

let kline_request_id =
    SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)?.as_millis() + 1;
let kline_subscribe_msg = serde_json::json!({
    "id": kline_request_id,
    "method": "SUBSCRIBE",
    "params": [kline_room_name]
});
info!(
    "ğŸ“¤ [SEND SUB {}] Kline Stream Payload: {}",
    log_display_name, kline_subscribe_msg
);
write
    .send(Message::Text(kline_subscribe_msg.to_string().into()))
    .await?;

Ok(())
  }async fn message_loop(io: &SocketIo,room_name: &str,log_display_name: &str,config: &Config,write: &mut WsWrite,read: &mut WsRead,current_kline: Arc<Mutex<Option<KlineTick>>>,address: Arc<String>,) -> Result<()> {let mut heartbeat = interval(config.heartbeat_interval);loop {tokio::select! {_ = heartbeat.tick() => {// info!("[HEARTBEAT {}] Sending Ping...", log_display_name);write.send(Message::Ping(vec![].into())).await.context("Failed to send heartbeat Ping")?;}msg_result = read.next() => {match msg_result {Some(Ok(msg)) => {let should_continue = handle_message(msg, io, room_name, log_display_name, write, current_kline.clone(), &address).await?;if !should_continue {break;}},Some(Err(e)) => return Err(e.into()),None => break,}}}}warn!("[TASK {}] Message loop exited.", log_display_name);Ok(())}async fn handle_message(msg: Message,io: &SocketIo,room_name: &str,log_display_name: &str,write: &mut WsWrite,current_kline: Arc<Mutex<Option<KlineTick>>>,tracked_address: &str,) -> Result<bool> {match msg {Message::Text(text) if !text.is_empty() => {if text.contains(""stream":"kl@") {match serde_json::from_str::<BinanceStreamWrapper<BinanceKlineDataWrapper>>(&text) {Ok(wrapper) => {let values = &wrapper.data.kline_data.values;let timestamp_seconds = values.5.parse::<i64>().unwrap_or_default() / 1000;let new_kline = KlineTick {time: DateTime::from_timestamp(timestamp_seconds, 0).unwrap_or_default().with_timezone(&Utc),open: values.0.parse().unwrap_or_default(),high: values.1.parse().unwrap_or_default(),low: values.2.parse().unwrap_or_default(),close: values.3.parse().unwrap_or_default(),volume: values.4.parse().unwrap_or_default(),}; code Codedownloadcontent_copyexpand_less    // âœ¨ Step 6: è¿™é‡Œå°±æ˜¯ WebSocket K çº¿æ•°æ®åˆ°è¾¾çš„åœ°æ–¹
                    // å®ƒä¼šæ›´æ–°/æ›¿æ¢æ‰æˆ‘ä»¬é€šè¿‡ HTTP æ³¨å…¥çš„é‚£ä¸€æ ¹
                    //info!("ğŸŒŠ [WS KLINE {}] Incoming Update. Time: {}, Close: {}", log_display_name, new_kline.time, new_kline.close);
                    
                    broadcast_update(io, room_name, new_kline.clone()).await;
                    *current_kline.lock().await = Some(new_kline);
                },
                Err(e) => {
                    error!("âŒ [KLINE PARSE ERROR {}] Error: {}. Raw: {}", log_display_name, e, text);
                }
            }
        } else if text.contains("\"stream\":\"tx@") {
            match serde_json::from_str::<BinanceStreamWrapper<BinanceTickDataWrapper>>(&text) {
                Ok(wrapper) => {
                    let tick = &wrapper.data.tick_data;

                    // âœ¨ é€»è¾‘ä¿®æ”¹ï¼šåŒæ—¶ç¡®å®š ä»·æ ¼(price) å’Œ åŸºç¡€æˆäº¤é‡(volume)
                    // ä¹‹å‰åªç”¨äº† tick.v (è¿™æ˜¯ USD é‡‘é¢)ï¼Œå‰ç«¯åˆä¹˜äº†ä»·æ ¼ï¼Œå¯¼è‡´æ•°å€¼çˆ†ç‚¸
                    let (price, volume) = if tick.t0a.eq_ignore_ascii_case(tracked_address) {
                        // tracked_address æ˜¯ Token0
                        (tick.t0pu, tick.a0)
                    } else if tick.t1a.eq_ignore_ascii_case(tracked_address) {
                        // tracked_address æ˜¯ Token1
                        (tick.t1pu, tick.a1)
                    } else {
                        // å½“å‰ç›‘æ§çš„åœ°å€æ—¢ä¸æ˜¯ t0 ä¹Ÿä¸æ˜¯ t1ï¼Œé€šå¸¸ä¸ä¼šå‘ç”Ÿï¼Œé™¤éè®¢é˜…é”™äº†
                        return Ok(true);
                    };
                    
                    // let usd_volume = tick.v; // ä¾›å‚è€ƒï¼šè¿™æ‰æ˜¯ tick.v çš„çœŸå®å«ä¹‰
                    
                    let mut kline_guard = current_kline.lock().await;
                    if let Some(kline) = kline_guard.as_mut() {
                        let last_price = kline.close;

                        if last_price > 0.0 {
                            let price_ratio = if price > last_price { price / last_price } else { last_price / price };
                            // è¿™é‡Œä½¿ç”¨ tick.v (USD Volume) æ¥åšè¿‡æ»¤é˜ˆå€¼æ˜¯åˆç†çš„ï¼Œå› ä¸º 10.0 é€šå¸¸æŒ‡ $10
                            if price_ratio > LOW_VOLUME_PRICE_DEVIATION_THRESHOLD && tick.v < LOW_VOLUME_THRESHOLD {
                                warn!(
                                    "ğŸš« [REJECT SPIKE {}] Price jump {:.2}x with low vol ${:.4}. Last: {}, New: {}",
                                    log_display_name, price_ratio, tick.v, last_price, price
                                );
                                return Ok(true);
                            }
                        }

                        kline.high = kline.high.max(price);
                        kline.low = kline.low.min(price);
                        kline.close = price;
                        
                        // âœ¨ ä¿®æ­£ï¼šç´¯åŠ çš„æ˜¯ Token æ•°é‡ï¼Œè€Œä¸æ˜¯ USD é‡‘é¢
                        kline.volume += volume;
                        
                        // info!("âš¡ [WS TICK {}] P: {}, Vol+: {} (RawV: {})", log_display_name, price, volume, tick.v);
                        
                        broadcast_update(io, room_name, kline.clone()).await;
                    }
                },
                Err(_e) => { // âœ¨ ä¿®å¤ï¼šæœªä½¿ç”¨å˜é‡ e -> _e
                    // error!("âŒ [TICK PARSE ERROR {}] Error: {}. Raw: {}", log_display_name, e, text);
                }
            }
        } else if text.contains("result") {
            info!(
                "âœ… [CONFIRM {}] Subscription active. Server said: {}",
                log_display_name, text
            );
        } else {
            // warn!("â“ [UNHANDLED MSG {}] {}", log_display_name, text);
        }
    }
    Message::Ping(ping_data) => {
        write
            .send(Message::Pong(ping_data))
            .await
            .context("Failed to send Pong")?;
    }
    Message::Close(close_frame) => {
        warn!(
            "ğŸ›‘ [TASK {}] Received Close frame: {:?}",
            log_display_name, close_frame
        );
        return Ok(false);
    }
    _ => {}
}
Ok(true)
  }async fn broadcast_update(io: &SocketIo, room_name: &str, kline: KlineTick) {let broadcast_data = KlineBroadcastData {room: room_name.to_string(),data: kline,};if let Err(e) = io.to(room_name.to_string()).emit("kline_update", &broadcast_data).await{error!("âŒ [BROADCAST FAIL {}] {:?}",room_name, e);}}async fn establish_http_tunnel(log_display_name: &str, config: &Config) -> Result<TcpStream> {let url_obj = Url::parse(&config.binance_wss_url)?;let host = url_obj.host_str().unwrap_or_default();let port = url_obj.port_or_known_default().unwrap_or(443);let target_addr = format!("{}:{}", host, port); code Codedownloadcontent_copyexpand_less    // info!("connecting to proxy...");
let mut stream = TcpStream::connect(&config.proxy_addr)
    .await
    .context("HTTP proxy connection failed")?;
let connect_req = format!(
    "CONNECT {} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n",
    target_addr, target_addr
);
stream
    .write_all(connect_req.as_bytes())
    .await
    .context("Failed to send CONNECT request")?;

let mut buf = vec![0; 1024];
let n = stream
    .read(&mut buf)
    .await
    .context("Failed to read proxy response")?;

let response = String::from_utf8_lossy(&buf[..n]);

if !response.starts_with("HTTP/1.1 200") {
    return Err(anyhow!(
        "âŒ [TASK {}] Proxy CONNECT failed: {}",
        log_display_name,
        response.trim()
    ));
}
Ok(stream)
  }async fn wrap_stream_with_tls(stream: TcpStream,host: &str,) -> Result<tokio_native_tls::TlsStream<TcpStream>> {let tls_connector = native_tls::TlsConnector::builder().build()?;let tokio_tls_connector = TokioTlsConnector::from(tls_connector);tokio_tls_connector.connect(host, stream).await.context("TLS Handshake failed")}]]></file>