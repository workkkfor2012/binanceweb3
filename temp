src/tx_server/旧的__lib/图表/binanceHTTP.ts


// src/tx_server/旧的__lib/图表/binanceHTTP.ts
import { httpRequest } from "../http_ws/httpRequest"
import { queryString } from "../通用/queryString"
import { sha256 } from "../通用/sha256"
import { toType } from "../通用/toType"
import { APP参数 } from "../../../______________config/APP参数"
import { BinanceOrderStatus, BinanceOrderType } from "./binanceType"
import { apiConfigManager } from "../../../______________config/apiConfigManager"

const __ = <REQ, RES, A, B>(p: {
isPublic: boolean
method: 'GET' | 'POST' | 'PUT' | 'DELETE'
path: string
mapReqFunc: (v: A) => REQ
mapResFunc: (v: RES) => B
forceDirect?: boolean // 【新增】是否强制使用直连配置
}) => async (a: A) => {
// --- 修改点：根据 forceDirect 决定使用哪种配置 ---
// 如果 forceDirect 为 true，强制使用 Mokex 直连配置；否则跟随系统当前策略（可能是直连也可能是代理）
const apiConfig = p.forceDirect ? apiConfigManager.getDirectConfig() : apiConfigManager.getCurrentConfig();

code
Code
download
content_copy
expand_less
const req = p.mapReqFunc(a)

let query = ''
if (p.isPublic) {
    const queryObject = req as any;
    if (Object.keys(queryObject).length > 0) {
        query = queryString.stringify(req)
    }
} else {
    const aaa = queryString.stringify({
        ...p.mapReqFunc(a),
        timestamp: Date.now() - 1000 * 60,
        recvWindow: 1000 * 60 * 5,
    })

    const bbb = queryString.stringify({
        signature: sha256({ key: APP参数.binanceSecretKey, text: aaa }),
    })

    query = aaa + '&' + bbb
}

const fdtype = 'fapi'
const version = ['account'].includes(p.path) ? 'v2' : 'v1'

const url = `${apiConfig.restApiBase}/${fdtype}/${version}/${p.path}${query ? `?${query}` : ''}`

// 合并 Custom Headers (Mokex 需要这个)
let finalHeaders: { [key: string]: string } = { ...apiConfig.customHeaders };

if (!p.isPublic) {
    finalHeaders['X-MBX-APIKEY'] = APP参数.binanceAPIKey;
}

const res = await httpRequest<RES>({
    method: p.method,
    url,
    headers: finalHeaders,
})

return res !== undefined ? p.mapResFunc(res) : undefined

}

export const binanceHTTP = {
exchangeInfo: __({
isPublic: true,
method: 'GET',
path: 'exchangeInfo',
forceDirect: true, // 【修改】强制走直连 (Mokex) 以获取品种列表
mapReqFunc: (v: {}) => v,
mapResFunc: v => {
let tickDic = Object.create(null) as {
[symbol: string]: {
tickSize: number
stepSize: number
onboardDate: number
status: string
}
}
if (v && (v as any).symbols) {
toType({
symbols: [{
symbol: '',
onboardDate: 1,
status: '',
filters: [{
tickSize: 0.01, //index 0
stepSize: 1, //index 1
}],
}]
})(v).symbols.forEach(v => {

code
Code
download
content_copy
expand_less
tickDic[v.symbol] = {
                    onboardDate: v.onboardDate,
                    status: v.status,
                    tickSize: v.filters[0].tickSize,//index 0 
                    stepSize: v.filters[1].stepSize,//index 1
                }
            })
        }
        return tickDic
    },
}),
newOrder: __({
    isPublic: false,
    method: 'POST',
    path: 'order',
    mapReqFunc: (v: {
        symbol: string
        isBuy: boolean
        平仓: boolean
        price: number | 'market'
        size: number
    }) => {
        const is多 = v.平仓 ? (!v.isBuy) : v.isBuy
        const obj = {
            symbol: v.symbol,
            side: v.isBuy ? 'BUY' : 'SELL',
            positionSide: is多 ? 'LONG' : 'SHORT',
            quantity: v.size,
        }

        return (v.price === 'market' ? {
            ...obj,
            type: 'MARKET',
        } : {
            ...obj,
            type: 'LIMIT',
            price: v.price,
            timeInForce: 'GTC',
        })
    },
    mapResFunc: () => ({}),
}),
cancelOrder: __({
    isPublic: false,
    method: 'DELETE',
    path: 'order',
    mapReqFunc: (v: {
        symbol: string
        orderID: string
    }) => ({
        symbol: v.symbol,
        orderId: v.orderID,
    }),
    mapResFunc: () => ({}),
}),
stopOrder: __({
    isPublic: false,
    method: 'POST',
    path: 'order',
    mapReqFunc: (v: {
        symbol: string
        isBuy: boolean
        price: number
        size?: number
    }) => ({
        symbol: v.symbol,
        side: v.isBuy ? 'BUY' : 'SELL',
        positionSide: v.isBuy ? 'SHORT' : 'LONG',
        type: 'STOP_MARKET',
        stopPrice: v.price,
        quantity: v.size,
        closePosition: v.size === undefined ? true : undefined,
    }),
    mapResFunc: () => ({}),
}),
突破: __({
    isPublic: false,
    method: 'POST',
    path: 'order',
    mapReqFunc: (v: {
        symbol: string
        isBuy: boolean
        price: number
        size: number
    }) => ({
        symbol: v.symbol,
        side: v.isBuy ? 'BUY' : 'SELL',
        positionSide: v.isBuy ? 'LONG' : 'SHORT',
        type: 'STOP_MARKET',
        stopPrice: v.price,
        quantity: v.size,
        timeInForce: 'GTC',
    }),
    mapResFunc: () => ({}),
}),
listenKey: __({
    isPublic: false,
    method: 'POST',
    path: 'listenKey',
    mapReqFunc: (v: {}) => v,
    mapResFunc: v => toType({ listenKey: '' })(v),
}),
put_listenKey: __({
    isPublic: false,
    method: 'PUT',
    path: 'listenKey',
    mapReqFunc: (v: {}) => v,
    mapResFunc: () => ({}),
}),
orderList: __({
    isPublic: false,
    method: 'GET',
    path: 'openOrders',
    mapReqFunc: (v: {}) => v,
    mapResFunc: v => {
        const arr = v ? toType([
            {
                "avgPrice": "0.00000",
                "clientOrderId": "abc",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": false,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "9300",
                "closePosition": false,
                "symbol": "BTCUSDT",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1579276756075,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": false
            }
        ])(v) : [];


        let orderDic = Object.create(null) as {
            [symbol: string]: {
                多仓: { [orderID: string]: BinanceOrderType }
                空仓: { [orderID: string]: BinanceOrderType }
            }
        }

        arr.forEach(v => {
            if (orderDic[v.symbol] === undefined) {
                orderDic[v.symbol] = {
                    多仓: {},
                    空仓: {},
                }
            }

            if (v.positionSide !== 'BOTH') {
                const _dic = v.positionSide === 'LONG' ? orderDic[v.symbol].多仓 : orderDic[v.symbol].空仓
                if (v.type === 'STOP_MARKET') {
                    if (v.reduceOnly) {
                        _dic[String(v.orderId)] = {
                            type: 'STOP_MARKET',
                            price: Number(v.stopPrice),
                            status: v.status as BinanceOrderStatus,
                        }
                    } else {
                        _dic[String(v.orderId)] = {
                            type: '突破',
                            price: Number(v.stopPrice),
                            size: Number(v.origQty),
                            status: v.status as BinanceOrderStatus,
                        }
                    }
                } else if (v.type === 'LIMIT') {
                    _dic[String(v.orderId)] = {
                        type: 'LIMIT',
                        is平仓: v.reduceOnly,
                        price: Number(v.price),
                        已成交: Number(v.executedQty),
                        size: Number(v.origQty),
                        status: v.status as BinanceOrderStatus,
                    }
                }
            }
        })

        return orderDic
    },
}),
余额和仓位: __({
    isPublic: false,
    method: 'GET',
    path: 'account',
    mapReqFunc: (v: {}) => v,
    mapResFunc: v => {
        const obj = v ? toType({
            "feeTier": 0,
            "canTrade": true,
            "canDeposit": true,
            "canWithdraw": true,
            "updateTime": 0,
            "totalInitialMargin": "0.00000000",
            "totalMaintMargin": "0.00000000",
            "totalWalletBalance": "23.72469206",
            "totalUnrealizedProfit": "0.00000000",
            "totalMarginBalance": "23.72469206",
            "totalPositionInitialMargin": "0.00000000",
            "totalOpenOrderInitialMargin": "0.00000000",
            "totalCrossWalletBalance": "23.72469206",
            "totalCrossUnPnl": "0.00000000",
            "availableBalance": "23.72469206",
            "maxWithdrawAmount": "23.72469206",
            "assets": [
                {
                    "asset": "USDT",
                    "walletBalance": "23.72469206",
                    "unrealizedProfit": "0.00000000",
                    "marginBalance": "23.72469206",
                    "maintMargin": "0.00000000",
                    "initialMargin": "0.00000000",
                    "positionInitialMargin": "0.00000000",
                    "openOrderInitialMargin": "0.00000000",
                    "crossWalletBalance": "23.72469206",
                    "crossUnPnl": "0.00000000",
                    "availableBalance": "23.72469206",
                    "maxWithdrawAmount": "23.72469206"
                }
            ],
            "positions": [
                {
                    "symbol": "BTCUSDT",
                    "initialMargin": "0",
                    "maintMargin": "0",
                    "unrealizedProfit": "0.00000000",
                    "positionInitialMargin": "0",
                    "openOrderInitialMargin": "0",
                    "leverage": "100",
                    "isolated": true,
                    "entryPrice": "0.00000",
                    "maxNotional": "250000",
                    "positionSide": "BOTH",
                    "positionAmt": "0"
                }
            ]
        })(v) : null;

        if (!obj) {
            return { USDT: 0, positionDic: {} };
        }

        let positionDic = Object.create(null) as {
            [symbol: string]: {
                多仓: { price: number; size: number; };
                空仓: { price: number; size: number; };
            }
        };

        obj.positions.forEach(v => {
            if (positionDic[v.symbol] === undefined) {
                positionDic[v.symbol] = {
                    多仓: { price: 0, size: 0 },
                    空仓: { price: 0, size: 0 },
                }
            }

            if (v.positionSide === 'LONG') {
                positionDic[v.symbol].多仓 = {
                    price: Number(v.entryPrice),
                    size: Math.abs(Number(v.positionAmt)),
                }
            }
            else if (v.positionSide === 'SHORT') {
                positionDic[v.symbol].空仓 = {
                    price: Number(v.entryPrice),
                    size: Math.abs(Number(v.positionAmt)),
                }
            }
        })

        return {
            USDT: Number(obj.totalCrossWalletBalance),
            positionDic,
        }
    },
}),

}