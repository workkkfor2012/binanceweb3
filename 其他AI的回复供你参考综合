ä½ çš„è§‚å¯Ÿéå¸¸å‡†ç¡®ï¼Œç›®å‰çš„ â€œæ‹–åŠ¨äº§ç”Ÿç¼©æ”¾/æŒ¤å‹â€ ç°è±¡ï¼Œæ­£æ˜¯å› ä¸ºä½¿ç”¨äº† æ—¶é—´ï¼ˆTime Rangeï¼‰åŒæ­¥ è€Œé é€»è¾‘ä½ç½®ï¼ˆLogical Indexï¼‰åŒæ­¥ å¯¼è‡´çš„ã€‚

æ ¸å¿ƒé—®é¢˜åˆ†æ

æ—¶é—´åŒæ­¥çš„ç¼ºé™·ï¼š

å½“ä½ å‘å·¦æ‹–åŠ¨å›¾è¡¨Aï¼ˆæŸ¥çœ‹å³ä¾§æœªæ¥ç©ºç™½åŒºåŸŸï¼‰æ—¶ï¼Œä½ å®é™…ä¸Šæ˜¯åœ¨è¦æ±‚å›¾è¡¨æ˜¾ç¤ºä¸€æ®µâ€œæœªæ¥çš„æ—¶é—´èŒƒå›´â€ã€‚

å½“ä½ æŠŠè¿™ä¸ªæ—¶é—´èŒƒå›´ä¼ ç»™å›¾è¡¨Bæ—¶ï¼Œå¦‚æœå›¾è¡¨Bçš„æ•°æ®æ²¡æœ‰é‚£ä¹ˆæ–°ï¼Œæˆ–è€…å®ƒçš„å†…éƒ¨æœºåˆ¶åˆ¤æ–­â€œå³ä¾§æ²¡æœ‰æ•°æ®â€ï¼Œå®ƒä¼šå°è¯•æŠŠè¿™ä¸ªæ—¶é—´èŒƒå›´å‹ç¼©åœ¨å®ƒè®¤ä¸ºåˆç†çš„æ˜¾ç¤ºåŒºåŸŸå†…ï¼Œæˆ–è€…å¼ºåˆ¶è´´é åœ¨å®ƒæ‹¥æœ‰çš„æœ€åä¸€æ ¹Kçº¿ä¸Šã€‚

ç»“æœï¼šå›¾è¡¨Bä¸ºäº†æ˜¾ç¤ºä½ è¦æ±‚çš„æ—¶é—´æ®µï¼Œè¢«è¿«æ”¹å˜äº†æ¯æ ¹Kçº¿çš„å®½åº¦ï¼ˆBar Spacingï¼‰ï¼Œå¯¼è‡´è§†è§‰ä¸Šçœ‹èµ·æ¥åƒæ˜¯è¢«â€œæ”¾å¤§â€æˆ–â€œæŒ¤å‹â€äº†ï¼Œè€Œä¸æ˜¯å•çº¯çš„å¹³ç§»ã€‚

ä¸ºä»€ä¹ˆéœ€è¦ Logical Indexï¼ˆé€»è¾‘ç´¢å¼•ï¼‰ï¼š

lightweight-charts å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªé€»è¾‘ç´¢å¼•ï¼š0 ä»£è¡¨æœ€æ–°çš„ä¸€æ ¹Kçº¿ï¼Œæ­£æ•°ä»£è¡¨å†å²ï¼Œè´Ÿæ•°ä»£è¡¨å³ä¾§çš„æœªæ¥ç©ºç™½åŒºåŸŸã€‚

æ¯”å¦‚ï¼šfrom: -10, to: 50 æ„å‘³ç€å±å¹•å³è¾¹ç¼˜è¿˜æœ‰10æ ¹Kçº¿çš„ç©ºç™½ç©ºé—´ï¼Œå·¦ä¾§æ˜¾ç¤ºåˆ°ç¬¬50æ ¹Kçº¿ã€‚

åŒæ­¥é€»è¾‘ç´¢å¼•ï¼šå¦‚æœæˆ‘ä»¬å¼ºåˆ¶æ‰€æœ‰å›¾è¡¨éƒ½æ˜¾ç¤º [-10, 50] è¿™ä¸ªç´¢å¼•èŒƒå›´ï¼Œæ— è®ºå®ƒä»¬çš„æ—¶é—´æˆ³æ˜¯ä»€ä¹ˆï¼Œå®ƒä»¬éƒ½ä¼šä¸¥æ ¼ä¿æŒç›¸åŒçš„ç¼©æ”¾æ¯”ä¾‹å’Œç›¸åŒçš„å³ä¾§ç•™ç™½è·ç¦»ã€‚

Ghost Series çš„ä½œç”¨ï¼š

ä½ å·²ç»å®ç°äº† Ghost Seriesï¼Œè¿™éå¸¸å¥½ã€‚å®ƒçš„ä½œç”¨æ˜¯ç»Ÿä¸€åæ ‡ç³»ã€‚å®ƒä¿è¯äº†æ‰€æœ‰å›¾è¡¨å¯¹äºâ€œIndex 0â€å¯¹åº”çš„æ—¶é—´æˆ³æ˜¯ä¸€è‡´çš„ï¼ˆéƒ½å¯¹é½åˆ°äº†å½“å‰çš„æ•´ç‚¹æ—¶é—´ï¼‰ã€‚

ç»“è®ºï¼šGhost Series (ç»Ÿä¸€éª¨æ¶) + Logical Range Sync (ç»Ÿä¸€è§†è§’) = å®Œç¾çš„åŒæ­¥æ‹–åŠ¨ä¸ç¼©æ”¾ã€‚

ä»¥ä¸‹æ˜¯ä¿®å¤æ–¹æ¡ˆï¼Œæˆ‘å°†ä¿®æ”¹ä¸‰ä¸ªæ–‡ä»¶ï¼Œå°†åŒæ­¥æœºåˆ¶ä» TimeRange å½»åº•åˆ‡æ¢ä¸º LogicalRangeã€‚

1. ä¿®æ”¹çŠ¶æ€å®šä¹‰ (ChartPageLayout.tsx)

å°† viewportState çš„ç±»å‹å®šä¹‰ä»æ—¶é—´æˆ³æ”¹ä¸ºé€»è¾‘ç´¢å¼•ã€‚

packages/frontend/src/ChartPageLayout.tsx
code
Code
download
content_copy
expand_less
// packages/frontend/src/ChartPageLayout.tsx
import { Component, createSignal, onMount, onCleanup, createMemo, Show } from 'solid-js';
import { createStore, produce } from 'solid-js/store';
import { socket } from './socket';
import type { MarketItem, DataPayload } from 'shared-types';
import CompactRankingListsContainer from './CompactRankingListsContainer';
import MultiChartGrid from './MultiChartGrid';
import SingleTokenView from './SingleTokenView';
import { initializeVoices, checkAndTriggerAlerts } from './AlertManager';

// âœ¨ [Refactor] æ ¸å¿ƒä¿®æ”¹: å°†åŒæ­¥çŠ¶æ€æ”¹ä¸º Logical Range (é€»è¾‘ç´¢å¼•)
// Logical Range æ˜¯ LWC çš„å†…éƒ¨åæ ‡ï¼š0 ä»£è¡¨æœ€æ–°ä¸€æ ¹ K çº¿ï¼Œè´Ÿæ•°ä»£è¡¨æœªæ¥çš„ç©ºç™½ï¼Œæ­£æ•°ä»£è¡¨å†å²
// é…åˆ Ghost Seriesï¼Œè¿™èƒ½å®Œç¾è§£å†³â€œæ‹–åŠ¨å¯¼è‡´çš„æŒ¤å‹/ç¼©æ”¾â€é—®é¢˜ï¼Œå®ç°åˆšæ€§å¹³ç§»ã€‚
export interface ViewportState {
from: number; // Logical Index (float)
to: number; // Logical Index (float)
}

const BLOCKLIST_STORAGE_KEY = 'trading-dashboard-blocklist';

const TIMEFRAME_MAP: Record<string, string> = {
'1': '1m', '2': '5m', '3': '1h', '4': '4h', '5': '1d',
};
export const ALL_TIMEFRAMES = Object.values(TIMEFRAME_MAP);

const loadBlockListFromStorage = (): Set<string> => {
try {
const storedList = localStorage.getItem(BLOCKLIST_STORAGE_KEY);
if (storedList) {
const parsedArray = JSON.parse(storedList);
if (Array.isArray(parsedArray)) return new Set(parsedArray);
}
} catch (error) { console.error('[Blocklist] Failed to load blocklist:', error); }
return new Set();
};

const saveBlockListToStorage = (blockList: Set<string>): void => {
try {
localStorage.setItem(BLOCKLIST_STORAGE_KEY, JSON.stringify(Array.from(blockList)));
} catch (error) { console.error('[Blocklist] Failed to save blocklist:', error); }
};

const ChartPageLayout: Component = () => {
const [marketData, setMarketData] = createStore<MarketItem[]>([]);
const [lastUpdate, setLastUpdate] = createSignal('Connecting...');
const [activeRankBy, setActiveRankBy] = createSignal<keyof MarketItem | null>('volume1m');
const [blockList, setBlockList] = createSignal(loadBlockListFromStorage());
const [activeTimeframe, setActiveTimeframe] = createSignal(ALL_TIMEFRAMES[0]);
// åŒæ­¥çŠ¶æ€ä¿¡å·
const [viewportState, setViewportState] = createSignal<ViewportState | null>(null);
// å½“å‰æ­£åœ¨æ“ä½œçš„å›¾è¡¨IDï¼Œé¿å…å›ç¯è§¦å‘
const [activeChartId, setActiveChartId] = createSignal<string | null>(null);

const [viewMode, setViewMode] = createSignal<'grid' | 'single'>('grid');
const [focusedToken, setFocusedToken] = createSignal<MarketItem | null>(null);

const handleViewportChange = (newState: ViewportState | null) => {
setViewportState(newState);
};

const handleKeyDown = (e: KeyboardEvent) => {
if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;

code
Code
download
content_copy
expand_less
if (Object.keys(TIMEFRAME_MAP).includes(e.key)) {
    const newTimeframe = TIMEFRAME_MAP[e.key];
    console.log(`[Layout] Hotkey '${e.key}' pressed. Changing timeframe to ${newTimeframe}`);
    setActiveTimeframe(newTimeframe);
    // åˆ‡æ¢å‘¨æœŸæ—¶é‡ç½®åŒæ­¥çŠ¶æ€ï¼Œå› ä¸ºä¸åŒå‘¨æœŸçš„é€»è¾‘ç´¢å¼•æ„ä¹‰ä¸åŒï¼ˆè™½ç„¶ Ghost Series è¯•å›¾å¯¹é½ï¼Œä½†é‡ç½®æ›´å®‰å…¨ï¼‰
    if (viewMode() === 'grid') {
        setViewportState(null);
    }
    return;
}

if (e.key.toLowerCase() === 'f') {
    if (viewMode() === 'grid') {
        const hoveredTokenId = activeChartId();
        if (hoveredTokenId) {
            const token = rankedTokensForGrid().find(t => t.contractAddress === hoveredTokenId);
            if (token) {
                console.log(`[Layout] Entering single view for ${token.symbol}`);
                setFocusedToken(token);
                setViewMode('single');
            }
        }
    } else {
        console.log('[Layout] Exiting single view.');
        setViewMode('grid');
        setFocusedToken(null);
    }
}

};

const handleNewAlert = (logMessage: string, alertType: 'volume' | 'price') => {
console.log([ChartPage Alert] [${alertType.toUpperCase()}] ${logMessage});
};

onMount(() => {
if (!socket.connected) {
socket.connect();
}

code
Code
download
content_copy
expand_less
socket.on('connect', () => setLastUpdate('Connected, waiting for data...'));
socket.on('disconnect', () => setLastUpdate('Disconnected'));
socket.on('data-broadcast', (payload: DataPayload) => {
    if (!payload.data || payload.data.length === 0) return;
    const blocked = blockList();
    
    for (const newItem of payload.data) {
        if (!blocked.has(newItem.contractAddress)) {
            const oldItem = marketData.find(d => 
                d.contractAddress === newItem.contractAddress && d.chain === newItem.chain
            );
            if (oldItem) {
                checkAndTriggerAlerts(newItem, oldItem, handleNewAlert);
            }
        }
    }

    setMarketData(produce(currentData => {
        for (const item of payload.data) {
            const index = currentData.findIndex(d => d.contractAddress === item.contractAddress && d.chain === item.chain);
            if (index > -1) Object.assign(currentData[index], item);
            else currentData.push(item);
        }
    }));
    setLastUpdate(new Date().toLocaleTimeString());
});

initializeVoices();
window.addEventListener('keydown', handleKeyDown);

onCleanup(() => {
    socket.off('connect');
    socket.off('disconnect');
    socket.off('data-broadcast');
    window.removeEventListener('keydown', handleKeyDown);
});

});

const handleBlockToken = (contractAddress: string) => {
const newBlockList = new Set(blockList());
newBlockList.add(contractAddress);
setBlockList(newBlockList);
saveBlockListToStorage(newBlockList);
console.log([Blocklist] Token ${contractAddress} added.);
};

const rankedTokensForGrid = createMemo(() => {
const rankBy = activeRankBy();
const blocked = blockList();
if (!rankBy) return [];
return [...marketData]
.filter(item => !blocked.has(item.contractAddress))
.filter(item => item.icon && item[rankBy] != null)
.sort((a, b) => {
const valA = a[rankBy]!;
const valB = b[rankBy]!;
return (typeof valB === 'string' ? parseFloat(valB) : valB) -
(typeof valA === 'string' ? parseFloat(valA) : valA);
})
.slice(0, 9);
});

const handleRankingHeaderClick = (rankBy: keyof MarketItem) => {
console.log([Layout] User selected new ranking: ${rankBy}.);
setActiveRankBy(rankBy);
};

const handleRankingItemClick = (item: MarketItem) => {
const url = /token.html?address=${item.contractAddress}&chain=${item.chain};
window.open(url, '_blank');
};

return (
<div class="chart-page-container">
<div class="left-sidebar">
<CompactRankingListsContainer
marketData={marketData}
lastUpdate={lastUpdate()}
onHeaderClick={handleRankingHeaderClick}
blockList={blockList()}
onItemClick={handleRankingItemClick}
/>
</div>
<div class="right-chart-grid">
<Show
when={viewMode() === 'single' && focusedToken()}
fallback={
<>
<div class="grid-header">
<div class="active-timeframe-indicator">
<span>Timeframe: </span>
<strong>{activeTimeframe().toUpperCase()}</strong>
<span class="hotkey-hint">(Keys: 1-5)</span>
</div>
</div>
<MultiChartGrid
tokens={rankedTokensForGrid()}
onBlockToken={handleBlockToken}
timeframe={activeTimeframe()}
viewportState={viewportState()}
onViewportChange={handleViewportChange}
activeChartId={activeChartId()}
onSetActiveChart={setActiveChartId}
/>
</>
}
>
<SingleTokenView
token={focusedToken()!}
activeTimeframe={activeTimeframe()}
/>
</Show>
</div>
</div>
);

};

export default ChartPageLayout;

2. æ›´æ–° Grid ç»„ä»¶ (MultiChartGrid.tsx)

é€ä¼ æ–°çš„ç±»å‹å®šä¹‰ã€‚

packages/frontend/src/MultiChartGrid.tsx
code
Code
download
content_copy
expand_less
// packages/frontend/src/MultiChartGrid.tsx
import { Component, For, createMemo } from 'solid-js';
import SingleKlineChart from './SingleKlineChart';
import type { MarketItem } from 'shared-types';
import type { ViewportState } from './ChartPageLayout';

interface MultiChartGridProps {
tokens: MarketItem[];
onBlockToken: (contractAddress: string) => void;
timeframe: string;
viewportState: ViewportState | null;
onViewportChange: (state: ViewportState | null) => void;
activeChartId: string | null;
onSetActiveChart: (id: string | null) => void;
}

const MultiChartGrid: Component<MultiChartGridProps> = (props) => {
const chartData = createMemo(() => {
const currentTokens = props.tokens || [];
// å§‹ç»ˆä¿æŒ9ä¸ªæ ¼å­
return Array.from({ length: 9 }).map((_, i) => currentTokens[i]);
});

code
Code
download
content_copy
expand_less
return (
    <div id="chart-grid-container">
        <For each={chartData()}>
            {(token) => (
                <SingleKlineChart
                    tokenInfo={token}
                    onBlock={props.onBlockToken}
                    timeframe={props.timeframe}
                    viewportState={props.viewportState}
                    onViewportChange={props.onViewportChange}
                    activeChartId={props.activeChartId}
                    onSetActiveChart={props.onSetActiveChart}
                    showAxes={true}
                />
            )}
        </For>
    </div>
);

};

export default MultiChartGrid;

3. æ ¸å¿ƒå®ç° (SingleKlineChart.tsx)

è¿™æ˜¯ä¿®æ”¹æœ€å…³é”®çš„åœ°æ–¹ï¼š

Ghost Series: ä¿æŒä¸å˜ï¼Œç”¨äºâ€œæ’‘å¼€â€åæ ‡è½´ï¼Œç¡®ä¿æ‰€æœ‰å›¾è¡¨éƒ½æœ‰ç›¸åŒçš„â€œæœªæ¥â€å’Œâ€œå†å²â€ç©ºé—´ã€‚

Sender: ä½¿ç”¨ subscribeVisibleLogicalRangeChange è·å–é€»è¾‘ç´¢å¼•å¹¶å¹¿æ’­ã€‚

Receiver: ä½¿ç”¨ setVisibleLogicalRange æ¥æ”¶å¹¶åº”ç”¨é€»è¾‘ç´¢å¼•ã€‚

packages/frontend/src/SingleKlineChart.tsx
code
Code
download
content_copy
expand_less
// packages/frontend/src/SingleKlineChart.tsx

/** @jsxImportSource solid-js */

import { Component, onMount, onCleanup, createEffect, Show, createSignal } from 'solid-js';
import { createChart, ColorType, IChartApi, ISeriesApi, CandlestickData, CandlestickSeries, Time, LineSeries, LogicalRange } from 'lightweight-charts';
import { socket } from './socket';
import type { KlineUpdatePayload, KlineFetchErrorPayload } from './types';
import type { MarketItem } from 'shared-types';
import type { ViewportState } from './ChartPageLayout';

const BACKEND_URL = 'http://localhost:3001';

// --- é…ç½®åŒº ---
// å¼ºåˆ¶è¡¥é½çš„Kçº¿æ•°é‡
const FORCE_GHOST_CANDLE_COUNT = 1000;

interface SingleKlineChartProps {
tokenInfo: MarketItem | undefined;
onBlock?: (contractAddress: string) => void;
timeframe: string;
viewportState: ViewportState | null;
onViewportChange?: (state: ViewportState | null) => void;
activeChartId: string | null;
onSetActiveChart?: (id: string | null) => void;
showAxes?: boolean;
}

const customPriceFormatter = (price: number): string => {
if (price === 0) return '0';
if (price < 0.000001) {
return price.toFixed(12).replace(/.?0+$/, "");
}
if (price < 1) return price.toFixed(6);
return price.toFixed(2);
};

const getIntervalSeconds = (timeframe: string): number => {
const val = parseInt(timeframe);
if (timeframe.endsWith('m')) return val * 60;
if (timeframe.endsWith('h')) return val * 3600;
if (timeframe.endsWith('d')) return val * 86400;
return 60; // default 1m
};

const SingleKlineChart: Component<SingleKlineChartProps> = (props) => {
let chartContainer: HTMLDivElement;
let chart: IChartApi | null = null;
let candlestickSeries: ISeriesApi<'Candlestick'> | null = null;
let ghostSeries: ISeriesApi<'Line'> | null = null;
let resizeObserver: ResizeObserver | null = null;
const [status, setStatus] = createSignal('Initializing...');

code
Code
download
content_copy
expand_less
// ğŸ”’ çŠ¶æ€é”
let isProgrammaticUpdate = false;
let isSyncPending = false;

const getMyId = () => props.tokenInfo?.contractAddress || '';

const log = (msg: string, ...args: any[]) => {
    // console.log(`[Chart ${props.tokenInfo?.symbol || 'Wait'}] ${msg}`, ...args);
};

const cleanupChart = () => {
    if (chart) {
        chart.remove();
        chart = null;
        candlestickSeries = null;
        ghostSeries = null;
    }
};

const unsubscribeRealtime = (payload: { address: string; chain: string; interval: string }) => {
    socket.off('kline_update', handleKlineUpdate);
    socket.emit('unsubscribe_kline', payload);
};

const handleKlineUpdate = (update: KlineUpdatePayload) => {
    const info = props.tokenInfo;
    if (!info || !candlestickSeries) return;
    
    const chainToPoolId: Record<string, number> = { bsc: 14, sol: 16, solana: 16, base: 199 };
    const poolId = chainToPoolId[info.chain.toLowerCase()];
    if (!poolId) return;

    const expectedRoom = `kl@${poolId}@${info.contractAddress}@${props.timeframe}`;

    if (update.room === expectedRoom) {
        const newCandle = update.data as CandlestickData<number>;
        const currentData = candlestickSeries.data();
        if (currentData.length > 0) {
            const lastCandle = currentData[currentData.length - 1] as CandlestickData<number>;
            if (newCandle.time < lastCandle.time) return;
        }
        candlestickSeries.update(newCandle);
    }
};

// ğŸ‘» ç”Ÿæˆéšå½¢æ•°æ®
// è¿™ä¸€æ­¥è‡³å…³é‡è¦ï¼šå®ƒç¡®ä¿äº†æ‰€æœ‰å›¾è¡¨çš„ Logical Index 0 å¯¹åº”ç€ç›¸åŒçš„ç‰©ç†æ—¶é—´
const generateGhostData = (timeframe: string) => {
    const intervalSec = getIntervalSeconds(timeframe);
    const nowAligned = Math.floor(Date.now() / 1000 / intervalSec) * intervalSec;
    
    const data = [];
    for (let i = FORCE_GHOST_CANDLE_COUNT; i >= 0; i--) {
        data.push({
            time: (nowAligned - (i * intervalSec)) as Time,
            value: 0 
        });
    }
    return data;
};

createEffect(() => {
    const info = props.tokenInfo;
    const timeframe = props.timeframe;

    if (!info || !timeframe) {
        cleanupChart();
        setStatus('No token selected.');
        return;
    }

    cleanupChart();
    setStatus(`Loading ${info.symbol}...`);
    
    if (!chartContainer) return;

    try {
        chart = createChart(chartContainer, {
            width: chartContainer.clientWidth, 
            height: chartContainer.clientHeight,
            layout: { background: { type: ColorType.Solid, color: '#ffffff' }, textColor: '#333' },
            grid: { vertLines: { color: '#f0f3fa' }, horzLines: { color: '#f0f3fa' } },
            timeScale: { 
                visible: !!props.showAxes, 
                borderColor: '#cccccc', 
                timeVisible: true, 
                secondsVisible: false,
                rightOffset: 12, 
                shiftVisibleRangeOnNewBar: true, 
                fixLeftEdge: false, 
                fixRightEdge: false, // å…è®¸æ‹–åŠ¨ç¦»å¼€å³è¾¹ç¼˜
            },
            rightPriceScale: { visible: !!props.showAxes, borderColor: '#cccccc', autoScale: true },
            leftPriceScale: { visible: false, autoScale: false }, 
            handleScroll: true, 
            handleScale: true,
        });

        // 1. Ghost Series
        ghostSeries = chart.addSeries(LineSeries, {
            color: 'rgba(0,0,0,0)', 
            lineWidth: 1,
            priceScaleId: 'left',   
            crosshairMarkerVisible: false,
            lastValueVisible: false,
            priceLineVisible: false,
        });
        ghostSeries.setData(generateGhostData(timeframe));

        // 2. Real Series
        candlestickSeries = chart.addSeries(CandlestickSeries, {
            priceFormat: { 
                type: 'price', 
                precision: 10,
                minMove: 0.00000001, 
                formatter: customPriceFormatter 
            },
            upColor: '#28a745', downColor: '#dc3545', borderDownColor: '#dc3545',
            borderUpColor: '#28a745', wickDownColor: '#dc3545', wickUpColor: '#28a745',
            priceScaleId: 'right'
        });

    } catch (e) {
        console.error(`[Chart:${info.symbol}] âŒ Fatal Error creating chart:`, e);
        return;
    }

    // [SENDER] âœ¨âœ¨âœ¨ æ ¸å¿ƒä¿®æ”¹ï¼šå‘é€ Logical Rangeï¼ˆé€»è¾‘ç´¢å¼•ï¼‰è€Œé TimeRange âœ¨âœ¨âœ¨
    // ç›‘å¬é€»è¾‘ç´¢å¼•å˜åŒ–ï¼Œè¿™ä»£è¡¨äº†ç”¨æˆ·æ‹–åŠ¨æˆ–ç¼©æ”¾äº†ç½‘æ ¼ï¼Œè€Œä¸åªæ˜¯æ—¶é—´
    chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
        if (isProgrammaticUpdate) return;

        const myId = getMyId().toLowerCase();
        const activeId = props.activeChartId?.toLowerCase();

        // åªæœ‰å½“å‰é¼ æ ‡æ‰€åœ¨çš„æ¿€æ´»å›¾è¡¨ï¼Œæ‰æœ‰èµ„æ ¼å‘é€åŒæ­¥ä¿¡å·
        if (myId === activeId) {
            if (!isSyncPending) {
                isSyncPending = true;
                requestAnimationFrame(() => {
                    // è·å–é€»è¾‘ç´¢å¼•èŒƒå›´ (e.g. from: -5.5, to: 50.2)
                    const logicalRange = chart?.timeScale().getVisibleLogicalRange();
                    if (logicalRange && props.onViewportChange) {
                        props.onViewportChange({ 
                            from: logicalRange.from, 
                            to: logicalRange.to 
                        });
                    }
                    isSyncPending = false;
                });
            }
        }
    });

    const payload = { address: info.contractAddress, chain: info.chain, interval: timeframe };

    const processData = (data: any[], isInitial: boolean) => {
        try {
            const sortedData = data
                .map(d => ({ ...d, time: Number(d.time) }))
                .sort((a, b) => a.time - b.time);

            if (isInitial) {
                candlestickSeries?.setData(sortedData as CandlestickData<number>[]);
                
                // åˆå§‹ä½ç½®é€»è¾‘
                if (props.viewportState) {
                    // å¦‚æœçˆ¶çº§æœ‰åŒæ­¥çŠ¶æ€ï¼Œä½¿ç”¨ setVisibleLogicalRange å¼ºåˆ¶å¯¹é½
                     chart?.timeScale().setVisibleLogicalRange({
                        from: props.viewportState.from,
                        to: props.viewportState.to
                    });
                } else {
                    chart?.timeScale().scrollToRealTime();
                }
            } else {
                const currentData = (candlestickSeries?.data() as CandlestickData<number>[] || []);
                const newDataMap = new Map(currentData.map(d => [d.time, d]));
                sortedData.forEach(d => newDataMap.set(d.time as number, d as CandlestickData<number>));
                const merged = Array.from(newDataMap.values()).sort((a, b) => (a.time as number) - (b.time as number));
                candlestickSeries?.setData(merged);
            }
            setStatus(`Live`);
        } catch (e) {
            console.error(`[Chart:${info.symbol}] âŒ Failed to process data:`, e);
        }
    };

    const handleInitialData = (response: any) => {
        if (response.interval !== timeframe || response.address.toLowerCase() !== info.contractAddress.toLowerCase()) return;
        if (response.data && response.data.length > 0) {
            processData(response.data, true);
        } else {
            setStatus(`No Data`);
        }
    };
    
    const handleCompletedData = (response: any) => {
        if (response.interval !== timeframe || response.address.toLowerCase() !== info.contractAddress.toLowerCase()) return;
        if (response.data && response.data.length > 0) {
            processData(response.data, false);
        }
    };
    
    const handleFetchError = (err: KlineFetchErrorPayload) => {
         const key = `${info.contractAddress.toLowerCase()}@${info.chain.toLowerCase()}@${timeframe}`;
         if(err.key === key) {
            setStatus(`Error`);
         }
    };

    socket.on('historical_kline_initial', handleInitialData);
    socket.on('historical_kline_completed', handleCompletedData);
    socket.on('kline_fetch_error', handleFetchError);
    socket.on('kline_update', handleKlineUpdate);

    socket.emit('request_historical_kline', payload);
    socket.emit('subscribe_kline', payload); 

    onCleanup(() => {
        unsubscribeRealtime(payload);
        socket.off('historical_kline_initial', handleInitialData);
        socket.off('historical_kline_completed', handleCompletedData);
        socket.off('kline_fetch_error', handleFetchError);
        cleanupChart();
    });
});

// [RECEIVER] âœ¨âœ¨âœ¨ æ ¸å¿ƒä¿®æ”¹ï¼šæ¥æ”¶é€»è¾‘ç´¢å¼•åŒæ­¥ âœ¨âœ¨âœ¨
createEffect(() => {
    const vs = props.viewportState;
    if (!chart || !vs || !props.tokenInfo) return;

    const myId = getMyId().toLowerCase();
    const activeId = props.activeChartId?.toLowerCase();

    // ä¸æ¥æ”¶è‡ªå·±çš„ä¿¡å·ï¼Œé¿å…æ­»å¾ªç¯
    if (myId === activeId) return;

    isProgrammaticUpdate = true;
    try {
        // ä½¿ç”¨ setVisibleLogicalRange å¼ºåˆ¶æ‰€æœ‰å›¾è¡¨å¯¹é½åˆ°ç›¸åŒçš„â€œæ ¼å­æ•°â€
        // é…åˆ Ghost Seriesï¼Œæ— è®ºæ•°æ®å¤šå°‘ï¼Œç½‘æ ¼çš„å‡ ä½•å½¢çŠ¶ï¼ˆBar Spacingï¼‰éƒ½å°†ä¸¥æ ¼ä¸€è‡´
        chart.timeScale().setVisibleLogicalRange({
            from: vs.from,
            to: vs.to
        });
    } catch (e) {
       // ignore potential errors during heavy data loading
    }
    // ç«‹å³è§£é”
    setTimeout(() => { isProgrammaticUpdate = false; }, 0);
});

onMount(() => {
    resizeObserver = new ResizeObserver(entries => {
        if (chart && chartContainer) {
            const { width, height } = entries[0].contentRect;
            chart.applyOptions({ width, height });
        }
    });
    if (chartContainer) {
        resizeObserver.observe(chartContainer);
    }
});

onCleanup(() => resizeObserver?.disconnect());

return (
    <div 
        class="single-chart-wrapper"
        onMouseEnter={() => {
            if (props.tokenInfo) {
                props.onSetActiveChart?.(props.tokenInfo.contractAddress);
            }
        }}
    >
        <div class="chart-header">
            <Show when={props.tokenInfo} fallback={<span class="placeholder">{status()}</span>}>
                <img src={`${BACKEND_URL}/image-proxy?url=${encodeURIComponent(props.tokenInfo!.icon!)}`} class="icon-small" alt={props.tokenInfo!.symbol}/>
                <span class="symbol-title">{props.tokenInfo!.symbol}</span>
                <span class="chain-badge">{props.tokenInfo!.chain.toUpperCase()}</span>
                <button class="block-button" title={`å±è”½ ${props.tokenInfo!.symbol}`} onClick={() => props.onBlock?.(props.tokenInfo!.contractAddress)}>
                    ğŸš«
                </button>
            </Show>
        </div>
        <div ref={chartContainer!} class="chart-container" />
    </div>
);

};

export default SingleKlineChart;