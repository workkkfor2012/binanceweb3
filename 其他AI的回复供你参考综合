è¿™æ˜¯ä¸€ä¸ªéå¸¸æ¸…æ™°çš„é‡æ„éœ€æ±‚ã€‚æˆ‘å·²ä»”ç»†é˜…è¯»äº†ä½ çš„é¡¹ç›®ä»£ç ï¼Œç‰¹åˆ«æ˜¯ ChartPageLayoutã€MultiChartGrid å’Œ SingleKlineChart ä¹‹é—´çš„äº¤äº’ã€‚

ç¬¬ä¸€éƒ¨åˆ†ï¼šå‰ç«¯ 9 å›¾æ¸²æŸ“æµç¨‹æ¢³ç†

ç›®å‰çš„æ¸²æŸ“æµç¨‹å¤§è‡´å¦‚ä¸‹ï¼š

æ•°æ®æ¥å…¥ (Socket/Data Layer):

App.tsx æˆ– ChartPageLayout.tsx é‡Œçš„ Socket ç›‘å¬ data-broadcastï¼Œæ›´æ–°å…¨å±€ marketDataï¼ˆåŒ…å«æœ€æ–°ä»·æ ¼ã€Volume ç­‰ snapshotï¼‰ã€‚

ChartPageLayout æ ¹æ® activeRankByï¼ˆå¦‚æˆäº¤é¢ã€æ¶¨å¹…ï¼‰å’Œ blockList è¿‡æ»¤å¹¶æ’åºå‡º Top 9 çš„ rankedTokensForGridã€‚

ç»„ä»¶æŒ‚è½½ (Layout Layer):

MultiChartGrid æ¥æ”¶è¿™ 9 ä¸ª Token æ•°æ®ï¼Œå¹¶å¾ªç¯æ¸²æŸ“ 9 ä¸ª SingleKlineChart ç»„ä»¶ã€‚

å›¾è¡¨åˆå§‹åŒ–ä¸æ•°æ®åŠ è½½ (Chart Component Layer):

æ¯ä¸ª SingleKlineChart åœ¨ onMount æ—¶åˆå§‹åŒ– lightweight-charts å®ä¾‹ã€‚

åŒæ—¶å‘é€ request_historical_kline å’Œ subscribe_kline åˆ°åç«¯ã€‚

Socket æ”¶åˆ° historical_kline_completed åï¼Œè°ƒç”¨ candlestickSeries.setData å¡«å……å†å²æ•°æ®ã€‚

Socket æ”¶åˆ° kline_update åï¼Œè°ƒç”¨ candlestickSeries.update æ›´æ–°å®æ—¶çš„ä¸€æ ¹ K çº¿ã€‚

åŒæ­¥ç¼©æ”¾ (Sync Layer - ç›®å‰çš„é‡ç‚¹):

ç”¨æˆ·åœ¨æŸä¸ªå›¾è¡¨ä¸Šæ»šåŠ¨/ç¼©æ”¾ -> è§¦å‘ subscribeVisibleLogicalRangeChangeã€‚

è®¡ç®—å½“å‰å¯è§†åŒºåŸŸçš„ Bar Index (Kçº¿æ•°é‡ç´¢å¼•) å®½åº¦å’Œç›¸å¯¹äºæœ€æ–° K çº¿çš„åç§»é‡ã€‚

é€šè¿‡çˆ¶ç»„ä»¶ ChartPageLayout å°†è¿™ä¸ªçŠ¶æ€å¹¿æ’­ç»™å…¶ä»– 8 ä¸ªå›¾è¡¨ã€‚

å…¶ä»–å›¾è¡¨æ¥æ”¶çŠ¶æ€ï¼Œé€šè¿‡ setVisibleLogicalRange å¼ºåˆ¶è®¾ç½®ç›¸åŒçš„ç´¢å¼•èŒƒå›´ã€‚

ç¬¬äºŒéƒ¨åˆ†ï¼šè¯„ä»·ç›®å‰çš„åŒæ­¥ç¼©æ”¾ç®—æ³•

ç›®å‰çš„ç®—æ³•ï¼šåŸºäºç´¢å¼•å¯¹é½ (Index-Based Alignment)

é€»è¾‘ï¼šè®¡ç®—â€œå½“å‰çœ‹åˆ°çš„æ˜¯å€’æ•°ç¬¬ X æ ¹åˆ°å€’æ•°ç¬¬ Y æ ¹ K çº¿â€ï¼Œå¹¶è®©æ‰€æœ‰å›¾è¡¨éƒ½æ˜¾ç¤ºè¿™ä¸ªèŒƒå›´ã€‚

è¯„ä»·ï¼šä¸åˆç† (Unreasonable)ã€‚

ä¸ºä»€ä¹ˆä¸åˆç†ï¼Ÿ

æ•°æ®å¯¹é½é—®é¢˜ï¼ˆæ ¸å¿ƒè‡´å‘½ä¼¤ï¼‰ï¼š

å‡è®¾å›¾è¡¨ A æ˜¯ BTCï¼ˆæµåŠ¨æ€§å¥½ï¼Œæ¯åˆ†é’Ÿéƒ½æœ‰ K çº¿ï¼‰ï¼Œå›¾è¡¨ B æ˜¯æŸä¸ªå†·é—¨å±±å¯¨å¸ï¼ˆå¯èƒ½å‡ åˆ†é’Ÿæ‰æœ‰ä¸€ç¬”äº¤æ˜“ï¼ŒK çº¿æœ‰æ–­æ¡£ï¼‰ã€‚

å¦‚æœä½ åœ¨ BTC ä¸Šçœ‹çš„æ˜¯â€œ10:00 - 10:05â€ï¼Œè¿™å¯¹åº”çš„æ˜¯å€’æ•°ç¬¬ 50-55 æ ¹ K çº¿ã€‚

åœ¨å†·é—¨å¸ä¸Šï¼Œå€’æ•°ç¬¬ 50-55 æ ¹ K çº¿å¯èƒ½å‘ç”Ÿåœ¨â€œæ˜¨å¤©ä¸‹åˆ 14:00â€ã€‚

ç»“æœï¼šç”¨æˆ·çœ‹åˆ°çš„æ—¶é—´è½´æ˜¯é”™ä¹±çš„ï¼Œæ— æ³•æ¨ªå‘å¯¹æ¯”åŒä¸€æ—¶é—´çš„è¡Œæƒ…ã€‚

æ•°æ®åŠ è½½å»¶è¿Ÿï¼š

å¦‚æœå›¾è¡¨ C çš„æ•°æ®è¿˜æ²¡åŠ è½½å®Œï¼ˆåªæœ‰ 10 æ ¹ï¼‰ï¼Œè€Œå›¾è¡¨ A è®©ä½ æ˜¾ç¤ºâ€œå€’æ•°ç¬¬ 100 æ ¹â€ï¼Œå›¾è¡¨ C ä¼šæŠ¥é”™æˆ–æ˜¾ç¤ºç©ºç™½ï¼Œè®¡ç®—é€»è¾‘ä¼šå‡ºç°è´Ÿæ•°ç´¢å¼•å¼‚å¸¸ã€‚

è§†è§‰è¯¯å¯¼ï¼š

9 å›¾æ¨¡å¼çš„æ ¸å¿ƒä»·å€¼åœ¨äºå‘ç°åŒä¸€æ—¶é—´ç‚¹çš„å…±æŒ¯ã€‚åŸºäº Index çš„åŒæ­¥ç ´åäº†è¿™ä¸€ä»·å€¼ã€‚

æ”¹è¿›å»ºè®®ï¼šåŸºäºæ—¶é—´æˆ³å¯¹é½ (Time-Based Alignment)

é€»è¾‘ï¼šè®¡ç®—â€œå½“å‰çœ‹åˆ°çš„æ˜¯ 10:00 åˆ° 10:30â€ï¼Œå°†è¿™ä¸ªæ—¶é—´æˆ³èŒƒå›´å¹¿æ’­ç»™å…¶ä»–å›¾è¡¨ã€‚

ä¼˜åŠ¿ï¼šæ— è®ºè¯¥å“ç§äº¤æ˜“æ˜¯å¦æ´»è·ƒï¼Œæ‰€æœ‰å›¾è¡¨çš„æ—¶é—´è½´éƒ½ä¼šå¼ºåˆ¶å¯¹é½åˆ°åŒä¸€ç‰©ç†æ—¶é—´æ®µã€‚

ç¬¬ä¸‰éƒ¨åˆ†ï¼šä»£ç é‡æ„

æˆ‘å°†ä¿®æ”¹è¿™ä¸‰ä¸ªæ–‡ä»¶ï¼Œå°†åŒæ­¥é€»è¾‘ä» LogicalRange (ç´¢å¼•) æ”¹ä¸º TimeRange (æ—¶é—´æˆ³)ã€‚

1. ä¿®æ”¹ packages/frontend/src/ChartPageLayout.tsx

å®šä¹‰æ–°çš„çŠ¶æ€æ¥å£ï¼Œå­˜å‚¨æ—¶é—´èŒƒå›´è€Œéç´¢å¼•èŒƒå›´ã€‚

code
download
content_copy
expand_less
packages/frontend/src/ChartPageLayout.tsx
// packages/frontend/src/ChartPageLayout.tsx
import { Component, createSignal, onMount, onCleanup, createMemo, Show } from 'solid-js';
import { createStore, produce } from 'solid-js/store';
import { socket } from './socket'; // âœ¨ ä½¿ç”¨å…±äº«çš„ socket å®ä¾‹
import type { MarketItem, DataPayload } from 'shared-types';
import CompactRankingListsContainer from './CompactRankingListsContainer';
import MultiChartGrid from './MultiChartGrid';
import SingleTokenView from './SingleTokenView';
import { initializeVoices, checkAndTriggerAlerts } from './AlertManager';

// âœ¨ æ ¸å¿ƒä¿®æ”¹: å°† ViewportState ä»ç´¢å¼•é€»è¾‘æ”¹ä¸ºæ—¶é—´æˆ³é€»è¾‘
export interface ViewportState {
from: number; // Unix Timestamp (seconds)
to: number; // Unix Timestamp (seconds)
}

const BLOCKLIST_STORAGE_KEY = 'trading-dashboard-blocklist';

const TIMEFRAME_MAP: Record<string, string> = {
'1': '1m', '2': '5m', '3': '1h', '4': '4h', '5': '1d',
};
export const ALL_TIMEFRAMES = Object.values(TIMEFRAME_MAP);

const loadBlockListFromStorage = (): Set<string> => {
try {
const storedList = localStorage.getItem(BLOCKLIST_STORAGE_KEY);
if (storedList) {
const parsedArray = JSON.parse(storedList);
if (Array.isArray(parsedArray)) return new Set(parsedArray);
}
} catch (error) { console.error('[Blocklist] Failed to load blocklist:', error); }
return new Set();
};

const saveBlockListToStorage = (blockList: Set<string>): void => {
try {
localStorage.setItem(BLOCKLIST_STORAGE_KEY, JSON.stringify(Array.from(blockList)));
} catch (error) { console.error('[Blocklist] Failed to save blocklist:', error); }
};

const ChartPageLayout: Component = () => {
const [marketData, setMarketData] = createStore<MarketItem[]>([]);
const [lastUpdate, setLastUpdate] = createSignal('Connecting...');
const [activeRankBy, setActiveRankBy] = createSignal<keyof MarketItem | null>('volume1m');
const [blockList, setBlockList] = createSignal(loadBlockListFromStorage());
const [activeTimeframe, setActiveTimeframe] = createSignal(ALL_TIMEFRAMES[0]);
const [viewportState, setViewportState] = createSignal<ViewportState | null>(null);
const [activeChartId, setActiveChartId] = createSignal<string | null>(null);

code
Code
download
content_copy
expand_less
const [viewMode, setViewMode] = createSignal<'grid' | 'single'>('grid');
const [focusedToken, setFocusedToken] = createSignal<MarketItem | null>(null);

const handleViewportChange = (newState: ViewportState | null) => {
    setViewportState(newState);
};

const handleKeyDown = (e: KeyboardEvent) => {
    if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;

    if (Object.keys(TIMEFRAME_MAP).includes(e.key)) {
        const newTimeframe = TIMEFRAME_MAP[e.key];
        console.log(`[Layout] Hotkey '${e.key}' pressed. Changing timeframe to ${newTimeframe}`);
        setActiveTimeframe(newTimeframe);
        if (viewMode() === 'grid') {
            setViewportState(null);
        }
        return;
    }

    if (e.key.toLowerCase() === 'f') {
        if (viewMode() === 'grid') {
            const hoveredTokenId = activeChartId();
            if (hoveredTokenId) {
                const token = rankedTokensForGrid().find(t => t.contractAddress === hoveredTokenId);
                if (token) {
                    console.log(`[Layout] Entering single view for ${token.symbol}`);
                    setFocusedToken(token);
                    setViewMode('single');
                }
            }
        } else {
            console.log('[Layout] Exiting single view.');
            setViewMode('grid');
            setFocusedToken(null);
        }
    }
};

const handleNewAlert = (logMessage: string, alertType: 'volume' | 'price') => {
    console.log(`[ChartPage Alert] [${alertType.toUpperCase()}] ${logMessage}`);
};

onMount(() => {
    // ç¡®ä¿ socket è¿æ¥ï¼Œå¦‚æœå®ƒæ–­å¼€äº†ï¼Œå®ƒä¼šè‡ªåŠ¨é‡è¿
    if (!socket.connected) {
        socket.connect();
    }
    
    socket.on('connect', () => setLastUpdate('Connected, waiting for data...'));
    socket.on('disconnect', () => setLastUpdate('Disconnected'));
    socket.on('data-broadcast', (payload: DataPayload) => {
        if (!payload.data || payload.data.length === 0) return;
        const blocked = blockList();
        for (const newItem of payload.data) {
            if (!blocked.has(newItem.contractAddress)) {
                const oldItem = marketData.find(d => 
                    d.contractAddress === newItem.contractAddress && d.chain === newItem.chain
                );
                if (oldItem) {
                    checkAndTriggerAlerts(newItem, oldItem, handleNewAlert);
                }
            }
        }
        setMarketData(produce(currentData => {
            for (const item of payload.data) {
                const index = currentData.findIndex(d => d.contractAddress === item.contractAddress && d.chain === item.chain);
                if (index > -1) Object.assign(currentData[index], item);
                else currentData.push(item);
            }
        }));
        setLastUpdate(new Date().toLocaleTimeString());
    });
    initializeVoices();
    window.addEventListener('keydown', handleKeyDown);

    onCleanup(() => {
        // åœ¨ç»„ä»¶å¸è½½æ—¶ï¼Œåªç§»é™¤æ­¤ç»„ä»¶å…³å¿ƒçš„äº‹ä»¶ç›‘å¬å™¨ï¼Œè€Œä¸æ˜¯æ–­å¼€æ•´ä¸ª socket
        socket.off('connect');
        socket.off('disconnect');
        socket.off('data-broadcast');
        window.removeEventListener('keydown', handleKeyDown);
    });
});

const handleBlockToken = (contractAddress: string) => {
    const newBlockList = new Set(blockList());
    newBlockList.add(contractAddress);
    setBlockList(newBlockList);
    saveBlockListToStorage(newBlockList);
    console.log(`[Blocklist] Token ${contractAddress} added.`);
};

const rankedTokensForGrid = createMemo(() => {
    const rankBy = activeRankBy();
    const blocked = blockList(); 
    if (!rankBy) return [];
    return [...marketData]
        .filter(item => !blocked.has(item.contractAddress))
        .filter(item => item.icon && item[rankBy] != null)
        .sort((a, b) => {
            const valA = a[rankBy]!;
            const valB = b[rankBy]!;
            return (typeof valB === 'string' ? parseFloat(valB) : valB) - 
                   (typeof valA === 'string' ? parseFloat(valA) : valA);
        })
        .slice(0, 9);
});

const handleRankingHeaderClick = (rankBy: keyof MarketItem) => {
    console.log(`[Layout] User selected new ranking: ${rankBy}.`);
    setActiveRankBy(rankBy);
};

const handleRankingItemClick = (item: MarketItem) => {
    const url = `/token.html?address=${item.contractAddress}&chain=${item.chain}`;
    // åœ¨æ–°æ ‡ç­¾é¡µä¸­æ‰“å¼€
    window.open(url, '_blank');
};

return (
    <div class="chart-page-container">
        <div class="left-sidebar">
            <CompactRankingListsContainer 
                marketData={marketData}
                lastUpdate={lastUpdate()} 
                onHeaderClick={handleRankingHeaderClick}
                blockList={blockList()}
                onItemClick={handleRankingItemClick}
            />
        </div>
        <div class="right-chart-grid">
            <Show
                when={viewMode() === 'single' && focusedToken()}
                fallback={
                    <>
                        <div class="grid-header">
                            <div class="active-timeframe-indicator">
                                <span>Timeframe: </span>
                                <strong>{activeTimeframe().toUpperCase()}</strong>
                                <span class="hotkey-hint">(Keys: 1-5)</span>
                            </div>
                        </div>
                        <MultiChartGrid 
                            tokens={rankedTokensForGrid()} 
                            onBlockToken={handleBlockToken} 
                            timeframe={activeTimeframe()}
                            viewportState={viewportState()}
                            onViewportChange={handleViewportChange}
                            activeChartId={activeChartId()}
                            onSetActiveChart={setActiveChartId}
                        />
                    </>
                }
            >
                <SingleTokenView 
                    token={focusedToken()!} 
                    activeTimeframe={activeTimeframe()} 
                />
            </Show>
        </div>
    </div>
);

};

export default ChartPageLayout;

2. ä¿®æ”¹ packages/frontend/src/MultiChartGrid.tsx

ä»…éœ€æ›´æ–°ç±»å‹å®šä¹‰ã€‚

code
download
content_copy
expand_less
packages/frontend/src/MultiChartGrid.tsx
// packages/frontend/src/MultiChartGrid.tsx
import { Component, For, createMemo } from 'solid-js';
import SingleKlineChart from './SingleKlineChart';
import type { MarketItem } from 'shared-types';
import type { ViewportState } from './ChartPageLayout';

interface MultiChartGridProps {
tokens: MarketItem[];
onBlockToken: (contractAddress: string) => void;
timeframe: string;
viewportState: ViewportState | null;
onViewportChange: (state: ViewportState | null) => void;
activeChartId: string | null;
onSetActiveChart: (id: string | null) => void;
}

const MultiChartGrid: Component<MultiChartGridProps> = (props) => {
const chartData = createMemo(() => {
const currentTokens = props.tokens || [];
return Array.from({ length: 9 }).map((_, i) => currentTokens[i]);
});

return (
<div id="chart-grid-container">
<For each={chartData()}>
{(token) => (
<SingleKlineChart
tokenInfo={token}
onBlock={props.onBlockToken}
timeframe={props.timeframe}
viewportState={props.viewportState}
onViewportChange={props.onViewportChange}
activeChartId={props.activeChartId}
onSetActiveChart={props.onSetActiveChart}
showAxes={true}
/>
)}
</For>
</div>
);
};

export default MultiChartGrid;

3. ä¿®æ”¹ packages/frontend/src/SingleKlineChart.tsx

è¿™æ˜¯æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ getVisibleRange() (è·å–æ—¶é—´) å’Œ setVisibleRange() (è®¾ç½®æ—¶é—´) æ›¿ä»£åŸæœ‰çš„ LogicalRange é€»è¾‘ã€‚

code
download
content_copy
expand_less
packages/frontend/src/SingleKlineChart.tsx
// packages/frontend/src/SingleKlineChart.tsx

/** @jsxImportSource solid-js */

import { Component, onMount, onCleanup, createEffect, Show, createSignal } from 'solid-js';
import { createChart, ColorType, IChartApi, ISeriesApi, CandlestickData, CandlestickSeries, Time } from 'lightweight-charts';
import { socket } from './socket';
import type { LightweightChartKline, KlineUpdatePayload, KlineFetchErrorPayload } from './types';
import type { MarketItem } from 'shared-types';
import type { ViewportState } from './ChartPageLayout';

const BACKEND_URL = 'http://localhost:3001';

interface SingleKlineChartProps {
tokenInfo: MarketItem | undefined;
onBlock?: (contractAddress: string) => void;
timeframe: string;
viewportState: ViewportState | null;
onViewportChange?: (state: ViewportState | null) => void;
activeChartId: string | null;
onSetActiveChart?: (id: string | null) => void;
showAxes?: boolean;
}

const customPriceFormatter = (price: number): string => {
if (price === 0) return '0';
if (price < 0.000001) {
return price.toFixed(12).replace(/.?0+$/, "");
}
if (price < 1) return price.toFixed(6);
return price.toFixed(2);
};

const SingleKlineChart: Component<SingleKlineChartProps> = (props) => {
let chartContainer: HTMLDivElement;
let chart: IChartApi | null = null;
let candlestickSeries: ISeriesApi<'Candlestick'> | null = null;
let resizeObserver: ResizeObserver | null = null;

code
Code
download
content_copy
expand_less
const [status, setStatus] = createSignal('Initializing...');
// âœ¨ ç§»é™¤ lastBarIndexï¼Œç°åœ¨ä½¿ç”¨çº¯æ—¶é—´åŒæ­¥

// æ ‡è®°æ˜¯å¦æ­£åœ¨é€šè¿‡ä»£ç è®¾ç½®èŒƒå›´ï¼Œé¿å…å¾ªç¯è§¦å‘äº‹ä»¶
let isProgrammaticUpdate = false;

const getLogId = () => `[${props.tokenInfo?.symbol || '???'} @ ${props.timeframe}]`;

const cleanupChart = () => {
    if (chart) {
        chart.remove();
        chart = null;
        candlestickSeries = null;
    }
};

const unsubscribeRealtime = (payload: { address: string; chain: string; interval: string }) => {
    socket.off('kline_update', handleKlineUpdate);
    socket.emit('unsubscribe_kline', payload);
};

const handleKlineUpdate = (update: KlineUpdatePayload) => {
    const info = props.tokenInfo;
    if (!info) return;
    const chainToPoolId: Record<string, number> = { bsc: 14, sol: 16, solana: 16, base: 199 };
    const poolId = chainToPoolId[info.chain.toLowerCase()];
    const expectedRoom = `kl@${poolId}@${info.contractAddress}@${props.timeframe}`;

    if (update.room === expectedRoom) {
        candlestickSeries?.update(update.data as CandlestickData<number>);
    }
};

createEffect(() => {
    const info = props.tokenInfo;
    const timeframe = props.timeframe;

    if (!info || !timeframe) {
        cleanupChart();
        setStatus('No token selected.');
        return;
    }

    cleanupChart();
    setStatus(`Loading ${info.symbol}...`);
    
    if (!chartContainer) {
        return;
    }

    const logId = `[${info.symbol} @ ${timeframe}]`;

    try {
        chart = createChart(chartContainer, {
            width: chartContainer.clientWidth, 
            height: chartContainer.clientHeight,
            layout: { background: { type: ColorType.Solid, color: '#ffffff' }, textColor: '#333' },
            grid: { vertLines: { color: '#f0f3fa' }, horzLines: { color: '#f0f3fa' } },
            timeScale: { 
                visible: !!props.showAxes, 
                borderColor: '#cccccc', 
                timeVisible: true, 
                secondsVisible: false 
            },
            rightPriceScale: { visible: !!props.showAxes, borderColor: '#cccccc', autoScale: true },
            leftPriceScale: { visible: false },
            handleScroll: true, 
            handleScale: true,
        });

        candlestickSeries = chart.addSeries(CandlestickSeries, {
            priceFormat: { 
                type: 'price', 
                precision: 10,
                minMove: 0.00000001, 
                formatter: customPriceFormatter 
            },
            upColor: '#28a745', downColor: '#dc3545', borderDownColor: '#dc3545',
            borderUpColor: '#28a745', wickDownColor: '#dc3545', wickUpColor: '#28a745',
        });

    } catch (e) {
        console.error(`${logId} âŒ Failed to create chart:`, e);
        setStatus(`Chart Error: ${e}`);
        return;
    }

    // âœ¨ æ ¸å¿ƒä¿®æ”¹ 1: ç›‘å¬è§†å›¾å˜åŒ–ï¼Œè½¬æ¢ä¸ºæ—¶é—´èŒƒå›´å¹¶å‘ä¸Šå†’æ³¡
    chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
        if (props.activeChartId === props.tokenInfo?.contractAddress && !isProgrammaticUpdate) {
            const timeRange = chart?.timeScale().getVisibleRange();
            if (timeRange && props.onViewportChange) {
                // lightweight-charts è¿”å›çš„ Time å¯ä»¥æ˜¯ string æˆ– number (seconds)
                // æˆ‘ä»¬çš„æ•°æ®æ˜¯ Unix timestamp (seconds)ï¼Œæ‰€ä»¥å¼ºåˆ¶è½¬æ¢
                props.onViewportChange({ 
                    from: Number(timeRange.from), 
                    to: Number(timeRange.to) 
                });
            }
        }
    });

    const payload = { address: info.contractAddress, chain: info.chain, interval: timeframe };

    // å¤„ç†æ•°æ®çš„é€šç”¨é€»è¾‘
    const processData = (data: any[], isInitial: boolean) => {
         try {
            // è½¬æ¢å’Œæ’åº
            const sortedData = data
                .map(d => ({ ...d, time: Number(d.time) }))
                .sort((a, b) => a.time - b.time);

            if (isInitial) {
                candlestickSeries?.setData(sortedData as CandlestickData<number>[]);
                
                // âœ¨ æ ¸å¿ƒä¿®æ”¹ 2: åˆå§‹åŒ–æ—¶ï¼Œå¦‚æœæœ‰çˆ¶çº§ viewportStateï¼Œä¼˜å…ˆä½¿ç”¨
                if (props.viewportState) {
                     chart?.timeScale().setVisibleRange({
                        from: props.viewportState.from as Time,
                        to: props.viewportState.to as Time
                    });
                } else {
                    chart?.timeScale().fitContent();
                }
            } else {
                // åˆå¹¶æ•°æ®é€»è¾‘ (ç®€åŒ–ç‰ˆï¼Œç›´æ¥ setData è¦†ç›–é€šå¸¸åœ¨è½»é‡çº§å›¾è¡¨é‡Œæ€§èƒ½å°šå¯ï¼Œæˆ–è€…åš merge)
                // è¿™é‡Œä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬å‡è®¾ completed data æ˜¯å…¨é‡æ›´æ–°æˆ–è€…è¿½åŠ 
                const currentData = (candlestickSeries?.data() as CandlestickData<number>[] || []);
                const newDataMap = new Map(currentData.map(d => [d.time, d]));
                sortedData.forEach(d => newDataMap.set(d.time as number, d as CandlestickData<number>));
                const merged = Array.from(newDataMap.values()).sort((a, b) => (a.time as number) - (b.time as number));
                candlestickSeries?.setData(merged);
                
                if (currentData.length === 0 && !props.viewportState) {
                    chart?.timeScale().fitContent();
                }
            }
            
            setStatus(`Live: ${info.symbol} ${timeframe}`);
        } catch (e) {
            console.error(`${logId} âŒ Failed to process data:`, e);
        }
    };

    const handleInitialData = (response: any) => {
        if (response.interval !== timeframe || response.address.toLowerCase() !== info.contractAddress.toLowerCase()) return;
        if (response.data && response.data.length > 0) {
            processData(response.data, true);
        } else {
            setStatus(`Waiting for data...`);
        }
    };
    
    const handleCompletedData = (response: any) => {
        if (response.interval !== timeframe || response.address.toLowerCase() !== info.contractAddress.toLowerCase()) return;
        if (response.data && response.data.length > 0) {
            processData(response.data, false);
        }
    };
    
    const handleFetchError = (err: KlineFetchErrorPayload) => {
         const key = `${info.contractAddress.toLowerCase()}@${info.chain.toLowerCase()}@${timeframe}`;
         if(err.key === key) {
            setStatus(`Error: ${err.error}`);
         }
    };

    socket.on('historical_kline_initial', handleInitialData);
    socket.on('historical_kline_completed', handleCompletedData);
    socket.on('kline_fetch_error', handleFetchError);
    socket.on('kline_update', handleKlineUpdate);

    socket.emit('request_historical_kline', payload);
    socket.emit('subscribe_kline', payload); 

    onCleanup(() => {
        unsubscribeRealtime(payload);
        socket.off('historical_kline_initial', handleInitialData);
        socket.off('historical_kline_completed', handleCompletedData);
        socket.off('kline_fetch_error', handleFetchError);
        cleanupChart();
    });
});

// âœ¨ æ ¸å¿ƒä¿®æ”¹ 3: å“åº” ViewportState å˜åŒ–ï¼Œä½¿ç”¨ setVisibleRange (Time Based)
createEffect(() => {
    const vs = props.viewportState;
    // åªæœ‰å½“å­˜åœ¨ viewportï¼Œä¸”å½“å‰å›¾è¡¨ä¸æ˜¯ç”¨æˆ·æ­£åœ¨æ“ä½œçš„é‚£ä¸ªå›¾è¡¨æ—¶ï¼Œæ‰åº”ç”¨åŒæ­¥
    if (chart && vs && props.activeChartId !== props.tokenInfo?.contractAddress) {
        isProgrammaticUpdate = true;
        try {
            chart.timeScale().setVisibleRange({
                from: vs.from as Time,
                to: vs.to as Time
            });
        } catch (e) {
            // æŸäº›æƒ…å†µä¸‹ï¼ˆå¦‚æ•°æ®å°šæœªåŠ è½½ï¼‰ï¼ŒsetVisibleRange å¯èƒ½ä¼šæŠ¥é”™ï¼Œå¯ä»¥å¿½ç•¥æˆ–è®°å½•
            // console.warn("Sync error:", e);
        }
        // æ¢å¤æ ‡è®°ï¼Œä½¿ç”¨ setTimeout ç¡®ä¿å½“å‰è°ƒç”¨æ ˆæ¸…ç©º
        setTimeout(() => { isProgrammaticUpdate = false; }, 0);
    }
});

onMount(() => {
    resizeObserver = new ResizeObserver(entries => {
        if (chart && chartContainer) {
            const { width, height } = entries[0].contentRect;
            chart.applyOptions({ width, height });
        }
    });
    if (chartContainer) {
        resizeObserver.observe(chartContainer);
    }
});

onCleanup(() => resizeObserver?.disconnect());

return (
    <div 
        class="single-chart-wrapper"
        onMouseEnter={() => props.tokenInfo && props.onSetActiveChart?.(props.tokenInfo.contractAddress)}
        onMouseLeave={() => props.onSetActiveChart?.(null)}
    >
        <div class="chart-header">
            <Show when={props.tokenInfo} fallback={<span class="placeholder">{status()}</span>}>
                <img src={`${BACKEND_URL}/image-proxy?url=${encodeURIComponent(props.tokenInfo!.icon!)}`} class="icon-small" alt={props.tokenInfo!.symbol}/>
                <span class="symbol-title">{props.tokenInfo!.symbol}</span>
                <span class="chain-badge">{props.tokenInfo!.chain.toUpperCase()}</span>
                <button class="block-button" title={`å±è”½ ${props.tokenInfo!.symbol}`} onClick={() => props.onBlock?.(props.tokenInfo!.contractAddress)}>
                    ğŸš«
                </button>
            </Show>
        </div>
        <div ref={chartContainer!} class="chart-container" />
    </div>
);

};

export default SingleKlineChart;