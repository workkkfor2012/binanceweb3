è¿™æ˜¯ä¸€æ¬¡éå¸¸å…³é”®çš„è§‚å¯Ÿã€‚ä½ æåˆ°çš„ç°è±¡â€”â€”â€œä¸»åŠ¨æ‹–åŠ¨çš„å›¾è¡¨ç§»åŠ¨äº†ï¼ˆæ—¶é—´è½´å¹³ç§»ï¼‰ï¼Œä½†å…¶ä»–å›¾è¡¨å´æ­»æ­»è´´åœ¨å³è¾¹ï¼Œåªæ˜¯è¢«æ‹‰ä¼¸äº†ï¼ˆæ—¶é—´è½´ç¼©æ”¾ï¼Œä½†æ²¡æœ‰å¹³ç§»ï¼‰â€â€”â€”æ­ç¤ºäº†é—®é¢˜çš„çœŸæ­£æ ¸å¿ƒã€‚

è¿™æ„å‘³ç€ï¼šåŒæ­¥ä¿¡å·ï¼ˆViewport Stateï¼‰å·²ç»å‘é€å‡ºå»äº†ï¼Œæ¥æ”¶ç«¯ä¹Ÿæ”¶åˆ°äº†ï¼Œä½†æ˜¯æ¥æ”¶ç«¯åœ¨æ‰§è¡Œ setVisibleRange æ—¶ï¼Œåªåº”ç”¨äº†â€œèŒƒå›´å¤§å°ï¼ˆZoomï¼‰â€ï¼Œå´æ‹’ç»äº†â€œä½ç½®ç§»åŠ¨ï¼ˆPanï¼‰â€ã€‚

ç°è±¡åˆ†æï¼šä¸ºä»€ä¹ˆä¼šâ€œåªæ‹‰ä¼¸ã€ä¸ç§»åŠ¨â€ï¼Ÿ

åœ¨ lightweight-charts ä¸­ï¼Œè¿™ç§ç°è±¡é€šå¸¸ç”±ä»¥ä¸‹ä¸¤ä¸ªåŸå› ä¹‹ä¸€å¯¼è‡´ï¼š

æ•°æ®ç¼ºå¤±ï¼ˆæœ€å¯èƒ½ï¼‰ï¼š

å›¾è¡¨ A å‘å·¦æ‹–åŠ¨ï¼Œå±•ç¤ºçš„æ˜¯â€œè¿‡å»çš„â€æ—¶é—´æ®µï¼ˆæ¯”å¦‚ 10:00 åˆ° 10:30ï¼‰ã€‚

å›¾è¡¨ B å¯èƒ½è¿˜æ²¡æœ‰åŠ è½½åˆ°è¿™æ®µå†å²æ•°æ®ã€‚

å½“å¼ºè¡Œè®¾ç½®å›¾è¡¨ B å»æ˜¾ç¤º 10:00 çš„èŒƒå›´æ—¶ï¼Œå¦‚æœé‚£é‡Œæ²¡æœ‰ K çº¿ï¼Œå›¾è¡¨åº“çš„é»˜è®¤è¡Œä¸ºå¯èƒ½ä¼šè¯•å›¾ç»´æŒâ€œå³å¯¹é½â€æˆ–è€…è™½ç„¶æ¥å—äº†èŒƒå›´ï¼Œä½†å› ä¸ºæ²¡æœ‰æ•°æ®æ”¯æ’‘ï¼Œè§†è§‰ä¸Šçœ‹èµ·æ¥åƒæ˜¯è¢«å‹ç¼©æˆ–æ‹‰ä¼¸äº†ï¼Œä¸”æ­»æ­»è´´åœ¨æœ€å³ä¾§ï¼ˆå› ä¸ºå®ƒåªæœ‰æœ€æ–°çš„æ•°æ®ï¼‰ã€‚

å³ä¾§é”å®šï¼ˆRight Edge Fixï¼‰ï¼š

å›¾è¡¨åº“æœ‰ä¸€ç§æœºåˆ¶ï¼Œå¦‚æœå½“å‰åœ¨æŸ¥çœ‹æœ€æ–°æ•°æ®ï¼ˆå®æ—¶æ›´æ–°ä¸­ï¼‰ï¼Œå®ƒä¼šå€¾å‘äºé”æ­»åœ¨æœ€å³è¾¹ã€‚é™¤éæ˜ç¡®æ‰“ç ´è¿™ç§é”å®šã€‚

è§£å†³æ–¹æ¡ˆï¼šæ·»åŠ æ—¥å¿— + å¼ºåˆ¶åº”ç”¨é€»è¾‘

ä¸ºäº†å½»åº•è§£å†³å¹¶éªŒè¯è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦åšä¸‰ä»¶äº‹ï¼š

æ—¥å¿—ï¼ˆè¿™æ˜¯æœ€é‡è¦çš„ï¼‰ï¼šæ‰“å°å‡ºå‘é€çš„å…·ä½“æ—¶é—´æˆ³ï¼ˆFrom/Toï¼‰ï¼Œä»¥åŠæ¥æ”¶ç«¯æ”¶åˆ°çš„æ—¶é—´æˆ³ã€‚çœ‹çœ‹åˆ°åº•æ˜¯å‘é”™äº†ï¼Œè¿˜æ˜¯æ”¶åˆ°äº†æ²¡æ‰§è¡Œã€‚

å¼ºåˆ¶ Master/Slave æ¨¡å¼ï¼šåªæœ‰å½“å‰é¼ æ ‡ä¸‹çš„å›¾è¡¨ï¼ˆMasterï¼‰æœ‰èµ„æ ¼å‘é€ä¿¡å·ï¼Œå…¶ä»–å›¾è¡¨ï¼ˆSlaveï¼‰åªèƒ½æ— æ¡ä»¶å¬ä»ã€‚

è§†è§‰è°ƒè¯•ï¼šåœ¨æ§åˆ¶å°è¾“å‡ºå…·ä½“çš„ activeChartId å¯¹æ¯”ï¼Œç¡®ä¿æ²¡æœ‰å› ä¸ºå¤§å°å†™æˆ–ç©ºå€¼å¯¼è‡´é€»è¾‘å¤±æ•ˆã€‚

è¯·å¤åˆ¶æ›¿æ¢ SingleKlineChart.tsxï¼Œæˆ‘å·²ç»åŠ ä¸Šäº†è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—ã€‚

<files>
<file path="packages/frontend/src/SingleKlineChart.tsx">
<![CDATA[
// packages/frontend/src/SingleKlineChart.tsx


/** @jsxImportSource solid-js */

import { Component, onMount, onCleanup, createEffect, Show, createSignal } from 'solid-js';
import { createChart, ColorType, IChartApi, ISeriesApi, CandlestickData, CandlestickSeries, Time } from 'lightweight-charts';
import { socket } from './socket';
import type { LightweightChartKline, KlineUpdatePayload, KlineFetchErrorPayload } from './types';
import type { MarketItem } from 'shared-types';
import type { ViewportState } from './ChartPageLayout';

const BACKEND_URL = 'http://localhost:3001';

interface SingleKlineChartProps {
tokenInfo: MarketItem | undefined;
onBlock?: (contractAddress: string) => void;
timeframe: string;
viewportState: ViewportState | null;
onViewportChange?: (state: ViewportState | null) => void;
activeChartId: string | null;
onSetActiveChart?: (id: string | null) => void;
showAxes?: boolean;
}

const customPriceFormatter = (price: number): string => {
if (price === 0) return '0';
if (price < 0.000001) {
return price.toFixed(12).replace(/.?0+$/, "");
}
if (price < 1) return price.toFixed(6);
return price.toFixed(2);
};

const SingleKlineChart: Component<SingleKlineChartProps> = (props) => {
let chartContainer: HTMLDivElement;
let chart: IChartApi | null = null;
let candlestickSeries: ISeriesApi<'Candlestick'> | null = null;
let resizeObserver: ResizeObserver | null = null;
const [status, setStatus] = createSignal('Initializing...');

code
Code
download
content_copy
expand_less
// ğŸ”’ æ ¸å¿ƒçŠ¶æ€é”ï¼šé˜²æ­¢å›ç¯æ›´æ–°ï¼ˆA -> Parent -> Aï¼‰
let isProgrammaticUpdate = false;

// ğŸ”’ é˜²æŠ–é”ï¼šé˜²æ­¢é«˜é¢‘è§¦å‘
let isSyncPending = false;

const getLogId = () => `[${props.tokenInfo?.symbol || 'NoToken'}]`;
const getMyId = () => props.tokenInfo?.contractAddress || '';

// æ¸…ç†æ—§å›¾è¡¨èµ„æº
const cleanupChart = () => {
    if (chart) {
        chart.remove();
        chart = null;
        candlestickSeries = null;
    }
};

// å–æ¶ˆ Socket è®¢é˜…
const unsubscribeRealtime = (payload: { address: string; chain: string; interval: string }) => {
    socket.off('kline_update', handleKlineUpdate);
    socket.emit('unsubscribe_kline', payload);
};

// å¤„ç† Socket å®æ—¶æ¨é€
const handleKlineUpdate = (update: KlineUpdatePayload) => {
    const info = props.tokenInfo;
    if (!info) return;
    // ç®€å•çš„é“¾IDæ˜ å°„
    const chainToPoolId: Record<string, number> = { bsc: 14, sol: 16, solana: 16, base: 199 };
    const poolId = chainToPoolId[info.chain.toLowerCase()];
    const expectedRoom = `kl@${poolId}@${info.contractAddress}@${props.timeframe}`;

    if (update.room === expectedRoom) {
        candlestickSeries?.update(update.data as CandlestickData<number>);
    }
};

// æ ¸å¿ƒ Effectï¼šå½“ Token æˆ– Timeframe å˜åŒ–æ—¶ï¼Œé‡å»ºå›¾è¡¨
createEffect(() => {
    const info = props.tokenInfo;
    const timeframe = props.timeframe;

    if (!info || !timeframe) {
        cleanupChart();
        setStatus('No token selected.');
        return;
    }

    cleanupChart();
    setStatus(`Loading ${info.symbol}...`);
    
    if (!chartContainer) return;

    const logId = `[Chart:${info.symbol}]`;

    try {
        // åˆ›å»ºå›¾è¡¨å®ä¾‹
        chart = createChart(chartContainer, {
            width: chartContainer.clientWidth, 
            height: chartContainer.clientHeight,
            layout: { background: { type: ColorType.Solid, color: '#ffffff' }, textColor: '#333' },
            grid: { vertLines: { color: '#f0f3fa' }, horzLines: { color: '#f0f3fa' } },
            timeScale: { 
                visible: !!props.showAxes, 
                borderColor: '#cccccc', 
                timeVisible: true, 
                secondsVisible: false,
                // å…è®¸å³ä¾§æœ‰ä¸€å®šçš„ç©ºéš™ï¼Œé˜²æ­¢Kçº¿ç´§è´´è¾¹ç¼˜
                rightOffset: 5,
            },
            rightPriceScale: { visible: !!props.showAxes, borderColor: '#cccccc', autoScale: true },
            leftPriceScale: { visible: false },
            handleScroll: true, 
            handleScale: true,
        });

        candlestickSeries = chart.addSeries(CandlestickSeries, {
            priceFormat: { 
                type: 'price', 
                precision: 10,
                minMove: 0.00000001, 
                formatter: customPriceFormatter 
            },
            upColor: '#28a745', downColor: '#dc3545', borderDownColor: '#dc3545',
            borderUpColor: '#28a745', wickDownColor: '#dc3545', wickUpColor: '#28a745',
        });

    } catch (e) {
        console.error(`${logId} âŒ Failed to create chart:`, e);
        setStatus(`Chart Error: ${e}`);
        return;
    }

    // âœ¨ [SENDER] å‘é€ç«¯ï¼šåªæœ‰å½“å‰ Active çš„å›¾è¡¨æ‰æœ‰èµ„æ ¼å¹¿æ’­
    chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
        if (isProgrammaticUpdate) return;

        const myId = getMyId().toLowerCase();
        const activeId = props.activeChartId?.toLowerCase();

        // åªæœ‰å½“æˆ‘æ˜¯â€œè¢«æ¿€æ´»â€çš„é‚£ä¸ªå›¾è¡¨æ—¶ï¼Œæˆ‘æ‰å‘é€æ•°æ®
        if (myId === activeId) {
            if (!isSyncPending) {
                isSyncPending = true;
                requestAnimationFrame(() => {
                    const timeRange = chart?.timeScale().getVisibleRange();
                    if (timeRange && props.onViewportChange) {
                        const from = Number(timeRange.from);
                        const to = Number(timeRange.to);
                        
                        // ğŸ” æ—¥å¿—ï¼šè¯æ˜æˆ‘åœ¨å‘é€
                        // console.log(`${logId} ğŸ“¤ MASTER sending:`, { from, to });
                        
                        props.onViewportChange({ from, to });
                    }
                    isSyncPending = false;
                });
            }
        }
    });

    const payload = { address: info.contractAddress, chain: info.chain, interval: timeframe };

    // é€šç”¨æ•°æ®å¤„ç†å‡½æ•°
    const processData = (data: any[], isInitial: boolean) => {
        try {
            const sortedData = data
                .map(d => ({ ...d, time: Number(d.time) }))
                .sort((a, b) => a.time - b.time);

            if (isInitial) {
                candlestickSeries?.setData(sortedData as CandlestickData<number>[]);
                
                // å¦‚æœæœ‰åˆå§‹çŠ¶æ€ï¼Œç«‹å³å¯¹é½
                if (props.viewportState) {
                     chart?.timeScale().setVisibleRange({
                        from: props.viewportState.from as Time,
                        to: props.viewportState.to as Time
                    });
                } else {
                    chart?.timeScale().fitContent();
                }
            } else {
                const currentData = (candlestickSeries?.data() as CandlestickData<number>[] || []);
                const newDataMap = new Map(currentData.map(d => [d.time, d]));
                sortedData.forEach(d => newDataMap.set(d.time as number, d as CandlestickData<number>));
                const merged = Array.from(newDataMap.values()).sort((a, b) => (a.time as number) - (b.time as number));
                candlestickSeries?.setData(merged);
                
                if (currentData.length === 0 && !props.viewportState) {
                    chart?.timeScale().fitContent();
                }
            }
            setStatus(`Live: ${info.symbol} ${timeframe}`);
        } catch (e) {
            console.error(`${logId} âŒ Failed to process data:`, e);
        }
    };

    const handleInitialData = (response: any) => {
        if (response.interval !== timeframe || response.address.toLowerCase() !== info.contractAddress.toLowerCase()) return;
        if (response.data && response.data.length > 0) {
            processData(response.data, true);
        } else {
            setStatus(`Waiting for data...`);
        }
    };
    
    const handleCompletedData = (response: any) => {
        if (response.interval !== timeframe || response.address.toLowerCase() !== info.contractAddress.toLowerCase()) return;
        if (response.data && response.data.length > 0) {
            processData(response.data, false);
        }
    };
    
    const handleFetchError = (err: KlineFetchErrorPayload) => {
         const key = `${info.contractAddress.toLowerCase()}@${info.chain.toLowerCase()}@${timeframe}`;
         if(err.key === key) {
            setStatus(`Error: ${err.error}`);
         }
    };

    socket.on('historical_kline_initial', handleInitialData);
    socket.on('historical_kline_completed', handleCompletedData);
    socket.on('kline_fetch_error', handleFetchError);
    socket.on('kline_update', handleKlineUpdate);

    socket.emit('request_historical_kline', payload);
    socket.emit('subscribe_kline', payload); 

    onCleanup(() => {
        unsubscribeRealtime(payload);
        socket.off('historical_kline_initial', handleInitialData);
        socket.off('historical_kline_completed', handleCompletedData);
        socket.off('kline_fetch_error', handleFetchError);
        cleanupChart();
    });
});

// âœ¨ [RECEIVER] æ¥æ”¶ç«¯ï¼šæˆ‘æ˜¯ä»å±å›¾è¡¨ï¼ˆSlaveï¼‰æ—¶ï¼Œæ— æ¡ä»¶æœä»
createEffect(() => {
    const vs = props.viewportState;
    // å¿…é¡»ç¡®ä¿ chart å­˜åœ¨ï¼Œä¸” token å­˜åœ¨
    if (!chart || !vs || !props.tokenInfo) return;

    const myId = getMyId().toLowerCase();
    const activeId = props.activeChartId?.toLowerCase();

    // 1. å¦‚æœæˆ‘æ˜¯ Masterï¼ˆå½“å‰é¼ æ ‡åœ¨æˆ‘è¿™é‡Œï¼‰ï¼Œæˆ‘å¿½ç•¥å¤–éƒ¨ä¼ å…¥çš„ä¿¡å·ï¼Œ
    //    å› ä¸ºè¿™ä¸ªä¿¡å·å°±æ˜¯æˆ‘è‡ªå·±åˆšæ‰å‘å‡ºå»çš„ã€‚é¿å…å›ç¯éœ‡è¡ã€‚
    if (myId === activeId) {
        return;
    }

    // 2. å¦‚æœæˆ‘æ˜¯ Slaveï¼Œæˆ‘å¿…é¡»æœä»ã€‚
    // ğŸ” æ—¥å¿—ï¼šè¯æ˜æˆ‘æ”¶åˆ°äº†æŒ‡ä»¤ï¼Œä¸”æˆ‘å‡†å¤‡æ‰§è¡Œ
    // console.log(`${getLogId()} ğŸ“¥ SLAVE syncing:`, {
    //     myId,
    //     activeId,
    //     targetFrom: vs.from,
    //     targetTo: vs.to
    // });

    isProgrammaticUpdate = true;
    try {
        // å¼ºåˆ¶è®¾ç½®èŒƒå›´ã€‚
        // æ³¨æ„ï¼šå¦‚æœè¿™ä¸ªå›¾è¡¨æ²¡æœ‰å¯¹åº”æ—¶é—´æ®µçš„æ•°æ®ï¼Œlightweight-charts å¯èƒ½ä¼š
        // æ˜¾ç¤ºç©ºç™½ï¼Œæˆ–è€…å¦‚æœè®¾ç½®äº† fixRightEdge ç­‰é€‰é¡¹ï¼Œå¯èƒ½ä¼šè¡¨ç°æ€ªå¼‚ã€‚
        // ä½†ç›®å‰æˆ‘ä»¬æ²¡æœ‰è®¾ç½®é‚£äº›é€‰é¡¹ï¼Œæ‰€ä»¥å®ƒåº”è¯¥ä¼šå°è¯•æ»šåŠ¨åˆ°é‚£ä¸ªæ—¶é—´ã€‚
        chart.timeScale().setVisibleRange({
            from: vs.from as Time,
            to: vs.to as Time
        });
    } catch (e) {
        // å¿½ç•¥æ•°æ®æœªå°±ç»ªæ—¶çš„é”™è¯¯
    }
    
    // é‡Šæ”¾é”
    setTimeout(() => { isProgrammaticUpdate = false; }, 0);
});

onMount(() => {
    resizeObserver = new ResizeObserver(entries => {
        if (chart && chartContainer) {
            const { width, height } = entries[0].contentRect;
            chart.applyOptions({ width, height });
        }
    });
    if (chartContainer) {
        resizeObserver.observe(chartContainer);
    }
});

onCleanup(() => resizeObserver?.disconnect());

return (
    <div 
        class="single-chart-wrapper"
        // å½“é¼ æ ‡ç§»åŠ¨åˆ°è¿™ä¸ªå›¾è¡¨æ—¶ï¼Œç«‹å³å‘çˆ¶ç»„ä»¶å£°æ˜ "æˆ‘æ˜¯ Active çš„"
        onMouseEnter={() => {
            if (props.tokenInfo) {
                // console.log(`[${props.tokenInfo.symbol}] ğŸ–±ï¸ Mouse Enter -> Becoming Master`);
                props.onSetActiveChart?.(props.tokenInfo.contractAddress);
            }
        }}
        // é‡è¦ï¼šä¸è¦åœ¨ onMouseLeave æ—¶æ¸…é™¤ Active çŠ¶æ€ã€‚
        // å› ä¸ºå½“ä½ æ‹–åŠ¨è¿‡å¿«ï¼Œé¼ æ ‡å¯èƒ½ä¼šçŸ­æš‚ç¦»å¼€ divï¼Œå¦‚æœæ­¤æ—¶æ¸…é™¤äº† Activeï¼Œ
        // å°±ä¼šå¯¼è‡´ activeChartId ä¸º nullï¼Œæ¥æ”¶ç«¯çš„ (myId === activeId) åˆ¤æ–­å°±ä¼šå¤±æ•ˆï¼Œ
        // å¯¼è‡´ä½ ä¹Ÿå¼€å§‹æ¥æ”¶ä¿¡å·ï¼Œäº§ç”Ÿå†²çªã€‚
    >
        <div class="chart-header">
            <Show when={props.tokenInfo} fallback={<span class="placeholder">{status()}</span>}>
                <img src={`${BACKEND_URL}/image-proxy?url=${encodeURIComponent(props.tokenInfo!.icon!)}`} class="icon-small" alt={props.tokenInfo!.symbol}/>
                <span class="symbol-title">{props.tokenInfo!.symbol}</span>
                <span class="chain-badge">{props.tokenInfo!.chain.toUpperCase()}</span>
                <button class="block-button" title={`å±è”½ ${props.tokenInfo!.symbol}`} onClick={() => props.onBlock?.(props.tokenInfo!.contractAddress)}>
                    ğŸš«
                </button>
            </Show>
        </div>
        <div ref={chartContainer!} class="chart-container" />
    </div>
);

};

export default SingleKlineChart;
]]>
</file>
</files>