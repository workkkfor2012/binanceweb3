你好！这确实是一个非常关键的逻辑修正。如果基础的计价单位（锚定资产）没有统一转换为 USDT，那么跨链的成交量对比（Hotlist 排序）和 K 线图的金额显示确实都是失真的。

你的分析非常清晰：所有的代币价格和成交量目前都是基于“链上原生币”（Native Token）的，我们需要引入“汇率”机制，将它们实时映射为 USDT。

这是一个涉及全局状态管理、实时数据流处理和计算逻辑修正的系统性工程。按照你的要求，我设计了一个分步实施方案，确保每一步都稳健且可验证。

核心思路

我们需要引入一个 NativePriceOracle（原生币价格预言机） 模块。
它负责维护全局唯一的三个变量：BNB_Price、SOL_Price、ETH_Price。
后端的所有其他模块（爬虫数据处理、WebSocket K 线推送、HTTP K 线历史）在处理数据时，都必须向这个预言机“询价”，然后进行乘法计算，最后输出给前端。

分步实施方案

我们将整个重构分为 4 个阶段，每个阶段完成后，你都可以通过日志清晰地看到数据流的变化。

第一阶段：建立基准 —— 全局价格预言机 (Global Native Price Oracle)

目标：在 Rust 后端启动时，建立一个全局共享的存储区域，并启动一个独立的 WebSocket 任务，专门监听 BNB、SOL、ETH 的 USDT 价格。

定义全局状态结构：

在 AppState 或新建一个 PriceCache 中添加存储结构，例如 DashMap<ChainId, f64>。

Chain ID 映射：

14 -> BNB 价格

16 -> SOL 价格

199 -> ETH 价格 (Base 链使用 ETH)

编写预言机任务 (oracle_task)：

复用现有的 WebSocket 逻辑，但这是一个死循环的常驻任务。

启动时订阅题目中提供的三个特定地址的交易流（或 K 线流，建议订阅 tx 或 1m K 线以获取最新价格）。

地址清单：

BNB (BSC, 14): 0xbb4...095c

SOL (SOL, 16): So111...1112

ETH (Base, 199): 0x420...0006

验证日志：

Log: [ORACLE] Initializing native price tracker...

Log: [ORACLE UPDATE] Chain 14 (BNB) Price updated: $605.23

Log: [ORACLE UPDATE] Chain 16 (SOL) Price updated: $145.67

Log: [ORACLE UPDATE] Chain 199 (ETH) Price updated: $3400.12

第二阶段：修正热点数据 —— 爬虫数据清洗 (Hotlist Sanitization)

目标：在 socket_handlers.rs 处理 data-update 时，利用第一阶段建立的价格，将成交量转换为 USDT。

拦截逻辑：

在解析 DataPayload 后，过滤逻辑执行之前。

遍历 data 列表。

根据每个 Item 的 chain_id，去全局 PriceCache 获取汇率。

计算逻辑：

New_Volume24h = Raw_Volume24h * Native_Price

New_Price = Raw_Price * Native_Price (如果 Item 中的 price 也是基于原生币的，这一步也需要做，否则市值计算也会错)。

过滤逻辑修正：

使用计算后的 USDT Volume 进行 MIN_HOTLIST_VOLUME (10000) 的过滤。

验证日志：

Log: [SPIDER DATA] Item 'BinanceLife' (Chain 14). Raw Vol: 100 BNB. Native Price: $600. Calced Vol: $60,000. -> Kept (Pass Filter)

Log: [SPIDER DATA] Item 'ShitCoin' (Chain 16). Raw Vol: 5 SOL. Native Price: $150. Calced Vol: $750. -> Dropped (Low Volume)

第三阶段：修正实时 K 线 —— WebSocket 推送计算 (Real-time Kline Calc)

目标：在 binance_task.rs 收到 tx (Tick) 或 kl (Kline) 数据时，实时计算 USDT 价格。

注入依赖：

将全局 PriceCache 传入 binance_websocket_task。

识别链 ID：

从 room_name (kl@14@0x...) 中解析出 pool_id (14/16/199)。

计算转换：

当收到 Price (原生币计价) 和 Volume (原生币数量) 时：

Price_USDT = Price_Native * Current_Native_Price

Volume_USDT = Volume_Native * Current_Native_Price

处理无价格情况：

如果系统刚启动，预言机还没拿到 BNB 价格怎么办？

方案：返回原始值或默认值，并打印警告（健壮性优先，不 crash）。

验证日志：

Log: [WS TICK] Chain 14. Raw P: 0.001, Raw V: 2.0. (BNB: $600). -> Broadcast P: $0.6, V: $1200.

第四阶段：修正历史 K 线 —— HTTP 数据计算 (Historical Kline Calc)

目标：在 kline_handler.rs 从 dquery 获取历史数据后，进行同样的转换。

注入依赖：

handle_kline_request 需要访问全局 PriceCache。

计算逻辑：

注意：这里有一个很难处理的点。历史 K 线（比如 3 天前的）应该乘以为“3 天前的 BNB 价格”还是“当前的 BNB 价格”？

理想方案：后端需要存储 BNB/SOL/ETH 的历史 K 线，通过时间戳对齐来计算。这非常复杂且消耗资源。

折中方案（健壮、高性能优先）：使用当前最新汇率进行估算，或者假设 dquery 接口能否通过参数直接返回 USD 计价？

根据目前方案：我们暂时使用当前全局汇率对历史数据的 Volume 和 Price 进行乘法修正。这虽然在金融上不绝对精确（因为以前的 BNB 价格不同），但对于观察热点趋势和量级通常是可接受的，且性能最好。

数据库存储调整：

存入 SQLite 的是原始数据还是计算后数据？

建议：存入计算后的 USDT 数据。这样读取速度快，且逻辑统一。如果未来汇率波动巨大，用户刷新页面会重新拉取（或利用缓存过期机制）。

验证日志：

Log: [HISTORY] Fetched 500 candles for Chain 16. Converting using SOL Price: $145. First Candle Vol: 100 -> 14500.
